{
  "address": "0xbE5d071Cce709F4bE5DAcBb7D9dCD6fBF5049791",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "oldAcross",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "newAcross",
          "type": "address"
        }
      ],
      "name": "AcrossUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "oldBurnRouter",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "newBurnRouter",
          "type": "address"
        }
      ],
      "name": "BurnRouterUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newChain",
          "type": "uint256"
        }
      ],
      "name": "ChainAdded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "oldChain",
          "type": "uint256"
        }
      ],
      "name": "ChainRemoved",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "lockerTargetAddress",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "recipientAddress",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address[2]",
          "name": "inputAndOutputToken",
          "type": "address[2]"
        },
        {
          "indexed": false,
          "internalType": "uint256[2]",
          "name": "inputAndOutputAmount",
          "type": "uint256[2]"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "speed",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "teleporter",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "bitcoinTxId",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "appId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "thirdPartyId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256[5]",
          "name": "fees",
          "type": "uint256[5]"
        }
      ],
      "name": "FailedWrapAndSwap",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "txId",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "time",
          "type": "uint256"
        }
      ],
      "name": "FillStarted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "remainingAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "filler",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "fillIdx",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "txId",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "reqMintedTeleBtc",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "sentTeleBtc",
          "type": "uint256"
        }
      ],
      "name": "FillTeleBtcSent",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "filler",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "fillIdx",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "txId",
          "type": "bytes32"
        }
      ],
      "name": "FillTokensReturned",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint8",
          "name": "version",
          "type": "uint8"
        }
      ],
      "name": "Initialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "mappedId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "middleChain",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "destinationChain",
          "type": "uint256"
        }
      ],
      "name": "NewChainIdMapping",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "filler",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "txId",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "NewFill",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "oldFillerWithdrawInterval",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newFillerWithdrawInterval",
          "type": "uint256"
        }
      ],
      "name": "NewFillerWithdrawInterval",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "oldInstantRouter",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "newInstantRouter",
          "type": "address"
        }
      ],
      "name": "NewInstantRouter",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "oldLockers",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "newLockers",
          "type": "address"
        }
      ],
      "name": "NewLockers",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "oldProtocolPercentageFee",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newProtocolPercentageFee",
          "type": "uint256"
        }
      ],
      "name": "NewProtocolPercentageFee",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "oldRelay",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "newRelay",
          "type": "address"
        }
      ],
      "name": "NewRelay",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "oldTeleBTC",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "newTeleBTC",
          "type": "address"
        }
      ],
      "name": "NewTeleBTC",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "thirdPartyId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "oldThirdPartyAddress",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "newThirdPartyAddress",
          "type": "address"
        }
      ],
      "name": "NewThirdPartyAddress",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "thirdPartyId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "oldThirdPartyFee",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newThirdPartyFee",
          "type": "uint256"
        }
      ],
      "name": "NewThirdPartyFee",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "oldTreasury",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "newTreasury",
          "type": "address"
        }
      ],
      "name": "NewTreasury",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "lockerTargetAddress",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address[2]",
          "name": "inputAndOutputToken",
          "type": "address[2]"
        },
        {
          "indexed": false,
          "internalType": "uint256[2]",
          "name": "inputAndOutputAmount",
          "type": "uint256[2]"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "speed",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "teleporter",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "bitcoinTxId",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "appId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "thirdPartyId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256[5]",
          "name": "fees",
          "type": "uint256[5]"
        }
      ],
      "name": "NewWrapAndSwap",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "appId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "exchangeConnector",
          "type": "address"
        }
      ],
      "name": "SetExchangeConnector",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "chainId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "newToken",
          "type": "address"
        }
      ],
      "name": "TokenAdded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "chainId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "oldToken",
          "type": "address"
        }
      ],
      "name": "TokenRemoved",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "across",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "burnRouter",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "chainId",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "chainIdMapping",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "middleChain",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "destinationChain",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "exchangeConnector",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "name": "extendedCcExchangeRequests",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "chainId",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "isTransferredToOtherChain",
          "type": "bool"
        },
        {
          "internalType": "uint256",
          "name": "remainedInputAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "bridgeFee",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "thirdParty",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "protocolFee",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "thirdPartyFee",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "lockerFee",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "chainId",
          "type": "uint256"
        }
      ],
      "name": "extractChainId",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "chainId",
          "type": "uint256"
        }
      ],
      "name": "extractDestinationChainId",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "fillerWithdrawInterval",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "fillersData",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "name": "fillsData",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "startingTime",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "reqToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "lastUsedIdx",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "remainingAmountOfLastFill",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "isWithdrawnLastFill",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_startingBlockNumber",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_protocolPercentageFee",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_chainId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "_lockers",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_relay",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_teleBTC",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_treasury",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_across",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_burnRouter",
          "type": "address"
        }
      ],
      "name": "initialize",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "instantRouter",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "isChainSupported",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "_txId",
          "type": "bytes32"
        }
      ],
      "name": "isRequestUsed",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "isTokenSupported",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "lockers",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "prefixFillSums",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "currentIndex",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "protocolPercentageFee",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "relay",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_chainId",
          "type": "uint256"
        }
      ],
      "name": "removeChain",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "chainId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "_token",
          "type": "address"
        }
      ],
      "name": "removeToken",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "_txId",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "_outputAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_acrossRelayerFee",
          "type": "uint256"
        },
        {
          "internalType": "address[]",
          "name": "path",
          "type": "address[]"
        },
        {
          "internalType": "bytes32",
          "name": "_r",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "_s",
          "type": "bytes32"
        },
        {
          "internalType": "uint8",
          "name": "_v",
          "type": "uint8"
        }
      ],
      "name": "retryFailedWrapAndSwap",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_across",
          "type": "address"
        }
      ],
      "name": "setAcross",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_burnRouter",
          "type": "address"
        }
      ],
      "name": "setBurnRouter",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_mappedId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_middleChain",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_destinationChain",
          "type": "uint256"
        }
      ],
      "name": "setChainIdMapping",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_appId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "_exchangeConnector",
          "type": "address"
        }
      ],
      "name": "setExchangeConnector",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_instantRouter",
          "type": "address"
        }
      ],
      "name": "setInstantRouter",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_lockers",
          "type": "address"
        }
      ],
      "name": "setLockers",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "middleChain",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "destinationChain",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "mappedId",
          "type": "uint256"
        }
      ],
      "name": "setMappingChainId",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_protocolPercentageFee",
          "type": "uint256"
        }
      ],
      "name": "setProtocolPercentageFee",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_relay",
          "type": "address"
        }
      ],
      "name": "setRelay",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_startingBlockNumber",
          "type": "uint256"
        }
      ],
      "name": "setStartingBlockNumber",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_teleBTC",
          "type": "address"
        }
      ],
      "name": "setTeleBTC",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_thirdPartyId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "_thirdPartyAddress",
          "type": "address"
        }
      ],
      "name": "setThirdPartyAddress",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_thirdPartyId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_thirdPartyFee",
          "type": "uint256"
        }
      ],
      "name": "setThirdPartyFee",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_treasury",
          "type": "address"
        }
      ],
      "name": "setTreasury",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "startingBlockNumber",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_chainId",
          "type": "uint256"
        }
      ],
      "name": "supportChain",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "chainId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "_token",
          "type": "address"
        }
      ],
      "name": "supportToken",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "teleBTC",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "thirdPartyAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "thirdPartyFee",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "treasury",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "_txId",
          "type": "bytes32"
        },
        {
          "internalType": "uint8",
          "name": "_scriptType",
          "type": "uint8"
        },
        {
          "internalType": "bytes",
          "name": "_userScript",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "_acrossRelayerFee",
          "type": "uint256"
        },
        {
          "internalType": "bytes32",
          "name": "_r",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "_s",
          "type": "bytes32"
        },
        {
          "internalType": "uint8",
          "name": "_v",
          "type": "uint8"
        },
        {
          "internalType": "bytes",
          "name": "_lockerLockingScript",
          "type": "bytes"
        }
      ],
      "name": "withdrawFailedWrapAndSwap",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "wmatic",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "bytes4",
              "name": "version",
              "type": "bytes4"
            },
            {
              "internalType": "bytes",
              "name": "vin",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "vout",
              "type": "bytes"
            },
            {
              "internalType": "bytes4",
              "name": "locktime",
              "type": "bytes4"
            },
            {
              "internalType": "uint256",
              "name": "blockNumber",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "intermediateNodes",
              "type": "bytes"
            },
            {
              "internalType": "uint256",
              "name": "index",
              "type": "uint256"
            }
          ],
          "internalType": "struct ICcExchangeRouter.TxAndProof",
          "name": "_txAndProof",
          "type": "tuple"
        },
        {
          "internalType": "bytes",
          "name": "_lockerLockingScript",
          "type": "bytes"
        },
        {
          "internalType": "address[]",
          "name": "_path",
          "type": "address[]"
        }
      ],
      "name": "wrapAndSwap",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "wrappedNativeToken",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "stateMutability": "payable",
      "type": "receive"
    }
  ],
  "transactionHash": "0x9610a34a0a404a68ef82665f1fd556c0e2033e486f1239c3a0236b42880cd6d3",
  "receipt": {
    "to": null,
    "from": "0xE1DE2FADF82f2812341C3aeB9f6ec3d052FF7105",
    "contractAddress": "0xbE5d071Cce709F4bE5DAcBb7D9dCD6fBF5049791",
    "transactionIndex": 1,
    "gasUsed": "4037419",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000010000000000000000000000020000000000000000000008000000000000000000000000000000000000000000000000000000000800000000000000000000100000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000002000000000000000010000000000000000000000200000000000000000000000000000000000000000100000000000000000004000000000000000000001000000000000000000000000000000100000001000000000000000000000000000000000000000000000000000000000000000100000",
    "blockHash": "0x3b717c4f3d8e71bd4d5b6d0ac886f61983c3da47b398d5e81a28774ebd8e3b7a",
    "transactionHash": "0x9610a34a0a404a68ef82665f1fd556c0e2033e486f1239c3a0236b42880cd6d3",
    "logs": [
      {
        "transactionIndex": 1,
        "blockNumber": 47784020,
        "transactionHash": "0x9610a34a0a404a68ef82665f1fd556c0e2033e486f1239c3a0236b42880cd6d3",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000e1de2fadf82f2812341c3aeb9f6ec3d052ff7105",
          "0x000000000000000000000000f903ba9e006193c1527bfbe65fe2123704ea3f99"
        ],
        "data": "0x00000000000000000000000000000000000000000000000001ae5055ef21e4000000000000000000000000000000000000000000000000007a9a33b907586bbf0000000000000000000000000000000000000000000013f2616a254ac4fd322000000000000000000000000000000000000000000000000078ebe363183687bf0000000000000000000000000000000000000000000013f2631875a0b41f1620",
        "logIndex": 2,
        "blockHash": "0x3b717c4f3d8e71bd4d5b6d0ac886f61983c3da47b398d5e81a28774ebd8e3b7a"
      }
    ],
    "blockNumber": 47784020,
    "cumulativeGasUsed": "4058419",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "4dbbda3723d3a5f07b26d477d3c1ab0a",
  "metadata": "{\"compiler\":{\"version\":\"0.8.2+commit.661d1103\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAcross\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAcross\",\"type\":\"address\"}],\"name\":\"AcrossUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldBurnRouter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newBurnRouter\",\"type\":\"address\"}],\"name\":\"BurnRouterUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newChain\",\"type\":\"uint256\"}],\"name\":\"ChainAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldChain\",\"type\":\"uint256\"}],\"name\":\"ChainRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"lockerTargetAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipientAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[2]\",\"name\":\"inputAndOutputToken\",\"type\":\"address[2]\"},{\"indexed\":false,\"internalType\":\"uint256[2]\",\"name\":\"inputAndOutputAmount\",\"type\":\"uint256[2]\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"speed\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"teleporter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"bitcoinTxId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"appId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"thirdPartyId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[5]\",\"name\":\"fees\",\"type\":\"uint256[5]\"}],\"name\":\"FailedWrapAndSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"txId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"FillStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"remainingAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"filler\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fillIdx\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"txId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reqMintedTeleBtc\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sentTeleBtc\",\"type\":\"uint256\"}],\"name\":\"FillTeleBtcSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"filler\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fillIdx\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"txId\",\"type\":\"bytes32\"}],\"name\":\"FillTokensReturned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mappedId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"middleChain\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"destinationChain\",\"type\":\"uint256\"}],\"name\":\"NewChainIdMapping\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"filler\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"txId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NewFill\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldFillerWithdrawInterval\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFillerWithdrawInterval\",\"type\":\"uint256\"}],\"name\":\"NewFillerWithdrawInterval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldInstantRouter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newInstantRouter\",\"type\":\"address\"}],\"name\":\"NewInstantRouter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldLockers\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newLockers\",\"type\":\"address\"}],\"name\":\"NewLockers\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldProtocolPercentageFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newProtocolPercentageFee\",\"type\":\"uint256\"}],\"name\":\"NewProtocolPercentageFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldRelay\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newRelay\",\"type\":\"address\"}],\"name\":\"NewRelay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldTeleBTC\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newTeleBTC\",\"type\":\"address\"}],\"name\":\"NewTeleBTC\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"thirdPartyId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldThirdPartyAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newThirdPartyAddress\",\"type\":\"address\"}],\"name\":\"NewThirdPartyAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"thirdPartyId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldThirdPartyFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newThirdPartyFee\",\"type\":\"uint256\"}],\"name\":\"NewThirdPartyFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldTreasury\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newTreasury\",\"type\":\"address\"}],\"name\":\"NewTreasury\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"lockerTargetAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[2]\",\"name\":\"inputAndOutputToken\",\"type\":\"address[2]\"},{\"indexed\":false,\"internalType\":\"uint256[2]\",\"name\":\"inputAndOutputAmount\",\"type\":\"uint256[2]\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"speed\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"teleporter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"bitcoinTxId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"appId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"thirdPartyId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[5]\",\"name\":\"fees\",\"type\":\"uint256[5]\"}],\"name\":\"NewWrapAndSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"appId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"exchangeConnector\",\"type\":\"address\"}],\"name\":\"SetExchangeConnector\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newToken\",\"type\":\"address\"}],\"name\":\"TokenAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldToken\",\"type\":\"address\"}],\"name\":\"TokenRemoved\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"across\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"chainIdMapping\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"middleChain\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destinationChain\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"exchangeConnector\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"extendedCcExchangeRequests\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isTransferredToOtherChain\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"remainedInputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bridgeFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"thirdParty\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protocolFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"thirdPartyFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockerFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"extractChainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"extractDestinationChainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fillerWithdrawInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"fillersData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"fillsData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"startingTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"reqToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lastUsedIdx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainingAmountOfLastFill\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isWithdrawnLastFill\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startingBlockNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_protocolPercentageFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_lockers\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_relay\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_teleBTC\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_across\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_burnRouter\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"instantRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"isChainSupported\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_txId\",\"type\":\"bytes32\"}],\"name\":\"isRequestUsed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isTokenSupported\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"prefixFillSums\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"currentIndex\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolPercentageFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"relay\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"}],\"name\":\"removeChain\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"removeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_txId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_outputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_acrossRelayerFee\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"}],\"name\":\"retryFailedWrapAndSwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_across\",\"type\":\"address\"}],\"name\":\"setAcross\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_burnRouter\",\"type\":\"address\"}],\"name\":\"setBurnRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mappedId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_middleChain\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_destinationChain\",\"type\":\"uint256\"}],\"name\":\"setChainIdMapping\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_appId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_exchangeConnector\",\"type\":\"address\"}],\"name\":\"setExchangeConnector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_instantRouter\",\"type\":\"address\"}],\"name\":\"setInstantRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lockers\",\"type\":\"address\"}],\"name\":\"setLockers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"middleChain\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destinationChain\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mappedId\",\"type\":\"uint256\"}],\"name\":\"setMappingChainId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_protocolPercentageFee\",\"type\":\"uint256\"}],\"name\":\"setProtocolPercentageFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_relay\",\"type\":\"address\"}],\"name\":\"setRelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startingBlockNumber\",\"type\":\"uint256\"}],\"name\":\"setStartingBlockNumber\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_teleBTC\",\"type\":\"address\"}],\"name\":\"setTeleBTC\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_thirdPartyId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_thirdPartyAddress\",\"type\":\"address\"}],\"name\":\"setThirdPartyAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_thirdPartyId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_thirdPartyFee\",\"type\":\"uint256\"}],\"name\":\"setThirdPartyFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"name\":\"setTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startingBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"}],\"name\":\"supportChain\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"supportToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teleBTC\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"thirdPartyAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"thirdPartyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_txId\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"_scriptType\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"_userScript\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_acrossRelayerFee\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"_lockerLockingScript\",\"type\":\"bytes\"}],\"name\":\"withdrawFailedWrapAndSwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wmatic\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes4\",\"name\":\"version\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"vin\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"vout\",\"type\":\"bytes\"},{\"internalType\":\"bytes4\",\"name\":\"locktime\",\"type\":\"bytes4\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"intermediateNodes\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"internalType\":\"struct ICcExchangeRouter.TxAndProof\",\"name\":\"_txAndProof\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"_lockerLockingScript\",\"type\":\"bytes\"},{\"internalType\":\"address[]\",\"name\":\"_path\",\"type\":\"address[]\"}],\"name\":\"wrapAndSwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wrappedNativeToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"initialize(uint256,uint256,uint256,address,address,address,address,address,address)\":{\"params\":{\"_chainId\":\"Id of the target chain\",\"_lockers\":\"Lockers' contract address\",\"_protocolPercentageFee\":\"Percentage amount of protocol fee (min: %0.01)\",\"_relay\":\"The Relay address to validate data from source chain\",\"_startingBlockNumber\":\"Requests that are included in a block older                              than _startingBlockNumber cannot be executed\",\"_teleBTC\":\"TeleportDAO BTC ERC20 token address\",\"_treasury\":\"Address of treasury that collects protocol fees\"}},\"isRequestUsed(bytes32)\":{\"details\":\"It prevents re-submitting an executed request\",\"params\":{\"_txId\":\"The transaction ID of request on Bitcoin \"},\"returns\":{\"_0\":\"True if the cc exchange request has been already executed\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.\"},\"retryFailedWrapAndSwap(bytes32,uint256,uint256,address[],bytes32,bytes32,uint8)\":{\"params\":{\"_acrossRelayerFee\":\"Fee that user pays to across relayer\",\"_outputAmount\":\"Amount of output token\",\"_r\":\"Signature r\",\"_s\":\"Signature s\",\"_txId\":\"The transaction ID of request on Bitcoin\",\"_v\":\"Signature v\",\"path\":\"Exchange path from teleBTC to the output token\"}},\"setChainIdMapping(uint256,uint256,uint256)\":{\"details\":\"Only owner can call this\"},\"setExchangeConnector(uint256,address)\":{\"details\":\"_exchangeConnector can be set to zero to inactive an app\"},\"setInstantRouter(address)\":{\"details\":\"Only owner can call this\",\"params\":{\"_instantRouter\":\"The new instantRouter contract address\"}},\"setThirdPartyAddress(uint256,address)\":{\"details\":\"Only owner can call this\",\"params\":{\"_thirdPartyAddress\":\"third party address\"}},\"setThirdPartyFee(uint256,uint256)\":{\"details\":\"Only owner can call this\",\"params\":{\"_thirdPartyFee\":\"third party fee\"}},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"},\"withdrawFailedWrapAndSwap(bytes32,uint8,bytes,uint256,bytes32,bytes32,uint8,bytes)\":{\"params\":{\"_acrossRelayerFee\":\"Fee that user pays to across relayer\",\"_lockerLockingScript\":\"Script hash of locker that user has sent BTC to it\",\"_r\":\"Signature r\",\"_s\":\"Signature s\",\"_scriptType\":\"Script type of the user script\",\"_txId\":\"The transaction ID of request on Bitcoin\",\"_userScript\":\"Script hash of the user on Bitcoin\",\"_v\":\"Signature v\"},\"returns\":{\"_0\":\"\"}},\"wrapAndSwap((bytes4,bytes,bytes,bytes4,uint256,bytes,uint256),bytes,address[])\":{\"details\":\"Mints teleBTC for user if exchanging is not successful\",\"params\":{\"_lockerLockingScript\":\"Script hash of locker that user has sent BTC to it\",\"_path\":\"(Optional) Exchange path from teleBTC to the output token. This is used if               the default path [teleBTC, wrappedNativeToken, outputToken] not exist or              exchanging using this path fails\",\"_txAndProof\":\"Transaction and merkle proof data\"},\"returns\":{\"_0\":\"true \"}}},\"version\":1},\"userdoc\":{\"events\":{\"FailedWrapAndSwap(address,address,address[2],uint256[2],uint256,address,bytes32,uint256,uint256,uint256[5])\":{\"notice\":\"Emits when a cc exchange request fails\"},\"FillStarted(bytes32,uint256)\":{\"notice\":\"Emits when a request is filled for the first time\"},\"FillTeleBtcSent(uint256,uint256,address,address,uint256,bytes32,uint256,uint256)\":{\"notice\":\"Emits when filler withdraws teleBTC\"},\"FillTokensReturned(uint256,address,address,uint256,bytes32)\":{\"notice\":\"Emits when unused tokens withdrawn\"},\"NewChainIdMapping(uint256,uint256,uint256)\":{\"notice\":\"Emits when changes made to chain id mapping\"},\"NewFill(address,bytes32,address,uint256)\":{\"notice\":\"Emits when a new filler fills a request\"},\"NewInstantRouter(address,address)\":{\"notice\":\"Emits when instant router contract updated\"},\"NewLockers(address,address)\":{\"notice\":\"Emits when lockers contract updated\"},\"NewProtocolPercentageFee(uint256,uint256)\":{\"notice\":\"Emits when protocol fee updated\"},\"NewRelay(address,address)\":{\"notice\":\"Emits when relay contract updated\"},\"NewTeleBTC(address,address)\":{\"notice\":\"Emits when telebtc contract updated\"},\"NewThirdPartyAddress(uint256,address,address)\":{\"notice\":\"Emits when changes made to third party address\"},\"NewThirdPartyFee(uint256,uint256,uint256)\":{\"notice\":\"Emits when changes made to third party fee\"},\"NewTreasury(address,address)\":{\"notice\":\"Emits when treasury address updated\"},\"NewWrapAndSwap(address,address,address[2],uint256[2],uint256,address,bytes32,uint256,uint256,uint256[5])\":{\"notice\":\"Emits when a cc exchange request gets done\"},\"SetExchangeConnector(uint256,address)\":{\"notice\":\"Emits when appId for an exchange connector is set\"}},\"kind\":\"user\",\"methods\":{\"initialize(uint256,uint256,uint256,address,address,address,address,address,address)\":{\"notice\":\"Gives default params to initiate cc exchange router\"},\"isRequestUsed(bytes32)\":{\"notice\":\"Checks if a request has been executed before\"},\"removeChain(uint256)\":{\"notice\":\"Removing a chainId\"},\"removeToken(uint256,address)\":{\"notice\":\"Removing a token as supported token on specific chain\"},\"retryFailedWrapAndSwap(bytes32,uint256,uint256,address[],bytes32,bytes32,uint8)\":{\"notice\":\"ETH user whose exchange request failed can retry          to exchange teleBTC for the desired token\"},\"setAcross(address)\":{\"notice\":\"Setter for across\"},\"setBurnRouter(address)\":{\"notice\":\"Setter for burnRouters\"},\"setChainIdMapping(uint256,uint256,uint256)\":{\"notice\":\"Setter for chain id mapping\"},\"setExchangeConnector(uint256,address)\":{\"notice\":\"Sets appId for an exchange connector\"},\"setInstantRouter(address)\":{\"notice\":\"Changes instantRouter contract address\"},\"setLockers(address)\":{\"notice\":\"Updates lockers contract address\"},\"setProtocolPercentageFee(uint256)\":{\"notice\":\"Setter for protocol percentage fee\"},\"setRelay(address)\":{\"notice\":\"Updates relay contract address\"},\"setStartingBlockNumber(uint256)\":{\"notice\":\"Setter for starting block number\"},\"setTeleBTC(address)\":{\"notice\":\"Updates teleBTC contract address\"},\"setThirdPartyAddress(uint256,address)\":{\"notice\":\"Setter for third party address\"},\"setThirdPartyFee(uint256,uint256)\":{\"notice\":\"Setter for third party fee\"},\"setTreasury(address)\":{\"notice\":\"Setter for treasury\"},\"supportChain(uint256)\":{\"notice\":\"Adding a new chainId\"},\"supportToken(uint256,address)\":{\"notice\":\"Adding a token as supported token on specific chain\"},\"withdrawFailedWrapAndSwap(bytes32,uint8,bytes,uint256,bytes32,bytes32,uint8,bytes)\":{\"notice\":\"ETH user whose request failed can redeem teleBTC for native BTC\"},\"wrapAndSwap((bytes4,bytes,bytes,bytes4,uint256,bytes,uint256),bytes,address[])\":{\"notice\":\"Executes a cross-chain exchange request after checking its merkle inclusion proof\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/routers/CcExchangeRouterLogic.sol\":\"CcExchangeRouterLogic\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000},\"remappings\":[]},\"sources\":{\"@across-protocol/contracts-v2/contracts/interfaces/SpokePoolInterface.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\n/**\\n * @notice Contains common data structures and functions used by all SpokePool implementations.\\n */\\ninterface SpokePoolInterface {\\n    // This leaf is meant to be decoded in the SpokePool to pay out successful relayers.\\n    struct RelayerRefundLeaf {\\n        // This is the amount to return to the HubPool. This occurs when there is a PoolRebalanceLeaf netSendAmount that\\n        // is negative. This is just the negative of this value.\\n        uint256 amountToReturn;\\n        // Used to verify that this is being executed on the correct destination chainId.\\n        uint256 chainId;\\n        // This array designates how much each of those addresses should be refunded.\\n        uint256[] refundAmounts;\\n        // Used as the index in the bitmap to track whether this leaf has been executed or not.\\n        uint32 leafId;\\n        // The associated L2TokenAddress that these claims apply to.\\n        address l2TokenAddress;\\n        // Must be same length as refundAmounts and designates each address that must be refunded.\\n        address[] refundAddresses;\\n    }\\n\\n    // This struct represents the data to fully specify a relay. If any portion of this data differs, the relay is\\n    // considered to be completely distinct. Only one relay for a particular depositId, chainId pair should be\\n    // considered valid and repaid. This data is hashed and inserted into the slow relay merkle root so that an off\\n    // chain validator can choose when to refund slow relayers.\\n    struct RelayData {\\n        // The address that made the deposit on the origin chain.\\n        address depositor;\\n        // The recipient address on the destination chain.\\n        address recipient;\\n        // The corresponding token address on the destination chain.\\n        address destinationToken;\\n        // The total relay amount before fees are taken out.\\n        uint256 amount;\\n        // Origin chain id.\\n        uint256 originChainId;\\n        // Destination chain id.\\n        uint256 destinationChainId;\\n        // The LP Fee percentage computed by the relayer based on the deposit's quote timestamp\\n        // and the HubPool's utilization.\\n        int64 realizedLpFeePct;\\n        // The relayer fee percentage specified in the deposit.\\n        int64 relayerFeePct;\\n        // The id uniquely identifying this deposit on the origin chain.\\n        uint32 depositId;\\n        // Data that is forwarded to the recipient.\\n        bytes message;\\n    }\\n\\n    struct SlowFill {\\n        RelayData relayData;\\n        int256 payoutAdjustmentPct;\\n    }\\n\\n    // Stores collection of merkle roots that can be published to this contract from the HubPool, which are referenced\\n    // by \\\"data workers\\\" via inclusion proofs to execute leaves in the roots.\\n    struct RootBundle {\\n        // Merkle root of slow relays that were not fully filled and whose recipient is still owed funds from the LP pool.\\n        bytes32 slowRelayRoot;\\n        // Merkle root of relayer refunds for successful relays.\\n        bytes32 relayerRefundRoot;\\n        // This is a 2D bitmap tracking which leaves in the relayer refund root have been claimed, with max size of\\n        // 256x(2^248) leaves per root.\\n        mapping(uint256 => uint256) claimedBitmap;\\n    }\\n\\n    function setCrossDomainAdmin(address newCrossDomainAdmin) external;\\n\\n    function setHubPool(address newHubPool) external;\\n\\n    function setEnableRoute(\\n        address originToken,\\n        uint256 destinationChainId,\\n        bool enable\\n    ) external;\\n\\n    function pauseDeposits(bool pause) external;\\n\\n    function pauseFills(bool pause) external;\\n\\n    function setDepositQuoteTimeBuffer(uint32 buffer) external;\\n\\n    function relayRootBundle(bytes32 relayerRefundRoot, bytes32 slowRelayRoot) external;\\n\\n    function emergencyDeleteRootBundle(uint256 rootBundleId) external;\\n\\n    function deposit(\\n        address recipient,\\n        address originToken,\\n        uint256 amount,\\n        uint256 destinationChainId,\\n        int64 relayerFeePct,\\n        uint32 quoteTimestamp,\\n        bytes memory message,\\n        uint256 maxCount\\n    ) external payable;\\n\\n    function depositNow(\\n        address recipient,\\n        address originToken,\\n        uint256 amount,\\n        uint256 destinationChainId,\\n        int64 relayerFeePct,\\n        bytes memory message,\\n        uint256 maxCount\\n    ) external payable;\\n\\n    function speedUpDeposit(\\n        address depositor,\\n        int64 updatedRelayerFeePct,\\n        uint32 depositId,\\n        address updatedRecipient,\\n        bytes memory updatedMessage,\\n        bytes memory depositorSignature\\n    ) external;\\n\\n    function fillRelay(\\n        address depositor,\\n        address recipient,\\n        address destinationToken,\\n        uint256 amount,\\n        uint256 maxTokensToSend,\\n        uint256 repaymentChainId,\\n        uint256 originChainId,\\n        int64 realizedLpFeePct,\\n        int64 relayerFeePct,\\n        uint32 depositId,\\n        bytes memory message,\\n        uint256 maxCount\\n    ) external;\\n\\n    function fillRelayWithUpdatedDeposit(\\n        address depositor,\\n        address recipient,\\n        address updatedRecipient,\\n        address destinationToken,\\n        uint256 amount,\\n        uint256 maxTokensToSend,\\n        uint256 repaymentChainId,\\n        uint256 originChainId,\\n        int64 realizedLpFeePct,\\n        int64 relayerFeePct,\\n        int64 updatedRelayerFeePct,\\n        uint32 depositId,\\n        bytes memory message,\\n        bytes memory updatedMessage,\\n        bytes memory depositorSignature,\\n        uint256 maxCount\\n    ) external;\\n\\n    function executeSlowRelayLeaf(\\n        address depositor,\\n        address recipient,\\n        address destinationToken,\\n        uint256 amount,\\n        uint256 originChainId,\\n        int64 realizedLpFeePct,\\n        int64 relayerFeePct,\\n        uint32 depositId,\\n        uint32 rootBundleId,\\n        bytes memory message,\\n        int256 payoutAdjustment,\\n        bytes32[] memory proof\\n    ) external;\\n\\n    function executeRelayerRefundLeaf(\\n        uint32 rootBundleId,\\n        SpokePoolInterface.RelayerRefundLeaf memory relayerRefundLeaf,\\n        bytes32[] memory proof\\n    ) external;\\n\\n    function chainId() external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x8ca5e32ee496553c1055954283747b6725356548dc35f5aad565e5cf37bf6449\",\"license\":\"BUSL-1.1\"},\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal onlyInitializing {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x247c62047745915c0af6b955470a72d1696ebad4352d7d3011aef1a2463cd888\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.1) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized < type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\",\"keccak256\":\"0x037c334add4b033ad3493038c25be1682d78c00992e1acb0e2795caff3925271\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    function __ReentrancyGuard_init() internal onlyInitializing {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x2b3005a0064cfc558bdf64b2bae94b565f4574a536aadd61c13838d4f2157790\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x4e733d3164f73f461eaf9d8087a7ad1ea180bdc8ba0d3d61b0e1ae16d8e63dff\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2edcb41c121abc510932e8d83ff8b82cf9cdde35e7c297622f5c29ef0af25183\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x963ea7f0b48b032eef72fe3a7582edf78408d6f834115b9feadd673a4d5bd149\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n        unchecked {\\n            _approve(sender, _msgSender(), currentAllowance - amount);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        uint256 senderBalance = _balances[sender];\\n        require(senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[sender] = senderBalance - amount;\\n        }\\n        _balances[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n\\n        _afterTokenTransfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\",\"keccak256\":\"0xb03df8481a954604ad0c9125680893b2e3f7ff770fe470e38b89ac61b84e8072\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0x027b891937d20ccf213fdb9c31531574256de774bda99d3a70ecef6e1913ed2a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x83fe24f5c04a56091e50f4a345ff504c8bff658a76d4c43b16878c8f940c53b2\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x3336baae5cf23e94274d75336e2d412193be508504aee185e61dc7d58cd05c8a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0x90565a39ae45c80f0468dc96c7b20d0afc3055f344c8203a0c9258239f350b9f\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128) {\\n        require(value >= type(int128).min && value <= type(int128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return int128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64) {\\n        require(value >= type(int64).min && value <= type(int64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return int64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32) {\\n        require(value >= type(int32).min && value <= type(int32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return int32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16) {\\n        require(value >= type(int16).min && value <= type(int16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return int16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8) {\\n        require(value >= type(int8).min && value <= type(int8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return int8(value);\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\",\"keccak256\":\"0x08d867b4c0bb782b9135691fa732b6846e0f133006489c3aa505abd1f6de56cb\",\"license\":\"MIT\"},\"@teleportdao/btc-evm-bridge/contracts/libraries/BitcoinHelper.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.8.4;\\n\\nimport \\\"./TypedMemView.sol\\\";\\nimport \\\"../types/ScriptTypesEnum.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\n\\nlibrary BitcoinHelper {\\n\\n    using SafeCast for uint96;\\n    using SafeCast for uint256;\\n\\n    using TypedMemView for bytes;\\n    using TypedMemView for bytes29;\\n\\n    // The target at minimum Difficulty. Also the target of the genesis block\\n    uint256 internal constant DIFF1_TARGET = 0xffff0000000000000000000000000000000000000000000000000000;\\n\\n    uint256 internal constant RETARGET_PERIOD = 2 * 7 * 24 * 60 * 60;  // 2 weeks in seconds\\n    uint256 internal constant RETARGET_PERIOD_BLOCKS = 2016;  // 2 weeks in blocks\\n\\n    enum BTCTypes {\\n        Unknown,            // 0x0\\n        CompactInt,         // 0x1\\n        ScriptSig,          // 0x2 - with length prefix\\n        Outpoint,           // 0x3\\n        TxIn,               // 0x4\\n        IntermediateTxIns,  // 0x5 - used in vin parsing\\n        Vin,                // 0x6\\n        ScriptPubkey,       // 0x7 - with length prefix\\n        PKH,                // 0x8 - the 20-byte payload digest\\n        WPKH,               // 0x9 - the 20-byte payload digest\\n        WSH,                // 0xa - the 32-byte payload digest\\n        SH,                 // 0xb - the 20-byte payload digest\\n        OpReturnPayload,    // 0xc\\n        TxOut,              // 0xd\\n        IntermediateTxOuts, // 0xe - used in vout parsing\\n        Vout,               // 0xf\\n        Header,             // 0x10\\n        HeaderArray,        // 0x11\\n        MerkleNode,         // 0x12\\n        MerkleStep,         // 0x13\\n        MerkleArray         // 0x14\\n    }\\n\\n    /// @notice             requires `memView` to be of a specified type\\n    /// @dev                passes if it is the correct type, errors if not\\n    /// @param memView      a 29-byte view with a 5-byte type\\n    /// @param t            the expected type (e.g. BTCTypes.Outpoint, BTCTypes.TxIn, etc)\\n    modifier typeAssert(bytes29 memView, BTCTypes t) {\\n        memView.assertType(uint40(t));\\n        _;\\n    }\\n\\n    // Revert with an error message re: non-minimal VarInts\\n    function revertNonMinimal(bytes29 ref) private pure returns (string memory) {\\n        (, uint256 g) = TypedMemView.encodeHex(ref.indexUint(0, ref.len().toUint8()));\\n        string memory err = string(\\n            abi.encodePacked(\\n                \\\"Non-minimal var int. Got 0x\\\",\\n                uint144(g)\\n            )\\n        );\\n        revert(err);\\n    }\\n\\n    /// @notice             reads a compact int from the view at the specified index\\n    /// @param memView      a 29-byte view with a 5-byte type\\n    /// @param _index       the index\\n    /// @return number      returns the compact int at the specified index\\n    function indexCompactInt(bytes29 memView, uint256 _index) internal pure returns (uint64 number) {\\n        uint256 flag = memView.indexUint(_index, 1);\\n        if (flag <= 0xfc) {\\n            return flag.toUint64();\\n        } else if (flag == 0xfd) {\\n            number = memView.indexLEUint(_index + 1, 2).toUint64();\\n            if (compactIntLength(number) != 3) {revertNonMinimal(memView.slice(_index, 3, 0));}\\n        } else if (flag == 0xfe) {\\n            number = memView.indexLEUint(_index + 1, 4).toUint64();\\n            if (compactIntLength(number) != 5) {revertNonMinimal(memView.slice(_index, 5, 0));}\\n        } else if (flag == 0xff) {\\n            number = memView.indexLEUint(_index + 1, 8).toUint64();\\n            if (compactIntLength(number) != 9) {revertNonMinimal(memView.slice(_index, 9, 0));}\\n        }\\n    }\\n\\n    /// @notice         gives the total length (in bytes) of a CompactInt-encoded number\\n    /// @param number   the number as uint64\\n    /// @return         the compact integer length as uint8\\n    function compactIntLength(uint64 number) private pure returns (uint8) {\\n        if (number <= 0xfc) {\\n            return 1;\\n        } else if (number <= 0xffff) {\\n            return 3;\\n        } else if (number <= 0xffffffff) {\\n            return 5;\\n        } else {\\n            return 9;\\n        }\\n    }\\n\\n    /// @notice             extracts the LE txid from an outpoint\\n    /// @param _outpoint    the outpoint\\n    /// @return             the LE txid\\n    function txidLE(bytes29 _outpoint) internal pure typeAssert(_outpoint, BTCTypes.Outpoint) returns (bytes32) {\\n        return _outpoint.index(0, 32);\\n    }\\n\\n    /// @notice                      Calculates the required transaction Id from the transaction details\\n    /// @dev                         Calculates the hash of transaction details two consecutive times\\n    /// @param _version              Version of the transaction\\n    /// @param _vin                  Inputs of the transaction\\n    /// @param _vout                 Outputs of the transaction\\n    /// @param _locktime             Lock time of the transaction\\n    /// @return                      Transaction Id of the transaction (in LE form)\\n    function calculateTxId(\\n        bytes4 _version,\\n        bytes memory _vin,\\n        bytes memory _vout,\\n        bytes4 _locktime\\n    ) internal pure returns (bytes32) {\\n        // Validates Vin length\\n        bytes29 vin = tryAsVin(_vin.ref(uint40(BTCTypes.Unknown)));\\n        require(!vin.isNull(), \\\"BitcoinHelper: vin is null\\\");\\n\\n        bytes32 inputHash1 = sha256(abi.encodePacked(_version, _vin, _vout, _locktime));\\n        bytes32 inputHash2 = sha256(abi.encodePacked(inputHash1));\\n        return inputHash2;\\n    }\\n\\n    /// @notice                      Reverts a Bytes32 input\\n    /// @param _input                Bytes32 input that we want to revert\\n    /// @return                      Reverted bytes32\\n    function reverseBytes32(bytes32 _input) private pure returns (bytes32) {\\n        bytes memory temp;\\n        bytes32 result;\\n        for (uint i = 0; i < 32; i++) {\\n            temp = abi.encodePacked(temp, _input[31-i]);\\n        }\\n        assembly {\\n            result := mload(add(temp, 32))\\n        }\\n        return result;\\n    }\\n\\n    /// @notice                           Parses outpoint info from an input\\n    /// @dev                              Reverts if vin is null\\n    /// @param _vin                       The vin of a Bitcoin transaction\\n    /// @param _index                     Index of the input that we are looking at\\n    /// @return _txId                     Output tx id\\n    /// @return _outputIndex              Output tx index\\n    function extractOutpoint(\\n        bytes memory _vin, \\n        uint _index\\n    ) internal pure returns (bytes32 _txId, uint _outputIndex) {\\n        bytes29 vin = tryAsVin(_vin.ref(uint40(BTCTypes.Unknown)));\\n        require(!vin.isNull(), \\\"BitcoinHelper: vin is null\\\");\\n        bytes29 input = indexVin(vin, _index);\\n        bytes29 _outpoint = outpoint(input);\\n        _txId = txidLE(_outpoint);\\n        _outputIndex = outpointIdx(_outpoint);\\n    }\\n\\n    /// @notice             extracts the index as an integer from the outpoint\\n    /// @param _outpoint    the outpoint\\n    /// @return             the index\\n    function outpointIdx(bytes29 _outpoint) internal pure typeAssert(_outpoint, BTCTypes.Outpoint) returns (uint32) {\\n        return _outpoint.indexLEUint(32, 4).toUint32();\\n    }\\n\\n    /// @notice          extracts the outpoint from an input\\n    /// @param _input    the input\\n    /// @return          the outpoint as a typed memory\\n    function outpoint(bytes29 _input) internal pure typeAssert(_input, BTCTypes.TxIn) returns (bytes29) {\\n        return _input.slice(0, 36, uint40(BTCTypes.Outpoint));\\n    }\\n\\n    /// @notice           extracts the script sig from an input\\n    /// @param _input     the input\\n    /// @return           the script sig as a typed memory\\n    function scriptSig(bytes29 _input) internal pure typeAssert(_input, BTCTypes.TxIn) returns (bytes29) {\\n        uint64 scriptLength = indexCompactInt(_input, 36);\\n        return _input.slice(36, compactIntLength(scriptLength) + scriptLength, uint40(BTCTypes.ScriptSig));\\n    }\\n\\n    /// @notice         determines the length of the first input in an array of inputs\\n    /// @param _inputs  the vin without its length prefix\\n    /// @return         the input length\\n    function inputLength(bytes29 _inputs) private pure typeAssert(_inputs, BTCTypes.IntermediateTxIns) returns (uint256) {\\n        uint64 scriptLength = indexCompactInt(_inputs, 36);\\n        return uint256(compactIntLength(scriptLength)) + uint256(scriptLength) + 36 + 4;\\n    }\\n\\n    /// @notice         extracts the input at a specified index\\n    /// @param _vin     the vin\\n    /// @param _index   the index of the desired input\\n    /// @return         the desired input\\n    function indexVin(bytes29 _vin, uint256 _index) internal pure typeAssert(_vin, BTCTypes.Vin) returns (bytes29) {\\n        uint256 _nIns = uint256(indexCompactInt(_vin, 0));\\n        uint256 _viewLen = _vin.len();\\n        require(_index < _nIns, \\\"Vin read overrun\\\");\\n\\n        uint256 _offset = uint256(compactIntLength(uint64(_nIns)));\\n        bytes29 _remaining;\\n        for (uint256 _i = 0; _i < _index; _i += 1) {\\n            _remaining = _vin.postfix(_viewLen - _offset, uint40(BTCTypes.IntermediateTxIns));\\n            _offset += inputLength(_remaining);\\n        }\\n\\n        _remaining = _vin.postfix(_viewLen - _offset, uint40(BTCTypes.IntermediateTxIns));\\n        uint256 _len = inputLength(_remaining);\\n        return _vin.slice(_offset, _len, uint40(BTCTypes.TxIn));\\n    }\\n\\n    /// @notice         extracts the value from an output\\n    /// @param _output  the output\\n    /// @return         the value\\n    function value(bytes29 _output) internal pure typeAssert(_output, BTCTypes.TxOut) returns (uint64) {\\n        return _output.indexLEUint(0, 8).toUint64();\\n    }\\n\\n    /// @notice                   Finds the value of a specific output\\n    /// @dev                      Reverts if vout is null\\n    /// @param _vout              The vout of a Bitcoin transaction\\n    /// @param _index             Index of output\\n    /// @return _value            Value of the specified output\\n    function parseOutputValue(bytes memory _vout, uint _index) internal pure returns (uint64 _value) {\\n        bytes29 voutView = tryAsVout(_vout.ref(uint40(BTCTypes.Unknown)));\\n        require(!voutView.isNull(), \\\"BitcoinHelper: vout is null\\\");\\n        bytes29 output;\\n        output = indexVout(voutView, _index);\\n        _value = value(output);\\n    }\\n\\n    /// @notice                   Finds total outputs value\\n    /// @dev                      Reverts if vout is null\\n    /// @param _vout              The vout of a Bitcoin transaction\\n    /// @return _totalValue       Total vout value\\n    function parseOutputsTotalValue(bytes memory _vout) internal pure returns (uint64 _totalValue) {\\n        bytes29 voutView = tryAsVout(_vout.ref(uint40(BTCTypes.Unknown)));\\n        require(!voutView.isNull(), \\\"BitcoinHelper: vout is null\\\");\\n        bytes29 output;\\n\\n        // Finds total number of outputs\\n        uint _numberOfOutputs = uint256(indexCompactInt(voutView, 0));\\n\\n        for (uint index = 0; index < _numberOfOutputs; index++) {\\n            output = indexVout(voutView, index);\\n            _totalValue = _totalValue + value(output);\\n        }\\n    }\\n\\n    /// @notice                           Parses the BTC amount that has been sent to \\n    ///                                   a specific script in a specific output\\n    /// @param _vout                      The vout of a Bitcoin transaction\\n    /// @param _voutIndex                 Index of the output that we are looking at\\n    /// @param _script                    Desired recipient script\\n    /// @param _scriptType                Type of the script (e.g. P2PK)\\n    /// @return bitcoinAmount             Amount of BTC have been sent to the _script\\n    function parseValueFromSpecificOutputHavingScript(\\n        bytes memory _vout,\\n        uint _voutIndex,\\n        bytes memory _script,\\n        ScriptTypes _scriptType\\n    ) internal pure returns (uint64 bitcoinAmount) {\\n        \\n        bytes29 voutView = tryAsVout(_vout.ref(uint40(BTCTypes.Unknown)));\\n        require(!voutView.isNull(), \\\"BitcoinHelper: vout is null\\\");\\n        bytes29 output = indexVout(voutView, _voutIndex);\\n        bytes29 _scriptPubkey = scriptPubkey(output);\\n        \\n        if (_scriptType == ScriptTypes.P2TR) {\\n            // note: first two bytes are OP_1 and Pushdata Bytelength. \\n            // note: script hash length is 32.           \\n            bitcoinAmount = keccak256(_script) == keccak256(abi.encodePacked(_scriptPubkey.index(2, 32))) ? value(output) : 0;\\n        } else if (_scriptType == ScriptTypes.P2PK) {\\n            // note: first byte is Pushdata Bytelength. \\n            // note: public key length is 32.           \\n            bitcoinAmount = keccak256(_script) == keccak256(abi.encodePacked(_scriptPubkey.index(1, 32))) ? value(output) : 0;\\n        } else if (_scriptType == ScriptTypes.P2PKH) { \\n            // note: first three bytes are OP_DUP, OP_HASH160, Pushdata Bytelength. \\n            // note: public key hash length is 20.         \\n            bitcoinAmount = keccak256(_script) == keccak256(abi.encodePacked(_scriptPubkey.indexAddress(3))) ? value(output) : 0;\\n        } else if (_scriptType == ScriptTypes.P2SH) {\\n            // note: first two bytes are OP_HASH160, Pushdata Bytelength\\n            // note: script hash length is 20.                      \\n            bitcoinAmount = keccak256(_script) == keccak256(abi.encodePacked(_scriptPubkey.indexAddress(2))) ? value(output) : 0;\\n        } else if (_scriptType == ScriptTypes.P2WPKH) {               \\n            // note: first two bytes are OP_0, Pushdata Bytelength\\n            // note: segwit public key hash length is 20. \\n            bitcoinAmount = keccak256(_script) == keccak256(abi.encodePacked(_scriptPubkey.indexAddress(2))) ? value(output) : 0;\\n        } else if (_scriptType == ScriptTypes.P2WSH) {\\n            // note: first two bytes are OP_0, Pushdata Bytelength \\n            // note: segwit script hash length is 32.           \\n            bitcoinAmount = keccak256(_script) == keccak256(abi.encodePacked(_scriptPubkey.index(2, 32))) ? value(output) : 0;\\n        }\\n        \\n    }\\n\\n    /// @notice                           Parses the BTC amount of a transaction\\n    /// @dev                              Finds the BTC amount that has been sent to the locking script\\n    ///                                   Returns zero if no matching locking scrip is found\\n    /// @param _vout                      The vout of a Bitcoin transaction\\n    /// @param _lockingScript             Desired locking script\\n    /// @return bitcoinAmount             Amount of BTC have been sent to the _lockingScript\\n    function parseValueHavingLockingScript(\\n        bytes memory _vout,\\n        bytes memory _lockingScript\\n    ) internal view returns (uint64 bitcoinAmount) {\\n        // Checks that vout is not null\\n        bytes29 voutView = tryAsVout(_vout.ref(uint40(BTCTypes.Unknown)));\\n        require(!voutView.isNull(), \\\"BitcoinHelper: vout is null\\\");\\n\\n        bytes29 output;\\n        bytes29 _scriptPubkey;\\n        \\n        // Finds total number of outputs\\n        uint _numberOfOutputs = uint256(indexCompactInt(voutView, 0));\\n\\n        for (uint index = 0; index < _numberOfOutputs; index++) {\\n            output = indexVout(voutView, index);\\n            _scriptPubkey = scriptPubkey(output);\\n\\n            if (\\n                keccak256(abi.encodePacked(_scriptPubkey.clone())) == keccak256(abi.encodePacked(_lockingScript))\\n            ) {\\n                bitcoinAmount = value(output);\\n                // Stops searching after finding the desired locking script\\n                break;\\n            }\\n        }\\n    }\\n\\n    /// @notice                           Parses the BTC amount and the op_return of a transaction\\n    /// @dev                              Finds the BTC amount that has been sent to the locking script\\n    ///                                   Assumes that payload size is less than 76 bytes\\n    /// @param _vout                      The vout of a Bitcoin transaction\\n    /// @param _lockingScript             Desired locking script\\n    /// @return bitcoinAmount             Amount of BTC have been sent to the _lockingScript\\n    /// @return arbitraryData             Opreturn  data of the transaction\\n    function parseValueAndDataHavingLockingScriptSmallPayload(\\n        bytes memory _vout,\\n        bytes memory _lockingScript\\n    ) internal view returns (uint64 bitcoinAmount, bytes memory arbitraryData) {\\n        // Checks that vout is not null\\n        bytes29 voutView = tryAsVout(_vout.ref(uint40(BTCTypes.Unknown)));\\n        require(!voutView.isNull(), \\\"BitcoinHelper: vout is null\\\");\\n\\n        bytes29 output;\\n        bytes29 _scriptPubkey;\\n        bytes29 _scriptPubkeyWithLength;\\n        bytes29 _arbitraryData;\\n\\n        // Finds total number of outputs\\n        uint _numberOfOutputs = uint256(indexCompactInt(voutView, 0));\\n\\n        for (uint index = 0; index < _numberOfOutputs; index++) {\\n            output = indexVout(voutView, index);\\n            _scriptPubkey = scriptPubkey(output);\\n            _scriptPubkeyWithLength = scriptPubkeyWithLength(output);\\n            _arbitraryData = opReturnPayloadSmall(_scriptPubkeyWithLength);\\n\\n            // Checks whether the output is an arbitarary data or not\\n            if(_arbitraryData == TypedMemView.NULL) {\\n                // Output is not an arbitrary data\\n                if (\\n                    keccak256(abi.encodePacked(_scriptPubkey.clone())) == keccak256(abi.encodePacked(_lockingScript))\\n                ) {\\n                    bitcoinAmount = value(output);\\n                }\\n            } else {\\n                // Returns the whole bytes array\\n                arbitraryData = _arbitraryData.clone();\\n            }\\n        }\\n    }\\n\\n    /// @notice                           Parses the BTC amount and the op_return of a transaction\\n    /// @dev                              Finds the BTC amount that has been sent to the locking script\\n    ///                                   Assumes that payload size is greater than 75 bytes\\n    /// @param _vout                      The vout of a Bitcoin transaction\\n    /// @param _lockingScript             Desired locking script\\n    /// @return bitcoinAmount             Amount of BTC have been sent to the _lockingScript\\n    /// @return arbitraryData             Opreturn  data of the transaction\\n    function parseValueAndDataHavingLockingScriptBigPayload(\\n        bytes memory _vout,\\n        bytes memory _lockingScript\\n    ) internal view returns (uint64 bitcoinAmount, bytes memory arbitraryData) {\\n        // Checks that vout is not null\\n        bytes29 voutView = tryAsVout(_vout.ref(uint40(BTCTypes.Unknown)));\\n        require(!voutView.isNull(), \\\"BitcoinHelper: vout is null\\\");\\n\\n        bytes29 output;\\n        bytes29 _scriptPubkey;\\n        bytes29 _scriptPubkeyWithLength;\\n        bytes29 _arbitraryData;\\n\\n        // Finds total number of outputs\\n        uint _numberOfOutputs = uint256(indexCompactInt(voutView, 0));\\n\\n        for (uint index = 0; index < _numberOfOutputs; index++) {\\n            output = indexVout(voutView, index);\\n            _scriptPubkey = scriptPubkey(output);\\n            _scriptPubkeyWithLength = scriptPubkeyWithLength(output);\\n            _arbitraryData = opReturnPayloadBig(_scriptPubkeyWithLength);\\n\\n            // Checks whether the output is an arbitarary data or not\\n            if(_arbitraryData == TypedMemView.NULL) {\\n                // Output is not an arbitrary data\\n                if (\\n                    keccak256(abi.encodePacked(_scriptPubkey.clone())) == keccak256(abi.encodePacked(_lockingScript))\\n                ) {\\n                    bitcoinAmount = value(output);\\n                }\\n            } else {\\n                // Returns the whole bytes array\\n                arbitraryData = _arbitraryData.clone();\\n            }\\n        }\\n    }\\n\\n    /// @notice             extracts the scriptPubkey from an output\\n    /// @param _output      the output\\n    /// @return             the scriptPubkey\\n    function scriptPubkey(bytes29 _output) internal pure typeAssert(_output, BTCTypes.TxOut) returns (bytes29) {\\n        uint64 scriptLength = indexCompactInt(_output, 8);\\n        return _output.slice(8 + compactIntLength(scriptLength), scriptLength, uint40(BTCTypes.ScriptPubkey));\\n    }\\n\\n    /// @notice             extracts the scriptPubkey from an output\\n    /// @param _output      the output\\n    /// @return             the scriptPubkey\\n    function scriptPubkeyWithLength(bytes29 _output) internal pure typeAssert(_output, BTCTypes.TxOut) returns (bytes29) {\\n        uint64 scriptLength = indexCompactInt(_output, 8);\\n        return _output.slice(8, compactIntLength(scriptLength) + scriptLength, uint40(BTCTypes.ScriptPubkey));\\n    }\\n\\n    /// @notice                           Parses locking script from an output\\n    /// @dev                              Reverts if vout is null\\n    /// @param _vout                      The vout of a Bitcoin transaction\\n    /// @param _index                     Index of the output that we are looking at\\n    /// @return _lockingScript            Parsed locking script\\n    function getLockingScript(\\n        bytes memory _vout, \\n        uint _index\\n    ) internal view returns (bytes memory _lockingScript) {\\n        bytes29 vout = tryAsVout(_vout.ref(uint40(BTCTypes.Unknown)));\\n        require(!vout.isNull(), \\\"BitcoinHelper: vout is null\\\");\\n        bytes29 output = indexVout(vout, _index);\\n        bytes29 _lockingScriptBytes29 = scriptPubkey(output);\\n        _lockingScript = _lockingScriptBytes29.clone();\\n    }\\n\\n    /// @notice                   Returns number of outputs in a vout\\n    /// @param _vout              The vout of a Bitcoin transaction           \\n    function numberOfOutputs(bytes memory _vout) internal pure returns (uint _numberOfOutputs) {\\n        bytes29 voutView = tryAsVout(_vout.ref(uint40(BTCTypes.Unknown)));\\n        _numberOfOutputs = uint256(indexCompactInt(voutView, 0));\\n    }\\n\\n    /// @notice             determines the length of the first output in an array of outputs\\n    /// @param _outputs     the vout without its length prefix\\n    /// @return             the output length\\n    function outputLength(bytes29 _outputs) private pure typeAssert(_outputs, BTCTypes.IntermediateTxOuts) returns (uint256) {\\n        uint64 scriptLength = indexCompactInt(_outputs, 8);\\n        return uint256(compactIntLength(scriptLength)) + uint256(scriptLength) + 8;\\n    }\\n\\n    /// @notice         extracts the output at a specified index\\n    /// @param _vout    the vout\\n    /// @param _index   the index of the desired output\\n    /// @return         the desired output\\n    function indexVout(bytes29 _vout, uint256 _index) internal pure typeAssert(_vout, BTCTypes.Vout) returns (bytes29) {\\n        uint256 _nOuts = uint256(indexCompactInt(_vout, 0));\\n        uint256 _viewLen = _vout.len();\\n        require(_index < _nOuts, \\\"Vout read overrun\\\");\\n\\n        uint256 _offset = uint256(compactIntLength(uint64(_nOuts)));\\n        bytes29 _remaining;\\n        for (uint256 _i = 0; _i < _index; _i += 1) {\\n            _remaining = _vout.postfix(_viewLen - _offset, uint40(BTCTypes.IntermediateTxOuts));\\n            _offset += outputLength(_remaining);\\n        }\\n\\n        _remaining = _vout.postfix(_viewLen - _offset, uint40(BTCTypes.IntermediateTxOuts));\\n        uint256 _len = outputLength(_remaining);\\n        return _vout.slice(_offset, _len, uint40(BTCTypes.TxOut));\\n    }\\n\\n    /// @notice         extracts the Op Return Payload\\n    /// @dev            structure of the input is: 1 byte op return + 2 bytes indicating the length of payload + max length for op return payload is 80 bytes\\n    /// @param _spk     the scriptPubkey\\n    /// @return         the Op Return Payload (or null if not a valid Op Return output)\\n    function opReturnPayloadBig(bytes29 _spk) internal pure typeAssert(_spk, BTCTypes.ScriptPubkey) returns (bytes29) {\\n        uint64 _bodyLength = indexCompactInt(_spk, 0);\\n        uint64 _payloadLen = _spk.indexUint(3, 1).toUint64();\\n        if (_spk.indexUint(1, 1) != 0x6a || _spk.indexUint(3, 1) != _bodyLength - 3) {\\n            return TypedMemView.nullView();\\n        }\\n        // Extra checks for OP_RETURN\\n        require(_bodyLength <= 83 && _bodyLength >= 4, \\\"BitcoinHelper: invalid opreturn\\\"); \\n        return _spk.slice(4, _payloadLen, uint40(BTCTypes.OpReturnPayload));\\n    }\\n\\n    /// @notice         extracts the Op Return Payload\\n    /// @dev            structure of the input is: 1 byte op return + 1 bytes indicating the length of payload + max length for op return payload is 75 bytes\\n    /// @param _spk     the scriptPubkey\\n    /// @return         the Op Return Payload (or null if not a valid Op Return output)\\n    function opReturnPayloadSmall(bytes29 _spk) internal pure typeAssert(_spk, BTCTypes.ScriptPubkey) returns (bytes29) {\\n        uint64 _bodyLength = indexCompactInt(_spk, 0);\\n        uint64 _payloadLen = _spk.indexUint(2, 1).toUint64();\\n        if (_spk.indexUint(1, 1) != 0x6a || _spk.indexUint(2, 1) != _bodyLength - 2) {\\n            // This means that this output is not OP_RETURN\\n            return TypedMemView.nullView();\\n        }\\n        // Extra checks for OP_RETURN\\n        require(_bodyLength <= 77 && _bodyLength >= 4, \\\"BitcoinHelper: invalid opreturn\\\"); \\n        return _spk.slice(3, _payloadLen, uint40(BTCTypes.OpReturnPayload));\\n    }\\n\\n    /// @notice     verifies the vin and converts to a typed memory\\n    /// @dev        will return null in error cases\\n    /// @param _vin the vin\\n    /// @return     the typed vin (or null if error)\\n    function tryAsVin(bytes29 _vin) internal pure typeAssert(_vin, BTCTypes.Unknown) returns (bytes29) {\\n        if (_vin.len() == 0) {\\n            return TypedMemView.nullView();\\n        }\\n        uint64 _nIns = indexCompactInt(_vin, 0);\\n        uint256 _viewLen = _vin.len();\\n        if (_nIns == 0) {\\n            return TypedMemView.nullView();\\n        }\\n\\n        uint256 _offset = uint256(compactIntLength(_nIns));\\n        for (uint256 i = 0; i < _nIns; i++) {\\n            if (_offset >= _viewLen) {\\n                // We've reached the end, but are still trying to read more\\n                return TypedMemView.nullView();\\n            }\\n            bytes29 _remaining = _vin.postfix(_viewLen - _offset, uint40(BTCTypes.IntermediateTxIns));\\n            _offset += inputLength(_remaining);\\n        }\\n        if (_offset != _viewLen) {\\n            return TypedMemView.nullView();\\n        }\\n        return _vin.castTo(uint40(BTCTypes.Vin));\\n    }\\n\\n    /// @notice         verifies the vout and converts to a typed memory\\n    /// @dev            will return null in error cases\\n    /// @param _vout    the vout\\n    /// @return         the typed vout (or null if error)\\n    function tryAsVout(bytes29 _vout) internal pure typeAssert(_vout, BTCTypes.Unknown) returns (bytes29) {\\n        if (_vout.len() == 0) {\\n            return TypedMemView.nullView();\\n        }\\n        uint64 _nOuts = indexCompactInt(_vout, 0);\\n\\n        uint256 _viewLen = _vout.len();\\n        if (_nOuts == 0) {\\n            return TypedMemView.nullView();\\n        }\\n\\n        uint256 _offset = uint256(compactIntLength(_nOuts));\\n        for (uint256 i = 0; i < _nOuts; i++) {\\n            if (_offset >= _viewLen) {\\n                // We've reached the end, but are still trying to read more\\n                return TypedMemView.nullView();\\n            }\\n            bytes29 _remaining = _vout.postfix(_viewLen - _offset, uint40(BTCTypes.IntermediateTxOuts));\\n            _offset += outputLength(_remaining);\\n        }\\n        if (_offset != _viewLen) {\\n            return TypedMemView.nullView();\\n        }\\n        return _vout.castTo(uint40(BTCTypes.Vout));\\n    }\\n\\n    /// @notice         verifies the header and converts to a typed memory\\n    /// @dev            will return null in error cases\\n    /// @param _header  the header\\n    /// @return         the typed header (or null if error)\\n    function tryAsHeader(bytes29 _header) internal pure typeAssert(_header, BTCTypes.Unknown) returns (bytes29) {\\n        if (_header.len() != 80) {\\n            return TypedMemView.nullView();\\n        }\\n        return _header.castTo(uint40(BTCTypes.Header));\\n    }\\n\\n\\n    /// @notice         Index a header array.\\n    /// @dev            Errors on overruns\\n    /// @param _arr     The header array\\n    /// @param index    The 0-indexed location of the header to get\\n    /// @return         the typed header at `index`\\n    function indexHeaderArray(bytes29 _arr, uint256 index) internal pure typeAssert(_arr, BTCTypes.HeaderArray) returns (bytes29) {\\n        uint256 _start = index * 80;\\n        return _arr.slice(_start, 80, uint40(BTCTypes.Header));\\n    }\\n\\n\\n    /// @notice     verifies the header array and converts to a typed memory\\n    /// @dev        will return null in error cases\\n    /// @param _arr the header array\\n    /// @return     the typed header array (or null if error)\\n    function tryAsHeaderArray(bytes29 _arr) internal pure typeAssert(_arr, BTCTypes.Unknown) returns (bytes29) {\\n        if (_arr.len() % 80 != 0) {\\n            return TypedMemView.nullView();\\n        }\\n        return _arr.castTo(uint40(BTCTypes.HeaderArray));\\n    }\\n\\n    /// @notice     verifies the merkle array and converts to a typed memory\\n    /// @dev        will return null in error cases\\n    /// @param _arr the merkle array\\n    /// @return     the typed merkle array (or null if error)\\n    function tryAsMerkleArray(bytes29 _arr) internal pure typeAssert(_arr, BTCTypes.Unknown) returns (bytes29) {\\n        if (_arr.len() % 32 != 0) {\\n            return TypedMemView.nullView();\\n        }\\n        return _arr.castTo(uint40(BTCTypes.MerkleArray));\\n    }\\n\\n    /// @notice         extracts the merkle root from the header\\n    /// @param _header  the header\\n    /// @return         the merkle root\\n    function merkleRoot(bytes29 _header) internal pure typeAssert(_header, BTCTypes.Header) returns (bytes32) {\\n        return _header.index(36, 32);\\n    }\\n\\n    /// @notice         extracts the target from the header\\n    /// @param _header  the header\\n    /// @return         the target\\n    function target(bytes29  _header) internal pure typeAssert(_header, BTCTypes.Header) returns (uint256) {\\n        uint256 _mantissa = _header.indexLEUint(72, 3);\\n        require(_header.indexUint(75, 1) > 2, \\\"ViewBTC: invalid target difficulty\\\");\\n        uint256 _exponent = _header.indexUint(75, 1) - 3;\\n        return _mantissa * (256 ** _exponent);\\n    }\\n\\n    /// @notice         calculates the difficulty from a target\\n    /// @param _target  the target\\n    /// @return         the difficulty\\n    function toDiff(uint256  _target) private pure returns (uint256) {\\n        return DIFF1_TARGET / (_target);\\n    }\\n\\n    /// @notice         extracts the difficulty from the header\\n    /// @param _header  the header\\n    /// @return         the difficulty\\n    function diff(bytes29  _header) internal pure typeAssert(_header, BTCTypes.Header) returns (uint256) {\\n        return toDiff(target(_header));\\n    }\\n\\n    /// @notice         extracts the timestamp from the header\\n    /// @param _header  the header\\n    /// @return         the timestamp\\n    function time(bytes29  _header) internal pure typeAssert(_header, BTCTypes.Header) returns (uint32) {\\n        return uint32(_header.indexLEUint(68, 4));\\n    }\\n\\n    /// @notice         extracts the parent hash from the header\\n    /// @param _header  the header\\n    /// @return         the parent hash\\n    function parent(bytes29 _header) internal pure typeAssert(_header, BTCTypes.Header) returns (bytes32) {\\n        return _header.index(4, 32);\\n    }\\n\\n    /// @notice                     Checks validity of header chain\\n    /// @dev                        Compares current header parent to previous header's digest\\n    /// @param _header              The raw bytes header\\n    /// @param _prevHeaderDigest    The previous header's digest\\n    /// @return                     true if the connect is valid, false otherwise\\n    function checkParent(bytes29 _header, bytes32 _prevHeaderDigest) internal pure typeAssert(_header, BTCTypes.Header) returns (bool) {\\n        return parent(_header) == _prevHeaderDigest;\\n    }\\n\\n    /// @notice                     Validates a tx inclusion in the block\\n    /// @dev                        `index` is not a reliable indicator of location within a block\\n    /// @param _txid                The txid (LE)\\n    /// @param _merkleRoot          The merkle root\\n    /// @param _intermediateNodes   The proof's intermediate nodes (digests between leaf and root)\\n    /// @param _index               The leaf's index in the tree (0-indexed)\\n    /// @return                     true if fully valid, false otherwise\\n    function prove( \\n        bytes32 _txid,\\n        bytes32 _merkleRoot,\\n        bytes29 _intermediateNodes,\\n        uint _index\\n    ) internal view typeAssert(_intermediateNodes, BTCTypes.MerkleArray) returns (bool) {\\n        // Shortcut the empty-block case\\n        if (\\n            _txid == _merkleRoot &&\\n                _index == 0 &&\\n                    _intermediateNodes.len() == 0\\n        ) {\\n            return true;\\n        }\\n\\n        return checkMerkle(_txid, _intermediateNodes, _merkleRoot, _index);\\n    }\\n\\n    /// @notice         verifies a merkle proof\\n    /// @dev            leaf, proof, and root are in LE format\\n    /// @param _leaf    the leaf\\n    /// @param _proof   the proof nodes\\n    /// @param _root    the merkle root\\n    /// @param _index   the index\\n    /// @return         true if valid, false if otherwise\\n    function checkMerkle(\\n        bytes32 _leaf,\\n        bytes29 _proof,\\n        bytes32 _root,\\n        uint256 _index\\n    ) private view typeAssert(_proof, BTCTypes.MerkleArray) returns (bool) {\\n        require(_root != bytes32(0), \\\"BitcoinHelper: zero root\\\");\\n\\n        uint256 nodes = _proof.len() / 32;\\n        if (nodes == 0) {\\n            return _leaf == _root;\\n        }\\n\\n        uint256 _idx = _index;\\n        bytes32 _current = _leaf;\\n\\n        for (uint i = 0; i < nodes; i++) {\\n            bytes32 _next = _proof.index(i * 32, 32);\\n            if (_idx % 2 == 1) {\\n                _current = merkleStep(_next, _current);\\n            } else {\\n                _current = merkleStep(_current, _next);\\n            }\\n            _idx >>= 1;\\n        }\\n\\n        return _current == _root;\\n    }\\n\\n    /// @notice          Concatenates and hashes two inputs for merkle proving\\n    /// @dev             Not recommended to call directly.\\n    /// @param _a        The first hash\\n    /// @param _b        The second hash\\n    /// @return digest   The double-sha256 of the concatenated hashes\\n    function merkleStep(bytes32 _a, bytes32 _b) private view returns (bytes32 digest) {\\n        assembly {\\n        // solium-disable-previous-line security/no-inline-assembly\\n            let ptr := mload(0x40)\\n            mstore(ptr, _a)\\n            mstore(add(ptr, 0x20), _b)\\n            pop(staticcall(gas(), 2, ptr, 0x40, ptr, 0x20)) // sha256 #1\\n            pop(staticcall(gas(), 2, ptr, 0x20, ptr, 0x20)) // sha256 #2\\n            digest := mload(ptr)\\n        }\\n    }\\n\\n    /// @notice                 performs the bitcoin difficulty retarget\\n    /// @dev                    implements the Bitcoin algorithm precisely\\n    /// @param _previousTarget  the target of the previous period\\n    /// @param _firstTimestamp  the timestamp of the first block in the difficulty period\\n    /// @param _secondTimestamp the timestamp of the last block in the difficulty period\\n    /// @return                 the new period's target threshold\\n    function retargetAlgorithm(\\n        uint256 _previousTarget,\\n        uint256 _firstTimestamp,\\n        uint256 _secondTimestamp\\n    ) internal pure returns (uint256) {\\n        uint256 _elapsedTime = _secondTimestamp - _firstTimestamp;\\n\\n        // Normalize ratio to factor of 4 if very long or very short\\n        if (_elapsedTime < RETARGET_PERIOD / 4) {\\n            _elapsedTime = RETARGET_PERIOD / 4;\\n        }\\n        if (_elapsedTime > RETARGET_PERIOD * 4) {\\n            _elapsedTime = RETARGET_PERIOD * 4;\\n        }\\n\\n        /*\\n            NB: high targets e.g. ffff0020 can cause overflows here\\n                so we divide it by 256**2, then multiply by 256**2 later\\n                we know the target is evenly divisible by 256**2, so this isn't an issue\\n        */\\n        uint256 _adjusted = _previousTarget / 65536 * _elapsedTime;\\n        return _adjusted / RETARGET_PERIOD * 65536;\\n    }\\n}\",\"keccak256\":\"0x1f25b83df29185010e565471c841e0456d7c76e0c02fd0d7fe6fe4e427b37d44\",\"license\":\"MIT\"},\"@teleportdao/btc-evm-bridge/contracts/libraries/TypedMemView.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.8.4;\\n\\n/** @author Summa (https://summa.one) */\\n\\n/*\\n    Original version: https://github.com/summa-tx/memview-sol/blob/main/contracts/TypedMemView.sol\\n    We made few changes to the original version:\\n    1. Use solidity version 8 compiler\\n    2. Remove SafeMath library\\n    3. Add unchecked in line 522\\n*/\\n\\nlibrary TypedMemView {\\n\\n    // Why does this exist?\\n    // the solidity `bytes memory` type has a few weaknesses.\\n    // 1. You can't index ranges effectively\\n    // 2. You can't slice without copying\\n    // 3. The underlying data may represent any type\\n    // 4. Solidity never deallocates memory, and memory costs grow\\n    //    superlinearly\\n\\n    // By using a memory view instead of a `bytes memory` we get the following\\n    // advantages:\\n    // 1. Slices are done on the stack, by manipulating the pointer\\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\\n    // 3. We can insert type info into the pointer, and typecheck at runtime\\n\\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\\n    // algorithms.\\n\\n    // Why bytes29?\\n    // We want to avoid confusion between views, digests, and other common\\n    // types so we chose a large and uncommonly used odd number of bytes\\n    //\\n    // Note that while bytes are left-aligned in a word, integers and addresses\\n    // are right-aligned. This means when working in assembly we have to\\n    // account for the 3 unused bytes on the righthand side\\n    //\\n    // First 5 bytes are a type flag.\\n    // - ff_ffff_fffe is reserved for unknown type.\\n    // - ff_ffff_ffff is reserved for invalid types/errors.\\n    // next 12 are memory address\\n    // next 12 are len\\n    // bottom 3 bytes are empty\\n\\n    // Assumptions:\\n    // - non-modification of memory.\\n    // - No Solidity updates\\n    // - - wrt free mem point\\n    // - - wrt bytes representation in memory\\n    // - - wrt memory addressing in general\\n\\n    // Usage:\\n    // - create type constants\\n    // - use `assertType` for runtime type assertions\\n    // - - unfortunately we can't do this at compile time yet :(\\n    // - recommended: implement modifiers that perform type checking\\n    // - - e.g.\\n    // - - `uint40 constant MY_TYPE = 3;`\\n    // - - ` modifer onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\\n    // - instantiate a typed view from a bytearray using `ref`\\n    // - use `index` to inspect the contents of the view\\n    // - use `slice` to create smaller views into the same memory\\n    // - - `slice` can increase the offset\\n    // - - `slice can decrease the length`\\n    // - - must specify the output type of `slice`\\n    // - - `slice` will return a null view if you try to overrun\\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\\n    // - use `equal` for typed comparisons.\\n\\n\\n    // The null view\\n    bytes29 internal constant NULL = hex\\\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\\";\\n    uint256 constant LOW_12_MASK = 0xffffffffffffffffffffffff;\\n    uint8 constant TWELVE_BYTES = 96;\\n\\n    /**\\n     * @notice      Returns the encoded hex character that represents the lower 4 bits of the argument.\\n     * @param _b    The byte\\n     * @return      char - The encoded hex character\\n     */\\n    function nibbleHex(uint8 _b) internal pure returns (uint8 char) {\\n        // This can probably be done more efficiently, but it's only in error\\n        // paths, so we don't really care :)\\n        uint8 _nibble = _b | 0xf0; // set top 4, keep bottom 4\\n        if (_nibble == 0xf0) {return 0x30;} // 0\\n        if (_nibble == 0xf1) {return 0x31;} // 1\\n        if (_nibble == 0xf2) {return 0x32;} // 2\\n        if (_nibble == 0xf3) {return 0x33;} // 3\\n        if (_nibble == 0xf4) {return 0x34;} // 4\\n        if (_nibble == 0xf5) {return 0x35;} // 5\\n        if (_nibble == 0xf6) {return 0x36;} // 6\\n        if (_nibble == 0xf7) {return 0x37;} // 7\\n        if (_nibble == 0xf8) {return 0x38;} // 8\\n        if (_nibble == 0xf9) {return 0x39;} // 9\\n        if (_nibble == 0xfa) {return 0x61;} // a\\n        if (_nibble == 0xfb) {return 0x62;} // b\\n        if (_nibble == 0xfc) {return 0x63;} // c\\n        if (_nibble == 0xfd) {return 0x64;} // d\\n        if (_nibble == 0xfe) {return 0x65;} // e\\n        if (_nibble == 0xff) {return 0x66;} // f\\n    }\\n\\n    /**\\n     * @notice      Returns a uint16 containing the hex-encoded byte.\\n     *              `the first 8 bits of encoded is the nibbleHex of top 4 bits of _b`\\n     *              `the second 8 bits of encoded is the nibbleHex of lower 4 bits of _b`\\n     * @param _b    The byte\\n     * @return      encoded - The hex-encoded byte\\n     */\\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\\n        encoded |= nibbleHex(_b >> 4); // top 4 bits\\n        encoded <<= 8;\\n        encoded |= nibbleHex(_b); // lower 4 bits\\n    }\\n\\n    /**\\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\\n     *              `second` contains the encoded lower 16 bytes.\\n     *\\n     * @param _b    The 32 bytes as uint256\\n     * @return      first - The top 16 bytes\\n     * @return      second - The bottom 16 bytes\\n     */\\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\\n        for (uint8 i = 31; i > 15; i -= 1) {\\n            uint8 _byte = uint8(_b >> (i * 8));\\n            first |= byteHex(_byte);\\n            if (i != 16) {\\n                first <<= 16;\\n            }\\n        }\\n\\n        unchecked {\\n            // abusing underflow here =_=\\n            for (uint8 i = 15; i < 255 ; i -= 1) {\\n                uint8 _byte = uint8(_b >> (i * 8));\\n                second |= byteHex(_byte);\\n                if (i != 0) {\\n                    second <<= 16;\\n                }\\n            }\\n        }\\n        \\n    }\\n\\n    /**\\n     * @notice          Changes the endianness of a uint256.\\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\\n     * @param _b        The unsigned integer to reverse\\n     * @return          v - The reversed value\\n     */\\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\\n        v = _b;\\n\\n        // swap bytes\\n        v = ((v >> 8) & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\\n        ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\\n        // swap 2-byte long pairs\\n        v = ((v >> 16) & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\\n        ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\\n        // swap 4-byte long pairs\\n        v = ((v >> 32) & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\\n        ((v & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) << 32);\\n        // swap 8-byte long pairs\\n        v = ((v >> 64) & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\\n        ((v & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) << 64);\\n        // swap 16-byte long pairs\\n        v = (v >> 128) | (v << 128);\\n    }\\n\\n    /**\\n     * @notice      Create a mask with the highest `_len` bits set.\\n     * @param _len  The length\\n     * @return      mask - The mask\\n     */\\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\\n        assembly {\\n        // solium-disable-previous-line security/no-inline-assembly\\n            mask := sar(\\n            sub(_len, 1),\\n            0x8000000000000000000000000000000000000000000000000000000000000000\\n            )\\n        }\\n    }\\n\\n    /**\\n     * @notice      Return the null view.\\n     * @return      bytes29 - The null view\\n     */\\n    function nullView() internal pure returns (bytes29) {\\n        return NULL;\\n    }\\n\\n    /**\\n     * @notice      Check if the view is null.\\n     * @return      bool - True if the view is null\\n     */\\n    function isNull(bytes29 memView) internal pure returns (bool) {\\n        return memView == NULL;\\n    }\\n\\n    /**\\n     * @notice      Check if the view is not null.\\n     * @return      bool - True if the view is not null\\n     */\\n    function notNull(bytes29 memView) internal pure returns (bool) {\\n        return !isNull(memView);\\n    }\\n\\n    /**\\n     * @notice          Check if the view is of a valid type and points to a valid location\\n     *                  in memory.\\n     * @dev             We perform this check by examining solidity's unallocated memory\\n     *                  pointer and ensuring that the view's upper bound is less than that.\\n     * @param memView   The view\\n     * @return          ret - True if the view is valid\\n     */\\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\\n        if (typeOf(memView) == 0xffffffffff) {return false;}\\n        uint256 _end = end(memView);\\n        assembly {\\n        // solium-disable-previous-line security/no-inline-assembly\\n            ret := not(gt(_end, mload(0x40)))\\n        }\\n    }\\n\\n    /**\\n     * @notice          Require that a typed memory view be valid.\\n     * @dev             Returns the view for easy chaining.\\n     * @param memView   The view\\n     * @return          bytes29 - The validated view\\n     */\\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\\n        require(isValid(memView), \\\"Validity assertion failed\\\");\\n        return memView;\\n    }\\n\\n    /**\\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\\n     * @param memView   The view\\n     * @param _expected The expected type\\n     * @return          bool - True if the memview is of the expected type\\n     */\\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\\n        return typeOf(memView) == _expected;\\n    }\\n\\n    /**\\n     * @notice          Require that a typed memory view has a specific type.\\n     * @dev             Returns the view for easy chaining.\\n     * @param memView   The view\\n     * @param _expected The expected type\\n     * @return          bytes29 - The view with validated type\\n     */\\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\\n        if (!isType(memView, _expected)) {\\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\\n            (, uint256 e) = encodeHex(uint256(_expected));\\n            string memory err = string(\\n                abi.encodePacked(\\n                    \\\"Type assertion failed. Got 0x\\\",\\n                    uint80(g),\\n                    \\\". Expected 0x\\\",\\n                    uint80(e)\\n                )\\n            );\\n            revert(err);\\n        }\\n        return memView;\\n    }\\n\\n    /**\\n     * @notice          Return an identical view with a different type.\\n     * @param memView   The view\\n     * @param _newType  The new type\\n     * @return          newView - The new view with the specified type\\n     */\\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\\n        // then | in the new type\\n        assembly {\\n        // solium-disable-previous-line security/no-inline-assembly\\n        // shift off the top 5 bytes\\n            newView := or(newView, shr(40, shl(40, memView)))\\n            newView := or(newView, shl(216, _newType))\\n        }\\n    }\\n\\n    /**\\n     * @notice          Unsafe raw pointer construction. This should generally not be called\\n     *                  directly. Prefer `ref` wherever possible.\\n     * @dev             Unsafe raw pointer construction. This should generally not be called\\n     *                  directly. Prefer `ref` wherever possible.\\n     * @param _type     The type\\n     * @param _loc      The memory address\\n     * @param _len      The length\\n     * @return          newView - The new view with the specified type, location and length\\n     */\\n    function unsafeBuildUnchecked(uint256 _type, uint256 _loc, uint256 _len) private pure returns (bytes29 newView) {\\n        assembly {\\n        // solium-disable-previous-line security/no-inline-assembly\\n            newView := shl(96, or(newView, _type)) // insert type\\n            newView := shl(96, or(newView, _loc))  // insert loc\\n            newView := shl(24, or(newView, _len))  // empty bottom 3 bytes\\n        }\\n    }\\n\\n    /**\\n     * @notice          Instantiate a new memory view. This should generally not be called\\n     *                  directly. Prefer `ref` wherever possible.\\n     * @dev             Instantiate a new memory view. This should generally not be called\\n     *                  directly. Prefer `ref` wherever possible.\\n     * @param _type     The type\\n     * @param _loc      The memory address\\n     * @param _len      The length\\n     * @return          newView - The new view with the specified type, location and length\\n     */\\n    function build(uint256 _type, uint256 _loc, uint256 _len) internal pure returns (bytes29 newView) {\\n        uint256 _end = _loc + _len;\\n        assembly {\\n        // solium-disable-previous-line security/no-inline-assembly\\n            if gt(_end, mload(0x40)) {\\n                _end := 0\\n            }\\n        }\\n        if (_end == 0) {\\n            return NULL;\\n        }\\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\\n    }\\n\\n    /**\\n     * @notice          Instantiate a memory view from a byte array.\\n     * @dev             Note that due to Solidity memory representation, it is not possible to\\n     *                  implement a deref, as the `bytes` type stores its len in memory.\\n     * @param arr       The byte array\\n     * @param newType   The type\\n     * @return          bytes29 - The memory view\\n     */\\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\\n        uint256 _len = arr.length;\\n\\n        uint256 _loc;\\n        assembly {\\n        // solium-disable-previous-line security/no-inline-assembly\\n            _loc := add(arr, 0x20)  // our view is of the data, not the struct\\n        }\\n\\n        return build(newType, _loc, _len);\\n    }\\n\\n    /**\\n     * @notice          Return the associated type information.\\n     * @param memView   The memory view\\n     * @return          _type - The type associated with the view\\n     */\\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\\n        assembly {\\n        // solium-disable-previous-line security/no-inline-assembly\\n        // 216 == 256 - 40\\n            _type := shr(216, memView) // shift out lower (12 + 12 + 3) bytes\\n        }\\n    }\\n\\n    /**\\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\\n     * @param left      The first view\\n     * @param right     The second view\\n     * @return          bool - True if the 5-byte type flag is equal\\n     */\\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\\n        // XOR the inputs to check their difference\\n        return (left ^ right) >> (2 * TWELVE_BYTES) == 0;\\n    }\\n\\n    /**\\n     * @notice          Return the memory address of the underlying bytes.\\n     * @param memView   The view\\n     * @return          _loc - The memory address\\n     */\\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\\n        uint256 _mask = LOW_12_MASK;  // assembly can't use globals\\n        assembly {\\n        // solium-disable-previous-line security/no-inline-assembly\\n        // 120 bits = 12 bytes (the encoded loc) + 3 bytes (empty low space)\\n            _loc := and(shr(120, memView), _mask)\\n        }\\n    }\\n\\n    /**\\n     * @notice          The number of memory words this memory view occupies, rounded up.\\n     * @param memView   The view\\n     * @return          uint256 - The number of memory words\\n     */\\n    function words(bytes29 memView) internal pure returns (uint256) {\\n        return (uint256(len(memView)) + 32) / 32;\\n    }\\n\\n    /**\\n     * @notice          The in-memory footprint of a fresh copy of the view.\\n     * @param memView   The view\\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\\n     */\\n    function footprint(bytes29 memView) internal pure returns (uint256) {\\n        return words(memView) * 32;\\n    }\\n\\n    /**\\n     * @notice          The number of bytes of the view.\\n     * @param memView   The view\\n     * @return          _len - The length of the view\\n     */\\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\\n        uint256 _mask = LOW_12_MASK;  // assembly can't use globals\\n        assembly {\\n        // solium-disable-previous-line security/no-inline-assembly\\n            _len := and(shr(24, memView), _mask)\\n        }\\n    }\\n\\n    /**\\n     * @notice          Returns the endpoint of `memView`.\\n     * @param memView   The view\\n     * @return          uint256 - The endpoint of `memView`\\n     */\\n    function end(bytes29 memView) internal pure returns (uint256) {\\n        return loc(memView) + len(memView);\\n    }\\n\\n    /**\\n     * @notice          Safe slicing without memory modification.\\n     * @param memView   The view\\n     * @param _index    The start index\\n     * @param _len      The length\\n     * @param newType   The new type\\n     * @return          bytes29 - The new view\\n     */\\n    function slice(bytes29 memView, uint256 _index, uint256 _len, uint40 newType) internal pure returns (bytes29) {\\n        uint256 _loc = loc(memView);\\n\\n        // Ensure it doesn't overrun the view\\n        if (_loc + _index + _len > end(memView)) {\\n            return NULL;\\n        }\\n\\n        _loc = _loc + _index;\\n        return build(newType, _loc, _len);\\n    }\\n\\n    /**\\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\\n     * @param memView   The view\\n     * @param _len      The length\\n     * @param newType   The new type\\n     * @return          bytes29 - The new view\\n     */\\n    function prefix(bytes29 memView, uint256 _len, uint40 newType) internal pure returns (bytes29) {\\n        return slice(memView, 0, _len, newType);\\n    }\\n\\n    /**\\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` bytes.\\n     * @param memView   The view\\n     * @param _len      The length\\n     * @param newType   The new type\\n     * @return          bytes29 - The new view\\n     */\\n    function postfix(bytes29 memView, uint256 _len, uint40 newType) internal pure returns (bytes29) {\\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\\n    }\\n\\n    /**\\n     * @notice          Construct an error message for an indexing overrun.\\n     * @param _loc      The memory address\\n     * @param _len      The length\\n     * @param _index    The index\\n     * @param _slice    The slice where the overrun occurred\\n     * @return          err - The err\\n     */\\n    function indexErrOverrun(\\n        uint256 _loc,\\n        uint256 _len,\\n        uint256 _index,\\n        uint256 _slice\\n    ) internal pure returns (string memory err) {\\n        (, uint256 a) = encodeHex(_loc);\\n        (, uint256 b) = encodeHex(_len);\\n        (, uint256 c) = encodeHex(_index);\\n        (, uint256 d) = encodeHex(_slice);\\n        err = string(\\n            abi.encodePacked(\\n                \\\"TypedMemView/index - Overran the view. Slice is at 0x\\\",\\n                uint48(a),\\n                \\\" with length 0x\\\",\\n                uint48(b),\\n                \\\". Attempted to index at offset 0x\\\",\\n                uint48(c),\\n                \\\" with length 0x\\\",\\n                uint48(d),\\n                \\\".\\\"\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @notice          Load up to 32 bytes from the view onto the stack.\\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\\n     *                  This can be immediately cast to a smaller fixed-length byte array.\\n     *                  To automatically cast to an integer, use `indexUint`.\\n     * @param memView   The view\\n     * @param _index    The index\\n     * @param _bytes    The bytes length\\n     * @return          result - The 32 byte result\\n     */\\n    function index(bytes29 memView, uint256 _index, uint8 _bytes) internal pure returns (bytes32 result) {\\n        if (_bytes == 0) {return bytes32(0);}\\n        if (_index + _bytes > len(memView)) {\\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\\n        }\\n        require(_bytes <= 32, \\\"TypedMemView/index - Attempted to index more than 32 bytes\\\");\\n\\n        unchecked {\\n            uint8 bitLength = _bytes * 8;\\n            uint256 _loc = loc(memView);\\n            uint256 _mask = leftMask(bitLength);\\n            assembly {\\n                // solium-disable-previous-line security/no-inline-assembly\\n                result := and(mload(add(_loc, _index)), _mask)\\n            }   \\n        }\\n\\n    }\\n\\n    /**\\n     * @notice          Parse an unsigned integer from the view at `_index`.\\n     * @dev             Requires that the view has >= `_bytes` bytes following that index.\\n     * @param memView   The view\\n     * @param _index    The index\\n     * @param _bytes    The bytes length\\n     * @return          result - The unsigned integer\\n     */\\n    function indexUint(bytes29 memView, uint256 _index, uint8 _bytes) internal pure returns (uint256 result) {\\n        return uint256(index(memView, _index, _bytes)) >> ((32 - _bytes) * 8);\\n    }\\n\\n    /**\\n     * @notice          Parse an unsigned integer from LE bytes.\\n     * @param memView   The view\\n     * @param _index    The index\\n     * @param _bytes    The bytes length\\n     * @return          result - The unsigned integer\\n     */\\n    function indexLEUint(bytes29 memView, uint256 _index, uint8 _bytes) internal pure returns (uint256 result) {\\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\\n    }\\n\\n    /**\\n     * @notice          Parse an address from the view at `_index`. Requires that the view have >= 20 bytes\\n     *                  following that index.\\n     * @param memView   The view\\n     * @param _index    The index\\n     * @return          address - The address\\n     */\\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\\n        return address(uint160(indexUint(memView, _index, 20)));\\n    }\\n\\n    /**\\n     * @notice          Return the keccak256 hash of the underlying memory\\n     * @param memView   The view\\n     * @return          digest - The keccak256 hash of the underlying memory\\n     */\\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\\n        uint256 _loc = loc(memView);\\n        uint256 _len = len(memView);\\n        assembly {\\n        // solium-disable-previous-line security/no-inline-assembly\\n            digest := keccak256(_loc, _len)\\n        }\\n    }\\n\\n    /**\\n     * @notice          Return the sha2 digest of the underlying memory.\\n     * @dev             We explicitly deallocate memory afterwards.\\n     * @param memView   The view\\n     * @return          digest - The sha2 hash of the underlying memory\\n     */\\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\\n        uint256 _loc = loc(memView);\\n        uint256 _len = len(memView);\\n        assembly {\\n        // solium-disable-previous-line security/no-inline-assembly\\n            let ptr := mload(0x40)\\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\\n            digest := mload(ptr)\\n        }\\n    }\\n\\n    /**\\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\\n     * @param memView   The pre-image\\n     * @return          digest - the Digest\\n     */\\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\\n        uint256 _loc = loc(memView);\\n        uint256 _len = len(memView);\\n        assembly {\\n        // solium-disable-previous-line security/no-inline-assembly\\n            let ptr := mload(0x40)\\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2\\n            pop(staticcall(gas(), 3, ptr, 0x20, ptr, 0x20)) // rmd160\\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\\n        }\\n    }\\n\\n    /**\\n     * @notice          Implements bitcoin's hash256 (double sha2)\\n     * @param memView   A view of the preimage\\n     * @return          digest - the Digest\\n     */\\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\\n        uint256 _loc = loc(memView);\\n        uint256 _len = len(memView);\\n        assembly {\\n        // solium-disable-previous-line security/no-inline-assembly\\n            let ptr := mload(0x40)\\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\\n            pop(staticcall(gas(), 2, ptr, 0x20, ptr, 0x20)) // sha2 #2\\n            digest := mload(ptr)\\n        }\\n    }\\n\\n    /**\\n     * @notice          Return true if the underlying memory is equal. Else false.\\n     * @param left      The first view\\n     * @param right     The second view\\n     * @return          bool - True if the underlying memory is equal\\n     */\\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\\n        return (loc(left) == loc(right) && len(left) == len(right)) || keccak(left) == keccak(right);\\n    }\\n\\n    /**\\n     * @notice          Return false if the underlying memory is equal. Else true.\\n     * @param left      The first view\\n     * @param right     The second view\\n     * @return          bool - False if the underlying memory is equal\\n     */\\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\\n        return !untypedEqual(left, right);\\n    }\\n\\n    /**\\n     * @notice          Compares type equality.\\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\\n     * @param left      The first view\\n     * @param right     The second view\\n     * @return          bool - True if the types are the same\\n     */\\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\\n        return left == right || (typeOf(left) == typeOf(right) && keccak(left) == keccak(right));\\n    }\\n\\n    /**\\n     * @notice          Compares type inequality.\\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\\n     * @param left      The first view\\n     * @param right     The second view\\n     * @return          bool - True if the types are not the same\\n     */\\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\\n        return !equal(left, right);\\n    }\\n\\n    /**\\n     * @notice          Copy the view to a location, return an unsafe memory reference\\n     * @dev             Super Dangerous direct memory access.\\n     *\\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\\n     *                  As such it MUST be consumed IMMEDIATELY.\\n     *                  This function is private to prevent unsafe usage by callers.\\n     * @param memView   The view\\n     * @param _newLoc   The new location\\n     * @return          written - the unsafe memory reference\\n     */\\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\\n        require(notNull(memView), \\\"TypedMemView/copyTo - Null pointer deref\\\");\\n        require(isValid(memView), \\\"TypedMemView/copyTo - Invalid pointer deref\\\");\\n        uint256 _len = len(memView);\\n        uint256 _oldLoc = loc(memView);\\n\\n        uint256 ptr;\\n        assembly {\\n        // solium-disable-previous-line security/no-inline-assembly\\n            ptr := mload(0x40)\\n        // revert if we're writing in occupied memory\\n            if gt(ptr, _newLoc) {\\n                revert(0x60, 0x20) // empty revert message\\n            }\\n\\n        // use the identity precompile to copy\\n        // guaranteed not to fail, so pop the success\\n            pop(staticcall(gas(), 4, _oldLoc, _len, _newLoc, _len))\\n        }\\n\\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\\n    }\\n\\n    /**\\n     * @notice          Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to\\n     *                  the new memory\\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\\n     * @param memView   The view\\n     * @return          ret - The view pointing to the new memory\\n     */\\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\\n        uint256 ptr;\\n        uint256 _len = len(memView);\\n        assembly {\\n        // solium-disable-previous-line security/no-inline-assembly\\n            ptr := mload(0x40) // load unused memory pointer\\n            ret := ptr\\n        }\\n        unsafeCopyTo(memView, ptr + 0x20);\\n        assembly {\\n        // solium-disable-previous-line security/no-inline-assembly\\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\\n            mstore(ptr, _len) // write len of new array (in bytes)\\n        }\\n    }\\n\\n    /**\\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\\n     * @dev             Super Dangerous direct memory access.\\n     *\\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\\n     *                  As such it MUST be consumed IMMEDIATELY.\\n     *                  This function is private to prevent unsafe usage by callers.\\n     * @param memViews  The views\\n     * @return          unsafeView - The conjoined view pointing to the new memory\\n     */\\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location) private view returns (bytes29 unsafeView) {\\n        assembly {\\n        // solium-disable-previous-line security/no-inline-assembly\\n            let ptr := mload(0x40)\\n        // revert if we're writing in occupied memory\\n            if gt(ptr, _location) {\\n                revert(0x60, 0x20) // empty revert message\\n            }\\n        }\\n\\n        uint256 _offset = 0;\\n        for (uint256 i = 0; i < memViews.length; i ++) {\\n            bytes29 memView = memViews[i];\\n            unsafeCopyTo(memView, _location + _offset);\\n            _offset += len(memView);\\n        }\\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\\n    }\\n\\n    /**\\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\\n     * @param memViews  The views\\n     * @return          bytes32 - The keccak256 digest\\n     */\\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\\n        uint256 ptr;\\n        assembly {\\n        // solium-disable-previous-line security/no-inline-assembly\\n            ptr := mload(0x40) // load unused memory pointer\\n        }\\n        return keccak(unsafeJoin(memViews, ptr));\\n    }\\n\\n    /**\\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\\n     * @param memViews  The views\\n     * @return          bytes32 - The sha256 digest\\n     */\\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\\n        uint256 ptr;\\n        assembly {\\n        // solium-disable-previous-line security/no-inline-assembly\\n            ptr := mload(0x40) // load unused memory pointer\\n        }\\n        return sha2(unsafeJoin(memViews, ptr));\\n    }\\n\\n    /**\\n     * @notice          copies all views, joins them into a new bytearray.\\n     * @param memViews  The views\\n     * @return          ret - The new byte array\\n     */\\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\\n        uint256 ptr;\\n        assembly {\\n        // solium-disable-previous-line security/no-inline-assembly\\n            ptr := mload(0x40) // load unused memory pointer\\n        }\\n\\n        bytes29 _newView = unsafeJoin(memViews, ptr + 0x20);\\n        uint256 _written = len(_newView);\\n        uint256 _footprint = footprint(_newView);\\n\\n        assembly {\\n        // solium-disable-previous-line security/no-inline-assembly\\n        // store the legnth\\n            mstore(ptr, _written)\\n        // new pointer is old + 0x20 + the footprint of the body\\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\\n            ret := ptr\\n        }\\n    }\\n}\",\"keccak256\":\"0x51c24c7c86620e39b732ba1b0de62c314842541748905323df7600a2797a2bd4\",\"license\":\"MIT\"},\"@teleportdao/btc-evm-bridge/contracts/relay/interfaces/IBitcoinRelay.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.8.4;\\n\\ninterface IBitcoinRelay {\\n    // Structures\\n\\n    /// @notice Structure for recording block header\\n    /// @param selfHash Hash of block header\\n    /// @param parentHash Hash of parent header\\n    /// @param merkleRoot Merkle root of transactions in the header\\n    /// @param relayer Address of Relayer who submitted the block header\\n    /// @param gasPrice Gas price of block header submission transaction\\n    struct blockHeader {\\n        bytes32 selfHash;\\n        bytes32 parentHash;\\n        bytes32 merkleRoot;\\n        address relayer;\\n        uint gasPrice;\\n    }\\n\\n    // Events\\n\\n    /// @notice Emits when a block header is added\\n    /// @param height of submitted header\\n    /// @param selfHash Hash of submitted header\\n    /// @param parentHash of submitted header\\n    /// @param relayer Address of Relayer who submitted the block header\\n    event BlockAdded(\\n        uint indexed height,\\n        bytes32 selfHash,\\n        bytes32 indexed parentHash,\\n        address indexed relayer\\n    );\\n\\n    /// @notice Emits when a block header gets finalized\\n    /// @param height of the header\\n    /// @param selfHash Hash of the header\\n    /// @param parentHash of the header\\n    /// @param relayer Address of Relayer who submitted the block header\\n    /// @param rewardAmountTNT Amount of reward that the Relayer receives in target blockchain native token\\n    /// @param rewardAmountTDT Amount of reward that the Relayer receives in TeleportDAO token\\n    event BlockFinalized(\\n        uint indexed height,\\n        bytes32 selfHash,\\n        bytes32 parentHash,\\n        address indexed relayer,\\n        uint rewardAmountTNT,\\n        uint rewardAmountTDT\\n    );\\n\\n    /// @notice Emits when inclusion of a tx is queried\\n    /// @param txId of queried transaction\\n    /// @param blockHeight of the block that includes the tx\\n    /// @param paidFee Amount of fee that user paid to Relay\\n    event NewQuery(\\n        bytes32 txId,\\n        uint blockHeight,\\n        uint paidFee\\n    );\\n         \\n    event NewRewardAmountInTDT (\\n        uint oldRewardAmountInTDT, \\n        uint newRewardAmountInTDT\\n    );\\n\\n    event NewFinalizationParameter (\\n        uint oldFinalizationParameter, \\n        uint newFinalizationParameter\\n    );\\n\\n    event NewRelayerPercentageFee (\\n        uint oldRelayerPercentageFee, \\n        uint newRelayerPercentageFee\\n    );\\n\\n    event NewTeleportDAOToken(\\n        address oldTeleportDAOToken, \\n        address newTeleportDAOToken\\n    );\\n\\n    event NewEpochLength(\\n        uint oldEpochLength, \\n        uint newEpochLength\\n    );\\n\\n    event NewBaseQueries(\\n        uint oldBaseQueries, \\n        uint newBaseQueries\\n    );\\n\\n    event NewSubmissionGasUsed(\\n        uint oldSubmissionGasUsed, \\n        uint newSubmissionGasUsed\\n    );\\n\\n    // Read-only functions\\n\\n    function relayGenesisHash() external view returns (bytes32);\\n\\n    function initialHeight() external view returns(uint);\\n\\n    function lastSubmittedHeight() external view returns(uint);\\n\\n    function finalizationParameter() external view returns(uint);\\n\\n    function TeleportDAOToken() external view returns(address);\\n\\n    function relayerPercentageFee() external view returns(uint);\\n\\n    function epochLength() external view returns(uint);\\n\\n    function lastEpochQueries() external view returns(uint);\\n\\n    function currentEpochQueries() external view returns(uint);\\n\\n    function baseQueries() external view returns(uint);\\n\\n    function submissionGasUsed() external view returns(uint);\\n\\n    function getBlockHeaderHash(uint height, uint index) external view returns(bytes32);\\n\\n    function getBlockHeaderFee(uint _height, uint _index) external view returns(uint);\\n\\n    function getNumberOfSubmittedHeaders(uint height) external view returns (uint);\\n\\n    function availableTDT() external view returns(uint);\\n\\n    function availableTNT() external view returns(uint);\\n\\n    function findHeight(bytes32 _hash) external view returns (uint256);\\n\\n    function rewardAmountInTDT() external view returns (uint);\\n\\n    // State-changing functions\\n\\n    function pauseRelay() external;\\n\\n    function unpauseRelay() external;\\n\\n    function setRewardAmountInTDT(uint _rewardAmountInTDT) external;\\n\\n    function setFinalizationParameter(uint _finalizationParameter) external;\\n\\n    function setRelayerPercentageFee(uint _relayerPercentageFee) external;\\n\\n    function setTeleportDAOToken(address _TeleportDAOToken) external;\\n\\n    function setEpochLength(uint _epochLength) external;\\n\\n    function setBaseQueries(uint _baseQueries) external;\\n\\n    function setSubmissionGasUsed(uint _submissionGasUsed) external;\\n\\n    function checkTxProof(\\n        bytes32 txid,\\n        uint blockHeight,\\n        bytes calldata intermediateNodes,\\n        uint index\\n    ) external payable returns (bool);\\n\\n    function getBlockHeaderHashContract(uint _height, uint _index) external payable returns (bytes32);\\n\\n    function addHeaders(bytes calldata _anchor, bytes calldata _headers) external returns (bool);\\n\\n    function addHeadersWithRetarget(\\n        bytes calldata _oldPeriodStartHeader,\\n        bytes calldata _oldPeriodEndHeader,\\n        bytes calldata _headers\\n    ) external returns (bool);\\n\\n    function ownerAddHeaders(bytes calldata _anchor, bytes calldata _headers) external returns (bool);\\n\\n    function ownerAddHeadersWithRetarget(\\n        bytes calldata _oldPeriodStartHeader,\\n        bytes calldata _oldPeriodEndHeader,\\n        bytes calldata _headers\\n    ) external returns (bool);\\n}\",\"keccak256\":\"0x8f4b9c9ad505ba1184d4e2c6694d725eacaf19c42942075bae2b1608bdbd9ef5\",\"license\":\"MIT\"},\"@teleportdao/btc-evm-bridge/contracts/types/ScriptTypesEnum.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.8.4;\\n\\n    enum ScriptTypes {\\n        P2PK, // 32 bytes\\n        P2PKH, // 20 bytes        \\n        P2SH, // 20 bytes          \\n        P2WPKH, // 20 bytes          \\n        P2WSH, // 32 bytes\\n        P2TR // 32 bytes               \\n    }\",\"keccak256\":\"0x65d6ce283fb19a20a37abd09247371c2362932c49a6b40dafab022c2f1153710\",\"license\":\"MIT\"},\"contracts/connectors/interfaces/IExchangeConnector.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.8.4;\\n\\ninterface IExchangeConnector {\\n\\n    // Events\\n    \\n    event Swap(address[] path, uint[] amounts, address receiver);\\n\\n    // Read-only functions\\n\\n    function name() external view returns (string memory);\\n\\n    function exchangeRouter() external view returns (address);\\n\\n    function liquidityPoolFactory() external view returns (address);\\n\\n    function wrappedNativeToken() external view returns (address);\\n\\n    function getInputAmount(\\n        uint _outputAmount,\\n        address _inputToken,\\n        address _outputToken\\n    ) external view returns (bool, uint);\\n\\n    function getOutputAmount(\\n        uint _inputAmount,\\n        address _inputToken,\\n        address _outputToken\\n    ) external view returns (bool, uint);\\n\\n    // State-changing functions\\n\\n    function setExchangeRouter(address _exchangeRouter) external;\\n\\n    function setLiquidityPoolFactory() external;\\n\\n    function setWrappedNativeToken() external;\\n\\n    function swap(\\n        uint256 _inputAmount,\\n        uint256 _outputAmount,\\n        address[] memory _path,\\n        address _to,\\n        uint256 _deadline,\\n        bool _isFixedToken\\n    ) external returns (bool, uint[] memory);\\n\\n    function isPathValid(address[] memory _path) external view returns(bool);\\n}\",\"keccak256\":\"0x12cc3b3424654cc48e9f0563ed027b953414fa142305c32dfc4e7d58bd39c2fa\",\"license\":\"MIT\"},\"contracts/erc20/interfaces/ITeleBTC.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.8.4;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\n\\ninterface ITeleBTC is IERC20Upgradeable {\\n\\n    // Events\\n    event Mint(address indexed doer, address indexed receiver, uint value);\\n\\n    event Burn(address indexed doer, address indexed burner, uint value);\\n\\n    event MinterAdded(address indexed newMinter);\\n\\n    event MinterRemoved(address indexed minter);\\n\\n    event BurnerAdded(address indexed newBurner);\\n\\n    event BurnerRemoved(address indexed burner);\\n\\n    event NewMintLimit(uint oldMintLimit, uint newMintLimit);\\n\\n    event NewEpochLength(uint oldEpochLength, uint newEpochLength);\\n\\n    event Blacklisted(address indexed account);\\n\\n    event UnBlacklisted(address indexed account);\\n\\n    event BlackListerAdded(address indexed newBlackLister);\\n\\n    event BlackListerRemoved(address indexed blackLister);\\n\\n    // read functions\\n\\n    function decimals() external view returns (uint8);\\n\\n    // state-changing functions\\n\\n    function addMinter(address account) external;\\n\\n    function removeMinter(address account) external;\\n\\n    function addBurner(address account) external;\\n\\n    function removeBurner(address account) external;\\n\\n    function mint(address receiver, uint amount) external returns(bool);\\n\\n    function burn(uint256 amount) external returns(bool);\\n\\n    function ownerBurn(address _user, uint _amount) external returns (bool);\\n\\n    function setMaxMintLimit(uint _mintLimit) external;\\n\\n    function setEpochLength(uint _length) external;\\n\\n    function addBlackLister(address account) external;\\n\\n    function removeBlackLister(address account) external;\\n\\n    function blacklist(address _account) external;\\n\\n    function unBlacklist(address _account) external;\\n}\",\"keccak256\":\"0x4189ccf1aee711d37f78f0e09b1a6eb80e5c38c3f95a864c4b993ef04dda8244\",\"license\":\"MIT\"},\"contracts/libraries/CcExchangeRouterLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.8.4;\\n\\nimport \\\"@teleportdao/btc-evm-bridge/contracts/relay/interfaces/IBitcoinRelay.sol\\\";\\nimport \\\"@teleportdao/btc-evm-bridge/contracts/libraries/BitcoinHelper.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"../routers/interfaces/ICcExchangeRouter.sol\\\";\\nimport \\\"../libraries/RequestParser.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\nlibrary CcExchangeRouterLib {\\n\\n    /// @notice Parses and stores exchange request if it's valid\\n    function ccExchangeHelper(\\n        ICcExchangeRouter.TxAndProof memory _txAndProof,\\n        mapping(bytes32 => ICcExchangeRouter.ccExchangeRequest) storage ccExchangeRequests,\\n        mapping(bytes32 => ICcExchangeRouter.extendedCcExchangeRequest) storage extendedCcExchangeRequests,\\n        address _teleBTC,\\n        address _wrappedNativeToken,\\n        uint _maxProtocolFee,\\n        bytes memory _lockerLockingScript,\\n        address _relay\\n    ) external returns (bytes32) {\\n\\n        // Finds tx id\\n        bytes32 txId = BitcoinHelper.calculateTxId(\\n            _txAndProof.version, _txAndProof.vin, _txAndProof.vout, _txAndProof.locktime\\n        );\\n\\n        // Checks that the request has not been processed before\\n        require(\\n            !ccExchangeRequests[txId].isUsed,\\n            \\\"ExchangeRouterLib: already used\\\"\\n        );\\n\\n        // Extracts value and OP_RETURN data from the request\\n        ICcExchangeRouter.ccExchangeRequest memory request;\\n        bytes memory arbitraryData;\\n        \\n        (request.inputAmount, arbitraryData) = BitcoinHelper.parseValueAndDataHavingLockingScriptSmallPayload(\\n            _txAndProof.vout, \\n            _lockerLockingScript\\n        );\\n\\n        /*  \\n            Exchange requests structure:\\n            1) chainId, 2 byte: max 65535 chains\\n            2) appId, 1 byte: max 256 apps\\n            3) recipientAddress, 20 byte: EVM account\\n            4) networkFee, 3 byte\\n            5) SPEED, 1 byte: {0,1}\\n            6) thirdParty, 1 byte: max 256 third parties, default is 0 for no third party\\n            7) exchangeToken, 20 byte: token address\\n            8) outputAmount, 14 byte: min expected output amount. Assuming that the token supply\\n               is less than 10^15 and token decimal is 18 (> (10^18) * (10^18))\\n            9) bridgeFee, 3 byte: will be multiply by 10^11, 10^18 means 100%, so the minimum \\n            amount of fee percentage is 10^-5%\\n            \\n            TOTAL = 65 BYTE\\n        */\\n        require(arbitraryData.length == 65, \\\"ExchangeRouterLib: invalid len\\\");\\n        require(request.inputAmount > 0, \\\"ExchangeRouterLib: zero input\\\");\\n\\n        extendedCcExchangeRequests[txId].chainId = RequestParser.parseChainId(arbitraryData);\\n        extendedCcExchangeRequests[txId].bridgeFee = RequestParser.parseaArossFeePercentage(arbitraryData);\\n        extendedCcExchangeRequests[txId].thirdParty = RequestParser.parseThirdPartyId(arbitraryData);\\n        \\n        request.appId = RequestParser.parseAppId(arbitraryData);\\n        address exchangeToken = RequestParser.parseExchangeToken(arbitraryData);\\n        request.outputAmount = RequestParser.parseExchangeOutputAmount(arbitraryData);\\n        request.isFixedToken = true; // Note: we assume input amount is fixed\\n        request.recipientAddress = RequestParser.parseRecipientAddress(arbitraryData);\\n\\n        // Note: default exchange path is: [teleBTC, exchangeToken]\\n        request.path = new address[](2);\\n        request.path[0] = _teleBTC;\\n        request.path[1] = exchangeToken;\\n\\n        // Finds Teleporter fee\\n        uint networkFee = RequestParser.parseNetworkFee(arbitraryData);\\n\\n        require(networkFee <= request.inputAmount, \\\"ExchangeRouterLib: wrong fee\\\");\\n        request.fee = networkFee;\\n        \\n        // Note: speed now determines using fillers to speed up filling request (speed = 1) or not\\n        request.speed = RequestParser.parseSpeed(arbitraryData);\\n        request.isUsed = true;\\n\\n        // Saves request\\n        ccExchangeRequests[txId] = request;\\n\\n        require(\\n            _isConfirmed(\\n                _txAndProof,\\n                _relay,\\n                txId\\n            ),\\n            \\\"ExchangeRouter: not finalized\\\"\\n        );\\n\\n        return txId;\\n    }\\n\\n    /// @notice Verifies the signature of _msgHash\\n    /// @return _signer Address of message signer (if signature is valid)\\n    function _verifySig(\\n        bytes32 _msgHash, \\n        bytes32 _r, \\n        bytes32 _s,\\n        uint8 _v\\n    ) public view returns (address _signer) {\\n        // Verify the message using ecrecover\\n        _signer = ecrecover(_msgHash, _v, _r, _s);\\n        require(_signer != address(0), \\\"ExchangeRouterLib: invalid sig\\\");\\n    }\\n\\n    /// @notice Checks inclusion of the transaction in the specified block\\n    /// @dev Calls the relay contract to check Merkle inclusion proof\\n    /// @param _relay Address of Relay contract\\n    /// @param _txId of the transaction\\n    /// @return True if the transaction was included in the block\\n    function _isConfirmed(\\n        ICcExchangeRouter.TxAndProof memory _txAndProof,\\n        address _relay,\\n        bytes32 _txId\\n    ) internal returns (bool) {\\n        // Finds fee amount\\n        uint feeAmount = _getFinalizedBlockHeaderFee(_relay, _txAndProof.blockNumber);\\n        require(msg.value >= feeAmount, \\\"ExchangeRouterLib: low fee\\\");\\n\\n        // Calls relay contract\\n        bytes memory data = Address.functionCallWithValue(\\n            _relay,\\n            abi.encodeWithSignature(\\n                \\\"checkTxProof(bytes32,uint256,bytes,uint256)\\\",\\n                _txId,\\n                _txAndProof.blockNumber,\\n                _txAndProof.intermediateNodes,\\n                _txAndProof.index\\n            ),\\n            feeAmount\\n        );\\n\\n        // Sends extra ETH back to msg.sender\\n        Address.sendValue(payable(msg.sender), msg.value - feeAmount);\\n\\n        return abi.decode(data, (bool));\\n    }\\n\\n    function _getFinalizedBlockHeaderFee(\\n        address _relay, \\n        uint _blockNumber\\n    ) private view returns (uint) {\\n        return IBitcoinRelay(_relay).getBlockHeaderFee(_blockNumber, 0);\\n    }\\n}\",\"keccak256\":\"0x56a904baea397a2ed1a7982ef19206d57a00acc8c182c93ffdba963158485d6d\",\"license\":\"MIT\"},\"contracts/libraries/RequestParser.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.8.4;\\n\\n/// @notice Library for parsing cc transfer and cc exchange requests\\nlibrary RequestParser {\\n    /// @notice Returns chain id of the request\\n    /// @param _arbitraryData Data written in Bitcoin tx\\n    function parseChainId(bytes memory _arbitraryData) internal pure returns (uint16 parsedValue) {\\n        bytes memory slicedBytes = sliceBytes(_arbitraryData, 0, 1);\\n        assembly {\\n            parsedValue := mload(add(slicedBytes, 2))\\n        }\\n    }\\n\\n    /// @notice Returns app id of the request\\n    /// @dev Determines the app that request belongs to (e.g. cc transfer app id is 0)\\n    function parseAppId(bytes memory _arbitraryData) internal pure returns (uint8 parsedValue) {\\n        bytes memory slicedBytes = sliceBytes(_arbitraryData, 2, 2);\\n        assembly {\\n            parsedValue := mload(add(slicedBytes, 1))\\n        }\\n    }\\n\\n    /// @notice Returns recipient address\\n    /// @dev Minted TeleBTC or exchanged tokens will be sent to this address\\n    function parseRecipientAddress(bytes memory _arbitraryData) internal pure returns (address parsedValue) {\\n        bytes memory slicedBytes = sliceBytes(_arbitraryData, 3, 22);\\n        assembly {\\n            parsedValue := mload(add(slicedBytes, 20))\\n        }\\n    }\\n\\n    /// @notice Returns network fee\\n    /// @dev This fee goes to Teleporter who submitted the request\\n    function parseNetworkFee(bytes memory _arbitraryData) internal pure returns (uint24 parsedValue) {\\n        bytes memory slicedBytes = sliceBytes(_arbitraryData, 23, 25);\\n        assembly {\\n            parsedValue := mload(add(slicedBytes, 3))\\n        }\\n    }\\n\\n    /// @notice Determines type of the request\\n    /// @dev 0 for normal requests, 1 for fixed-rate requests\\n    function parseSpeed(bytes memory _arbitraryData) internal pure returns (uint8 parsedValue) {\\n        bytes memory slicedBytes = sliceBytes(_arbitraryData, 26, 26);\\n        assembly {\\n            parsedValue := mload(add(slicedBytes, 1))\\n        }\\n    }\\n\\n    /// @notice Returns id of third party\\n    /// @dev 0 for no third party\\n    function parseThirdPartyId(bytes memory _arbitraryData) internal pure returns (uint8 parsedValue){\\n        bytes memory slicedBytes = sliceBytes(_arbitraryData, 27, 27);\\n        assembly {\\n            parsedValue := mload(add(slicedBytes, 1))\\n        }\\n    }\\n\\n    /// @notice Returns address of exchange token\\n    /// @dev Minted TeleBTC will be exchanged for this token\\n    function parseExchangeToken(bytes memory _arbitraryData) internal pure returns (address parsedValue){\\n        bytes memory slicedBytes = sliceBytes(_arbitraryData, 28, 47);\\n        assembly {\\n            parsedValue := mload(add(slicedBytes, 20))\\n        }\\n    }\\n\\n    /// @notice Returns min expected output (exchange) amount\\n    function parseExchangeOutputAmount(bytes memory _arbitraryData) internal pure returns (uint112 parsedValue){\\n        bytes memory slicedBytes = sliceBytes(_arbitraryData, 48, 61);\\n        assembly {\\n            parsedValue := mload(add(slicedBytes, 14))\\n        }\\n    }\\n\\n    /// @notice Returns across percentage fee \\n    /// @dev This fee goes to across relayers\\n    function parseaArossFeePercentage(bytes memory _arbitraryData) internal pure returns (uint24 parsedValue) {\\n        bytes memory slicedBytes = sliceBytes(_arbitraryData, 62, 64);\\n        assembly {\\n            parsedValue := mload(add(slicedBytes, 3))\\n        }\\n    }\\n\\n    /// @notice Returns the sliced bytes\\n    /// @param _data Slicing data\\n    /// @param _start index of slicing\\n    /// @param _end index of slicing\\n    function sliceBytes(\\n        bytes memory _data,\\n        uint _start,\\n        uint _end\\n    ) internal pure returns (bytes memory _result) {\\n        bytes1 temp;\\n        for (uint i = _start; i < _end + 1; i++) {\\n            temp = _data[i];\\n            _result = abi.encodePacked(_result, temp);\\n        }\\n    }\\n\\n}\\n\",\"keccak256\":\"0xef98e32ff52781348c872a10151a655db0fb93b35bd23387b8ccf1235d0c86c1\",\"license\":\"MIT\"},\"contracts/lockers/interfaces/ILockers.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.8.4;\\n\\nimport \\\"./ILockersStorage.sol\\\";\\n\\ninterface ILockers is ILockersStorage {\\n\\n     // Events\\n\\n    event RequestAddLocker(\\n        address indexed lockerTargetAddress,\\n        bytes lockerLockingScript,\\n        uint TDTLockedAmount,\\n        uint nativeTokenLockedAmount\\n    );\\n\\n    event RevokeAddLockerRequest(\\n        address indexed lockerTargetAddress,\\n        bytes lockerLockingScript,\\n        uint TDTLockedAmount,\\n        uint nativeTokenLockedAmount\\n    );\\n\\n    event RequestInactivateLocker(\\n        address indexed lockerTargetAddress,\\n        uint indexed inactivationTimestamp,\\n        bytes lockerLockingScript,\\n        uint TDTLockedAmount,\\n        uint nativeTokenLockedAmount,\\n        uint netMinted\\n    );\\n\\n    event ActivateLocker(\\n        address indexed lockerTargetAddress,\\n        bytes lockerLockingScript,\\n        uint TDTLockedAmount,\\n        uint nativeTokenLockedAmount,\\n        uint netMinted\\n    );\\n\\n    event LockerAdded(\\n        address indexed lockerTargetAddress,\\n        bytes lockerLockingScript,\\n        uint TDTLockedAmount,\\n        uint nativeTokenLockedAmount,\\n        uint addingTime\\n    );\\n\\n    event LockerRemoved(\\n        address indexed lockerTargetAddress,\\n        bytes lockerLockingScript,\\n        uint TDTUnlockedAmount,\\n        uint nativeTokenUnlockedAmount\\n    );\\n\\n    event LockerSlashed(\\n        address indexed lockerTargetAddress,\\n        uint rewardAmount,\\n        address indexed rewardRecipient,\\n        uint amount,\\n        address indexed recipient,\\n        uint slashedCollateralAmount,\\n        uint slashTime,\\n        bool isForCCBurn\\n    );\\n\\n    event LockerLiquidated(\\n        address indexed lockerTargetAddress,\\n        address indexed liquidatorAddress,\\n        uint collateralAmount,\\n        uint teleBTCAmount,\\n        uint liquidateTime\\n    );\\n\\n    event LockerSlashedCollateralSold(\\n        address indexed lockerTargetAddress,\\n        address indexed buyerAddress,\\n        uint slashingAmount,\\n        uint teleBTCAmount,\\n        uint slashingTime\\n    );\\n\\n    event CollateralAdded(\\n        address indexed lockerTargetAddress,\\n        uint addedCollateral,\\n        uint totalCollateral,\\n        uint addingTime\\n    );\\n\\n    event CollateralRemoved(\\n        address indexed lockerTargetAddress,\\n        uint removedCollateral,\\n        uint totalCollateral,\\n        uint removingTime\\n    );\\n\\n    event MintByLocker(\\n        address indexed lockerTargetAddress,\\n        address indexed receiver,\\n        uint mintedAmount,\\n        uint lockerFee,\\n        uint mintingTime\\n    );\\n\\n    event BurnByLocker(\\n        address indexed lockerTargetAddress,\\n        uint burntAmount,\\n        uint lockerFee,\\n        uint burningTime\\n    );\\n\\n    event MinterAdded(\\n        address indexed account\\n    );\\n\\n    event MinterRemoved(\\n        address indexed account\\n    );\\n\\n    event BurnerAdded(\\n        address indexed account\\n    );\\n    \\n    event BurnerRemoved(\\n        address indexed account\\n    );\\n\\n    event NewLockerPercentageFee(\\n        uint oldLockerPercentageFee,\\n        uint newLockerPercentageFee\\n    );\\n\\n    event NewPriceWithDiscountRatio(\\n        uint oldPriceWithDiscountRatio,\\n        uint newPriceWithDiscountRatio\\n    );\\n\\n    event NewMinRequiredTDTLockedAmount(\\n        uint oldMinRequiredTDTLockedAmount,\\n        uint newMinRequiredTDTLockedAmount\\n    );\\n\\n    event NewMinRequiredTNTLockedAmount(\\n        uint oldMinRequiredTNTLockedAmount,\\n        uint newMinRequiredTNTLockedAmount\\n    );\\n\\n    event NewPriceOracle(\\n        address oldPriceOracle,\\n        address newPriceOracle\\n    );\\n\\n    event NewCCBurnRouter(\\n        address oldCCBurnRouter,\\n        address newCCBurnRouter\\n    );\\n\\n    event NewExchangeConnector(\\n        address oldExchangeConnector,\\n        address newExchangeConnector\\n    );\\n\\n    event NewTeleportDAOToken(\\n        address oldTDTToken,\\n        address newTDTToken\\n    ); \\n\\n    event NewTeleBTC(\\n        address oldTeleBTC,\\n        address newTeleBTC\\n    );   \\n\\n    event NewCollateralRatio(\\n        uint oldCollateralRatio,\\n        uint newCollateralRatio\\n    );  \\n\\n    event NewLiquidationRatio(\\n        uint oldLiquidationRatio,\\n        uint newLiquidationRatio\\n    );   \\n\\n    // Read-only functions\\n\\n    function getLockerTargetAddress(bytes calldata _lockerLockingScript) external view returns (address);\\n\\n    function isLocker(bytes calldata _lockerLockingScript) external view returns (bool);\\n\\n    function getNumberOfLockers() external view returns (uint);\\n\\n    function getLockerLockingScript(address _lockerTargetAddress) external view returns (bytes memory);\\n\\n    function isLockerActive(address _lockerTargetAddress) external view returns (bool);\\n\\n    function priceOfOneUnitOfCollateralInBTC() external view returns (uint);\\n\\n    function isMinter(address account) external view returns(bool);\\n\\n    function isBurner(address account) external view returns(bool);\\n\\n    // State-changing functions\\n\\n    function pauseLocker() external;\\n\\n    function unPauseLocker() external;\\n\\n    function addMinter(address _account) external;\\n\\n    function removeMinter(address _account) external;\\n\\n    function addBurner(address _account) external;\\n\\n    function removeBurner(address _account) external;\\n\\n    function mint(bytes calldata _lockerLockingScript, address _receiver, uint _amount) external returns(uint);\\n\\n    function burn(bytes calldata _lockerLockingScript, uint256 _amount) external returns(uint);\\n\\n    function setTeleportDAOToken(address _tdtTokenAddress) external;\\n\\n    function setLockerPercentageFee(uint _lockerPercentageFee) external;\\n\\n    function setPriceWithDiscountRatio(uint _priceWithDiscountRatio) external;\\n\\n    function setMinRequiredTDTLockedAmount(uint _minRequiredTDTLockedAmount) external;\\n\\n    function setMinRequiredTNTLockedAmount(uint _minRequiredTNTLockedAmount) external;\\n\\n    function setPriceOracle(address _priceOracle) external;\\n\\n    function setCCBurnRouter(address _ccBurnRouter) external;\\n\\n    function setExchangeConnector(address _exchangeConnector) external;\\n\\n    function setTeleBTC(address _teleBTC) external;\\n\\n    function setCollateralRatio(uint _collateralRatio) external;\\n\\n    function setLiquidationRatio(uint _liquidationRatio) external;\\n\\n    function liquidateLocker(\\n        address _lockerTargetAddress,\\n        uint _btcAmount\\n    ) external returns (bool);\\n\\n    function addCollateral(\\n        address _lockerTargetAddress,\\n        uint _addingNativeTokenAmount\\n    ) external payable returns (bool);\\n\\n    function removeCollateral(\\n        uint _removingNativeTokenAmount\\n    ) external payable returns (bool);\\n\\n    function requestToBecomeLocker(\\n        bytes calldata _lockerLockingScript,\\n        uint _lockedTDTAmount,\\n        uint _lockedNativeTokenAmount,\\n        ScriptTypes _lockerRescueType,\\n        bytes calldata _lockerRescueScript\\n    ) external payable returns (bool);\\n\\n    function revokeRequest() external returns (bool);\\n\\n    function addLocker(address _lockerTargetAddress) external returns (bool);\\n\\n    function requestInactivation() external returns (bool);\\n\\n    function requestActivation() external returns (bool);\\n\\n    function selfRemoveLocker() external returns (bool);\\n\\n    function slashIdleLocker(\\n        address _lockerTargetAddress,\\n        uint _rewardAmount,\\n        address _rewardRecipient,\\n        uint _amount,\\n        address _recipient\\n    ) external returns(bool);\\n\\n    function slashThiefLocker(\\n        address _lockerTargetAddress,\\n        uint _rewardAmount,\\n        address _rewardRecipient,\\n        uint _amount\\n    ) external returns(bool);\\n\\n    function buySlashedCollateralOfLocker(\\n        address _lockerTargetAddress,\\n        uint _collateralAmount\\n    ) external returns (bool);\\n\\n}\",\"keccak256\":\"0xf12133c535eeb0a7dedbca5b701825164f4159c78fb88ce59aa4bb44293b5795\",\"license\":\"MIT\"},\"contracts/lockers/interfaces/ILockersStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.8.4;\\n\\nimport \\\"../../types/DataTypes.sol\\\";\\n\\ninterface ILockersStorage {\\n    // Read-only functions\\n\\n    function TeleportDAOToken() external view returns(address);\\n\\n    function teleBTC() external view returns(address);\\n\\n    function ccBurnRouter() external view returns(address);\\n\\n    function exchangeConnector() external view returns(address);\\n\\n    function priceOracle() external view returns(address);\\n\\n    function minRequiredTDTLockedAmount() external view returns(uint);\\n\\n    function minRequiredTNTLockedAmount() external view returns(uint);\\n\\n    function lockerPercentageFee() external view returns(uint);\\n\\n    function collateralRatio() external view returns(uint);\\n\\n    function liquidationRatio() external view returns(uint);\\n\\n    function priceWithDiscountRatio() external view returns(uint);\\n\\n    function totalNumberOfCandidates() external view returns(uint);\\n\\n    function totalNumberOfLockers() external view returns(uint);\\n  \\n}\\n\\n\\n\\n \",\"keccak256\":\"0xfbe29ee307724219396c389feb47b2a20199bdbd7fc3f99c9a225db15945d252\",\"license\":\"MIT\"},\"contracts/routers/CcExchangeRouterLogic.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.8.4;\\n\\nimport \\\"./CcExchangeRouterStorage.sol\\\";\\nimport \\\"./CcExchangeRouterStorageV2.sol\\\";\\nimport \\\"./interfaces/IBurnRouter.sol\\\";\\nimport \\\"./interfaces/ICcExchangeRouter.sol\\\";\\nimport \\\"../connectors/interfaces/IExchangeConnector.sol\\\";\\nimport \\\"../erc20/interfaces/ITeleBTC.sol\\\";\\nimport \\\"../lockers/interfaces/ILockers.sol\\\";\\nimport \\\"../libraries/CcExchangeRouterLib.sol\\\";\\nimport \\\"@teleportdao/btc-evm-bridge/contracts/relay/interfaces/IBitcoinRelay.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"solidity-bytes-utils/contracts/BytesLib.sol\\\";\\nimport \\\"@across-protocol/contracts-v2/contracts/interfaces/SpokePoolInterface.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\ncontract CcExchangeRouterLogic is CcExchangeRouterStorage, \\n    OwnableUpgradeable, ReentrancyGuardUpgradeable, CcExchangeRouterStorageV2 {\\n\\n    using BytesLib for bytes;\\n\\n    modifier nonZeroAddress(address _address) {\\n        require(_address != address(0), \\\"ExchangeRouter: zero address\\\");\\n        _;\\n    }\\n\\n    // Contract is payable\\n    receive() external payable {}\\n\\n    /// @notice Gives default params to initiate cc exchange router\\n    /// @param _startingBlockNumber Requests that are included in a block older \\n    ///                             than _startingBlockNumber cannot be executed\\n    /// @param _protocolPercentageFee Percentage amount of protocol fee (min: %0.01)\\n    /// @param _chainId Id of the target chain\\n    /// @param _relay The Relay address to validate data from source chain\\n    /// @param _lockers Lockers' contract address\\n    /// @param _teleBTC TeleportDAO BTC ERC20 token address\\n    /// @param _treasury Address of treasury that collects protocol fees\\n    function initialize(\\n        uint _startingBlockNumber,\\n        uint _protocolPercentageFee,\\n        uint _chainId,\\n        address _lockers,\\n        address _relay,\\n        address _teleBTC,\\n        address _treasury,\\n        address _across,\\n        address _burnRouter\\n    ) public initializer {\\n        OwnableUpgradeable.__Ownable_init();\\n        ReentrancyGuardUpgradeable.__ReentrancyGuard_init();\\n\\n        chainId = _chainId;\\n        isChainSupported[chainId] = true;\\n        _setStartingBlockNumber(_startingBlockNumber);\\n        _setProtocolPercentageFee(_protocolPercentageFee);\\n        _setRelay(_relay);\\n        _setLockers(_lockers);\\n        _setTeleBTC(_teleBTC);\\n        _setTreasury(_treasury);\\n        _setAcross(_across);\\n        _setBurnRouter(_burnRouter);\\n    }\\n\\n    function renounceOwnership() public virtual override onlyOwner {}\\n\\n    /// @notice Setter for starting block number\\n    function setStartingBlockNumber(uint _startingBlockNumber) external override onlyOwner {\\n        _setStartingBlockNumber(_startingBlockNumber);\\n    }\\n\\n    /// @notice Updates relay contract address\\n    function setRelay(address _relay) external override onlyOwner {\\n        _setRelay(_relay);\\n    }\\n\\n    /// @notice                 Changes instantRouter contract address\\n    /// @dev                    Only owner can call this\\n    /// @param _instantRouter   The new instantRouter contract address\\n    function setInstantRouter(address _instantRouter) external override onlyOwner {\\n        _setInstantRouter(_instantRouter);\\n    }\\n\\n    /// @notice Updates lockers contract address\\n    function setLockers(address _lockers) external override onlyOwner {\\n        _setLockers(_lockers);\\n    }\\n\\n    /// @notice Sets appId for an exchange connector\\n    /// @dev _exchangeConnector can be set to zero to inactive an app\\n    function setExchangeConnector(\\n        uint _appId, \\n        address _exchangeConnector\\n    ) external override onlyOwner {\\n        exchangeConnector[_appId] = _exchangeConnector;\\n        emit SetExchangeConnector(_appId, _exchangeConnector);\\n    }\\n\\n    /// @notice Updates teleBTC contract address\\n    function setTeleBTC(address _teleBTC) external override onlyOwner {\\n        _setTeleBTC(_teleBTC);\\n    }\\n\\n    /// @notice Setter for protocol percentage fee\\n    function setProtocolPercentageFee(uint _protocolPercentageFee) external override onlyOwner {\\n        _setProtocolPercentageFee(_protocolPercentageFee);\\n    }\\n\\n    /// @notice Setter for treasury\\n    function setTreasury(address _treasury) external override onlyOwner {\\n        _setTreasury(_treasury);\\n    }\\n\\n    // /// @notice Setter for filler withdraw interval\\n    // /// @dev Assuming that filling is started at X, \\n    // ///      fillers cannot withdraw their funds before x + _fillerWithdrawInterval\\n    // ///      (unless that filling is completed)\\n    // function setFillerWithdrawInterval(uint _fillerWithdrawInterval) external override onlyOwner {\\n    //     _setFillerWithdrawInterval(_fillerWithdrawInterval);\\n    // }\\n\\n    /// @notice Setter for across\\n    function setAcross(address _across) external override onlyOwner {\\n        _setAcross(_across);\\n    }\\n\\n    /// @notice Setter for burnRouters\\n    function setBurnRouter(address _burnRouter) external override onlyOwner {\\n        _setBurnRouter(_burnRouter);\\n    }\\n\\n    /// @notice                             Setter for third party address\\n    /// @dev                                Only owner can call this\\n    /// @param _thirdPartyAddress           third party address\\n    function setThirdPartyAddress(uint _thirdPartyId, address _thirdPartyAddress) external override onlyOwner {\\n        _setThirdPartyAddress(_thirdPartyId, _thirdPartyAddress);\\n    }\\n\\n    /// @notice                             Setter for third party fee\\n    /// @dev                                Only owner can call this\\n    /// @param _thirdPartyFee               third party fee\\n    function setThirdPartyFee(uint _thirdPartyId, uint _thirdPartyFee) external override onlyOwner {\\n        _setThirdPartyFee(_thirdPartyId, _thirdPartyFee);\\n    }\\n\\n    /// @notice                             Setter for chain id mapping\\n    /// @dev                                Only owner can call this\\n    function setChainIdMapping(uint _mappedId, uint _middleChain, uint _destinationChain) external override onlyOwner {\\n        _setChainIdMapping(_middleChain, _destinationChain, _mappedId);\\n    }\\n    \\n\\n    /// @notice Adding a token as supported token on specific chain\\n    function supportToken(uint chainId, address _token) external override onlyOwner {\\n        emit TokenAdded(chainId, _token);\\n        isTokenSupported[chainId][_token] = true;\\n    }\\n\\n    /// @notice Removing a token as supported token on specific chain\\n    function removeToken(uint chainId, address _token) external override onlyOwner {\\n        emit TokenRemoved(chainId, _token);\\n        isTokenSupported[chainId][_token] = false;\\n    }\\n\\n    /// @notice Adding a new chainId\\n    function supportChain(uint _chainId) external override onlyOwner {\\n        emit ChainAdded(_chainId);\\n        isChainSupported[_chainId] = true;\\n    }\\n\\n    /// @notice Removing a chainId\\n    function removeChain(uint _chainId) external override onlyOwner {\\n        emit ChainRemoved(_chainId);\\n        isChainSupported[_chainId] = false;\\n    }\\n\\n    /// @notice Checks if a request has been executed before\\n    /// @dev It prevents re-submitting an executed request\\n    /// @param _txId The transaction ID of request on Bitcoin \\n    /// @return True if the cc exchange request has been already executed\\n    function isRequestUsed(bytes32 _txId) external view override returns (bool) {\\n        return ccExchangeRequests[_txId].isUsed ? true : false;\\n    }\\n\\n    function extractChainId(uint chainId) public view returns (uint, uint) {\\n        return (chainIdMapping[chainId].middleChain, chainIdMapping[chainId].destinationChain);\\n    }\\n\\n    function extractDestinationChainId(uint chainId) public view returns (uint) {\\n        return chainIdMapping[chainId].destinationChain;\\n    }\\n\\n    function setMappingChainId(uint middleChain, uint destinationChain, uint mappedId) public {\\n        chainIdMapping[mappedId] = chainIdStruct(\\n            middleChain, \\n            destinationChain\\n        );\\n    }\\n\\n    /// @notice Executes a cross-chain exchange request after checking its merkle inclusion proof\\n    /// @dev Mints teleBTC for user if exchanging is not successful\\n    /// @param _txAndProof Transaction and merkle proof data\\n    /// @param _lockerLockingScript Script hash of locker that user has sent BTC to it\\n    /// @param _path (Optional) Exchange path from teleBTC to the output token. This is used if \\n    ///              the default path [teleBTC, wrappedNativeToken, outputToken] not exist or\\n    ///              exchanging using this path fails\\n    /// @return true \\n    function wrapAndSwap(\\n        TxAndProof memory _txAndProof,\\n        bytes calldata _lockerLockingScript,\\n        address[] memory _path\\n    ) external payable nonReentrant override virtual returns (bool) {\\n        // Basic checks\\n        require(_msgSender() == instantRouter, \\\"ExchangeRouter: invalid sender\\\"); // Only Teleporter can submit requests\\n        require(_txAndProof.blockNumber >= startingBlockNumber, \\\"ExchangeRouter: old request\\\");\\n        require(_txAndProof.locktime == bytes4(0), \\\"ExchangeRouter: non-zero locktime\\\");\\n\\n        // Checks that the given script hash is locker\\n        require(\\n            ILockers(lockers).isLocker(_lockerLockingScript),\\n            \\\"ExchangeRouter: not locker\\\"\\n        );\\n\\n        // Extracts information from the request and checks if transaction has been finalized on Bitcoin\\n        bytes32 txId = CcExchangeRouterLib.ccExchangeHelper(\\n            _txAndProof,\\n            ccExchangeRequests,\\n            extendedCcExchangeRequests,\\n            teleBTC,\\n            wrappedNativeToken,\\n            MAX_PROTOCOL_FEE,\\n            _lockerLockingScript,\\n            relay\\n        );\\n\\n        // extract the middle chain Id (the chain user is sending the request to) \\n        // and destination chain Id (the final chain that user gets its token on it) from chainId\\n        (uint middleChainId, uint destinationChainId) = extractChainId(extendedCcExchangeRequests[txId].chainId);\\n\\n        // middle chain Id must be equal to current chain\\n        require(middleChainId == chainId, \\\"ExchangeRouter: wrong chain\\\");\\n        \\n        require(\\n            isChainSupported[destinationChainId],\\n            \\\"ExchangeRouter: invalid chain id\\\"\\n        );\\n\\n        ccExchangeRequest memory request = ccExchangeRequests[txId];\\n    \\n        address _exchangeConnector = exchangeConnector[request.appId];\\n        require(\\n            _exchangeConnector != address(0), \\n            \\\"ExchangeRouter: invalid appId\\\"\\n        );\\n\\n        // Finds remained amount after reducing fees\\n        _mintAndReduceFees(\\n            _lockerLockingScript, \\n            txId\\n        );\\n\\n        \\n\\n        require(request.speed == 0, \\\"ExchangeRouter: filler is not supported\\\");\\n\\n        // if (\\n        //     request.speed == 1 && \\n        //     _canFill(\\n        //         txId, \\n        //         request.path[request.path.length - 1], // output token \\n        //         request.outputAmount\\n        //     )\\n        // ) {\\n        //     // Fills exchange request\\n        //     _fillCcExchange(\\n        //         _lockerLockingScript, \\n        //         txId, \\n        //         request\\n        //     );\\n\\n        // } else {\\n            if (destinationChainId == chainId) { // Requests that belongs to the current chain\\n                // Normal exchange request for a request which has not been filled\\n                _wrapAndSwap(\\n                    _exchangeConnector, \\n                    _lockerLockingScript, \\n                    txId, \\n                    _path\\n                );\\n            } else { // Requests that belongs to the other chain\\n                // Exchange and send to other chain for a request which has not been filled\\n                _wrapAndSwapToOtherChain( \\n                    _exchangeConnector, \\n                    _lockerLockingScript, \\n                    txId, \\n                    _path, \\n                    extendedCcExchangeRequests[txId].bridgeFee,\\n                    destinationChainId\\n                );\\n            }\\n        // }\\n\\n        return true;\\n    }\\n\\n    // /// @notice Filler fills an upcoming exchange request\\n    // /// @param _txId Bitcoin request that filler wants to fill\\n    // /// @param _token Address of exchange token in the request\\n    // /// @param _amount Requested exchanging amount\\n    // function fillTx(\\n    //     bytes32 _txId,\\n    //     address _recipient,\\n    //     address _token,\\n    //     uint _amount,\\n    //     uint _requestAmount\\n    // ) external override payable nonReentrant {\\n    //     require (_amount > 0,  \\\"ExchangeRouter: zero amount\\\");\\n    //     require (\\n    //         fillersData[_txId][_msgSender()].amount == 0, \\n    //         \\\"ExchangeRouter: already filled\\\"\\n    //     );\\n\\n    //     PrefixFillSum storage _prefixFillSum = prefixFillSums[_txId][_token];\\n\\n    //     if (_prefixFillSum.currentIndex == 0) {\\n    //         // ^ This is the first filling\\n    //         _prefixFillSum.prefixSum.push(0);\\n    //         _prefixFillSum.currentIndex = 1;\\n    //     }\\n\\n    //     // Stores the filling info\\n    //     uint index = _prefixFillSum.currentIndex;\\n\\n    //     if (_requestAmount > _prefixFillSum.prefixSum[index]) {\\n    //         uint fillAmount = _requestAmount - _prefixFillSum.prefixSum[index];\\n\\n    //         if (_token == NATIVE_TOKEN) {\\n    //             require(msg.value >= fillAmount, \\\"ExchangeRouter: incorrect amount\\\");\\n    //             (bool sentToRecipient, bytes memory data1) = _recipient.call{value: fillAmount}(\\\"\\\");\\n    //             (bool sentToFiller, bytes memory data2) = _msgSender().call{value: fillAmount}(\\\"\\\");\\n    //             require(\\n    //                 sentToRecipient == true && sentToFiller == true,\\n    //                 \\\"ExchangeRouter: failed to transfer native token\\\"\\n    //             );\\n    //         } else {\\n    //             require(\\n    //                 IERC20(_token).transferFrom(_msgSender(), _recipient, fillAmount),\\n    //                 \\\"ExchangeRouter: no allowance\\\"\\n    //             ); \\n    //         }\\n\\n    //         fillersData[_txId][_msgSender()] = FillerData(_prefixFillSum.currentIndex, _token, fillAmount);\\n\\n    //         // Updates the cumulative filling\\n    //         _prefixFillSum.prefixSum.push(_prefixFillSum.prefixSum[index - 1] + fillAmount);\\n    //         _prefixFillSum.currentIndex += 1;\\n\\n    //         if (fillsData[_txId].startingTime == 0) {  \\n    //             // ^ No one has filled before\\n    //             fillsData[_txId].startingTime = block.timestamp;\\n\\n    //             emit FillStarted(\\n    //                 _txId, \\n    //                 block.timestamp\\n    //             );\\n    //         }\\n\\n    //         emit NewFill(\\n    //             _msgSender(),\\n    //             _txId, \\n    //             _token,\\n    //             fillAmount\\n    //         );\\n    //     }\\n    // }\\n\\n    // TODO remove\\n    // / @notice Fillers can withdraw their unused tokens\\n    // / @param _txId Bitcoin request which filling belongs to\\n    // / @return true if withdrawing was successful\\n    // function returnUnusedFill(\\n    //     bytes32 _txId\\n    // ) external override nonReentrant returns (bool) {\\n    //     FillData memory fillData = fillsData[_txId];\\n\\n    //     // To withdraw tokens, either request should have been processed or \\n    //     // deadline for processing should has been passed\\n    //     require (\\n    //         ccExchangeRequests[_txId].inputAmount > 0 || \\n    //             fillData.startingTime + fillerWithdrawInterval < block.timestamp, \\n    //         \\\"ExchangeRouter: req not processed nor time not passed\\\"\\n    //     );\\n\\n    //     FillerData memory fillerData = fillersData[_txId][_msgSender()];\\n        \\n    //     // To withdraw token, either token should be wrong or token should have not been used\\n    //     if (fillData.reqToken != fillerData.token || fillData.lastUsedIdx < fillerData.index) {\\n    //         if (fillerData.token == NATIVE_TOKEN) {\\n    //             require(\\n    //                 payable(_msgSender()).send(fillerData.amount), \\n    //                 \\\"ExchangeRouter: can't send Ether\\\"\\n    //             );\\n    //         } else {\\n    //             require(\\n    //                 IERC20(fillerData.token).transfer(_msgSender(), fillerData.amount), \\n    //                 \\\"ExchangeRouter: can't transfer token\\\"\\n    //             );\\n    //         }\\n    //         fillersData[_txId][_msgSender()].amount = 0;\\n\\n    //         emit FillTokensReturned(\\n    //             fillerData.amount,\\n    //             fillerData.token,\\n    //             _msgSender(),\\n    //             fillerData.index,\\n    //             _txId\\n    //         );\\n    //         return true;\\n    //     }\\n\\n    //     // Last used filling may used partially, so filler can withdraw remaining amount\\n    //     if (\\n    //         fillData.lastUsedIdx == fillerData.index && \\n    //         fillsData[_txId].isWithdrawnLastFill == false\\n    //     ) {\\n    //         if (fillerData.token == NATIVE_TOKEN) {\\n    //             require(\\n    //                 payable(_msgSender()).send(fillData.remainingAmountOfLastFill), \\n    //                 \\\"ExchangeRouter: can't send Ether\\\"\\n    //             );\\n    //         } else {\\n    //             require(\\n    //                 IERC20(fillerData.token).transfer(_msgSender(), fillData.remainingAmountOfLastFill), \\n    //                 \\\"ExchangeRouter: can't transfer token\\\"\\n    //             );\\n    //         }\\n    //         fillsData[_txId].isWithdrawnLastFill = true;\\n\\n    //         emit FillTokensReturned(\\n    //             fillData.remainingAmountOfLastFill,\\n    //             fillerData.token,\\n    //             _msgSender(),\\n    //             fillerData.index,\\n    //             _txId\\n    //         );\\n    //         return true;\\n    //     }\\n\\n    //     return false;\\n    // }\\n\\n    // /// @notice Filler whose tokens has been used gets teleBTC\\n    // /// @param _txId Bitcoin request which filling belongs to\\n    // /// @return true if withdrawing was successful\\n    // function getTeleBtcForFill(\\n    //    bytes32 _txId\\n    // ) external override nonReentrant returns (bool) {\\n    //     FillData memory fillData = fillsData[_txId];\\n    //     FillerData memory fillerData = fillersData[_txId][_msgSender()];\\n        \\n    //     if (fillData.lastUsedIdx > fillerData.index) {\\n    //         // ^ This filling has been fully used\\n    //         uint amount = extendedCcExchangeRequests[_txId].remainedInputAmount \\n    //             * fillerData.amount / ccExchangeRequests[_txId].outputAmount;\\n    //         require(\\n    //             ITeleBTC(teleBTC).transfer(_msgSender(), amount), \\n    //             \\\"ExchangeRouter: can't transfer TeleBTC\\\"\\n    //         );\\n    //         fillersData[_txId][_msgSender()].amount = 0;\\n\\n    //         emit FillTeleBtcSent(\\n    //             fillerData.amount,\\n    //             0,\\n    //             fillerData.token,\\n    //             _msgSender(),\\n    //             fillerData.index,\\n    //             _txId,\\n    //             extendedCcExchangeRequests[_txId].remainedInputAmount,\\n    //             amount\\n    //         );\\n    //         return true;\\n    //     }\\n\\n    //     // We treat last used filling separately since part of it may only have been used\\n    //     if (fillData.lastUsedIdx == fillerData.index) {\\n    //         uint amount = (fillerData.amount - fillData.remainingAmountOfLastFill) \\n    //             * extendedCcExchangeRequests[_txId].remainedInputAmount / ccExchangeRequests[_txId].outputAmount;\\n    //         require(\\n    //             ITeleBTC(teleBTC).transfer(_msgSender(), amount),\\n    //             \\\"ExchangeRouter: can't transfer TeleBTC\\\"\\n    //         );\\n    //         fillersData[_txId][_msgSender()].amount = 0;\\n\\n    //         emit FillTeleBtcSent(\\n    //             fillerData.amount,\\n    //             fillData.remainingAmountOfLastFill,\\n    //             fillerData.token,\\n    //             _msgSender(),\\n    //             fillerData.index,\\n    //             _txId,\\n    //             extendedCcExchangeRequests[_txId].remainedInputAmount,\\n    //             amount\\n    //         );\\n    //         return true;\\n    //     }\\n\\n    //     return false;\\n    // }\\n\\n    /// @notice ETH user whose request failed can redeem teleBTC for native BTC\\n    /// @param _txId The transaction ID of request on Bitcoin\\n    /// @param _scriptType Script type of the user script\\n    /// @param _userScript Script hash of the user on Bitcoin\\n    /// @param _acrossRelayerFee Fee that user pays to across relayer\\n    /// @param _r Signature r\\n    /// @param _s Signature s\\n    /// @param _v Signature v\\n    /// @param _lockerLockingScript Script hash of locker that user has sent BTC to it\\n    /// @return\\n    function withdrawFailedWrapAndSwap(\\n        bytes32 _txId,\\n        uint8 _scriptType,\\n        bytes memory _userScript,\\n        uint _acrossRelayerFee,\\n        bytes32 _r,\\n        bytes32 _s,\\n        uint8 _v,\\n        bytes calldata _lockerLockingScript\\n    ) external nonReentrant override returns (bool) {\\n        /* Checks that:\\n           1. Request doesn't belong to the current chain\\n           2. Request execution has been failed\\n        */\\n        require(\\n            extendedCcExchangeRequests[_txId].chainId != chainId\\n            && extendedCcExchangeRequests[_txId].isTransferredToOtherChain == false,\\n            \\\"ExchangeRouter: already processed\\\"\\n        );\\n        extendedCcExchangeRequests[_txId].isTransferredToOtherChain = true;\\n\\n        require(\\n            CcExchangeRouterLib._verifySig(\\n                _hashMsg(\\n                    abi.encode(_txId, _scriptType, _userScript, _acrossRelayerFee)\\n                ),\\n                _r,\\n                _s,\\n                _v\\n            ) == ccExchangeRequests[_txId].recipientAddress,\\n            \\\"ExchangeRouter: invalid signer\\\"\\n        );\\n\\n        \\n        // Burns teleBTC for user\\n        ITeleBTC(teleBTC).approve(\\n            burnRouter,\\n            extendedCcExchangeRequests[_txId].remainedInputAmount\\n        );\\n\\n        IBurnRouter(burnRouter).unwrap(\\n            extendedCcExchangeRequests[_txId].remainedInputAmount,\\n            _userScript,\\n            ScriptTypes(_scriptType),\\n            _lockerLockingScript,\\n            0\\n        );\\n\\n        return true;\\n    }\\n\\n    /// @notice ETH user whose exchange request failed can retry \\n    ///         to exchange teleBTC for the desired token\\n    /// @param _txId The transaction ID of request on Bitcoin\\n    /// @param _outputAmount Amount of output token\\n    /// @param _acrossRelayerFee Fee that user pays to across relayer\\n    /// @param path Exchange path from teleBTC to the output token\\n    /// @param _r Signature r\\n    /// @param _s Signature s\\n    /// @param _v Signature v\\n    function retryFailedWrapAndSwap(\\n        bytes32 _txId,\\n        uint256 _outputAmount,\\n        uint _acrossRelayerFee,\\n        address[] memory path,\\n        bytes32 _r,\\n        bytes32 _s,\\n        uint8 _v\\n    ) external nonReentrant override returns (bool) {\\n        ccExchangeRequest memory exchangeReq = ccExchangeRequests[_txId];\\n\\n        /* Checks that:\\n           1. Request doesn't belong to the current chain\\n           2. Request execution has been failed\\n        */\\n        require(\\n            extendedCcExchangeRequests[_txId].chainId != chainId\\n            && extendedCcExchangeRequests[_txId].isTransferredToOtherChain == false, \\n            \\\"ExchangeRouter: already processed\\\"\\n        );\\n        extendedCcExchangeRequests[_txId].isTransferredToOtherChain = true;\\n\\n        require(\\n            CcExchangeRouterLib._verifySig(\\n                _hashMsg(\\n                    abi.encodePacked(_txId, _outputAmount, _acrossRelayerFee, path)\\n                ),\\n                _r,\\n                _s,\\n                _v\\n            ) == exchangeReq.recipientAddress,\\n            \\\"ExchangeRouter: invalid signer\\\"\\n        );\\n\\n        // Exchanges teleBTC for desired exchange token\\n        (bool result, uint[] memory amounts) = IExchangeConnector(exchangeConnector[exchangeReq.appId]).swap(\\n            extendedCcExchangeRequests[_txId].remainedInputAmount,\\n            _outputAmount,\\n            path,\\n            address(this), // Sends tokens to this contract\\n            block.timestamp,\\n            true // Input token is fixed\\n        );\\n        require(result, \\\"ExchangeRouter: swap failed\\\");\\n\\n        // Sends exchanged tokens to ETH\\n        _sendTokenToOtherChain(\\n            extendedCcExchangeRequests[_txId].chainId,\\n            path[path.length - 1], \\n            amounts[amounts.length - 1], \\n            exchangeReq.recipientAddress,\\n            _acrossRelayerFee\\n        );\\n\\n        return true;\\n    }\\n\\n    /// @notice Finds hash of the message that user should have signed\\n    function _hashMsg(\\n        bytes memory _data\\n    ) internal view returns (bytes32) {\\n        return keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", \\n                keccak256(_data)\\n            )\\n        );\\n    }\\n\\n    /// @notice Sends tokens to the destination using across\\n    function _sendTokenToOtherChain(\\n        uint _chainId,\\n        address _token,\\n        uint _amount,\\n        address _user,\\n        uint _acrossRelayerFee\\n    ) private {\\n        IERC20(_token).approve(\\n            across, \\n            _amount\\n        );\\n        SpokePoolInterface(across).deposit(\\n            _user,\\n            _token,\\n            _amount,\\n            extractDestinationChainId(_chainId),\\n            int64(uint64(_acrossRelayerFee)),\\n            uint32(block.timestamp),\\n            \\\"0x\\\", // Null data\\n            115792089237316195423570985008687907853269984665640564039457584007913129639935\\n        );  \\n    }\\n\\n    /// @notice Executes the exchange request\\n    /// @dev Mints teleBTC for user if exchanging is not successful\\n    function _wrapAndSwap(\\n        address _exchangeConnector,\\n        bytes memory _lockerLockingScript, \\n        bytes32 _txId,\\n        address[] memory _path\\n    ) internal {\\n        // try swapping with path provided by teleporter\\n        (bool result, uint[] memory amounts) = _swap(\\n            chainId,\\n            _lockerLockingScript,\\n            ccExchangeRequests[_txId],\\n            extendedCcExchangeRequests[_txId],\\n            _txId,\\n            _path,\\n            _exchangeConnector\\n        );\\n\\n        if (!result) {\\n            // Sends teleBTC to recipient if exchange wasn't successful\\n            ITeleBTC(teleBTC).transfer(\\n                ccExchangeRequests[_txId].recipientAddress,\\n                extendedCcExchangeRequests[_txId].remainedInputAmount\\n            );\\n        }\\n    }\\n\\n    /// @notice                          Executes a normal cross-chain exchange request\\n    /// @dev                             Mints teleBTC for user if exchanging is not successful\\n    /// @param _lockerLockingScript      Locker's locking script    \\n    /// @param _txId                     Id of the transaction containing the user request\\n    function _wrapAndSwapToOtherChain(\\n        address _exchangeConnector,\\n        bytes memory _lockerLockingScript, \\n        bytes32 _txId,\\n        address[] memory _path,\\n        uint _acrossRelayerFee, // TODO fix in future: teleporter sets across relayer fee and use this as maximum amount of it\\n        uint _chainId\\n    ) private {\\n        (bool result, uint[] memory amounts) = _swap(\\n            _chainId,\\n            _lockerLockingScript,\\n            ccExchangeRequests[_txId],\\n            extendedCcExchangeRequests[_txId],\\n            _txId, \\n            _path,\\n            _exchangeConnector\\n        );\\n\\n        if (result) { // if swap is successfull, user will get desired tokens on destination chain\\n            extendedCcExchangeRequests[_txId].isTransferredToOtherChain = true;\\n            // Send exchanged tokens to ETH\\n            _sendTokenToOtherChain(\\n                extendedCcExchangeRequests[_txId].chainId,\\n                _path[_path.length - 1], \\n                amounts[amounts.length-1], \\n                ccExchangeRequests[_txId].recipientAddress,\\n                _acrossRelayerFee\\n            );\\n        } else { // if swap fails, someone needs to call:\\n        // withdrawFailedWrapAndSwap: to burn minted telebtc and user gets them back\\n        // or\\n        // retryFailedWrapAndSwap: to retry swap and send swapped tokens to other chain\\n        // on current chain\\n            ITeleBTC(teleBTC).approve(\\n                _exchangeConnector,\\n                extendedCcExchangeRequests[_txId].remainedInputAmount\\n            );\\n        }\\n    }\\n\\n    function _swap(\\n        uint destinationChainId,\\n        bytes memory _lockerLockingScript,\\n        ccExchangeRequest memory _ccExchangeRequest,\\n        extendedCcExchangeRequest memory _extendedCcExchangeRequest,\\n        bytes32 _txId,\\n        address[] memory _path,\\n        address _exchangeConnector\\n    ) private returns (bool result, uint[] memory amounts) {\\n        if (\\n            destinationChainId == chainId ||\\n            isTokenSupported[destinationChainId][_path[_path.length - 1]]\\n        ) {\\n            // Either the destination chain should be the current chain or \\n            // we should be able to send exchanged tokens to the destination chain\\n\\n            // Gives allowance to exchange connector for swapping\\n            ITeleBTC(teleBTC).approve(\\n                _exchangeConnector,\\n                _extendedCcExchangeRequest.remainedInputAmount\\n            );\\n            \\n            if (\\n                IExchangeConnector(_exchangeConnector).isPathValid(_path)\\n            ) {\\n                require(\\n                    _path[0] == teleBTC &&\\n                    _path[_path.length - 1] == _ccExchangeRequest.path[_ccExchangeRequest.path.length - 1],\\n                    \\\"CcExchangeRouter: invalid path\\\"\\n                );\\n                (result, amounts) = IExchangeConnector(_exchangeConnector).swap(\\n                    _extendedCcExchangeRequest.remainedInputAmount,\\n                    _ccExchangeRequest.outputAmount,\\n                    _path,\\n                    _ccExchangeRequest.recipientAddress,\\n                    block.timestamp,\\n                    true\\n                );\\n\\n                if (!result) {\\n                    (result, amounts) = IExchangeConnector(_exchangeConnector).swap(\\n                        _extendedCcExchangeRequest.remainedInputAmount,\\n                        _ccExchangeRequest.outputAmount,\\n                        _ccExchangeRequest.path,\\n                        _ccExchangeRequest.recipientAddress,\\n                        block.timestamp,\\n                        true\\n                    );\\n                }\\n            }\\n        } else {\\n            result = false;\\n        }\\n\\n        uint[5] memory fees = [\\n            _ccExchangeRequest.fee, \\n            _extendedCcExchangeRequest.lockerFee, \\n            _extendedCcExchangeRequest.protocolFee, \\n            _extendedCcExchangeRequest.thirdPartyFee, \\n            _extendedCcExchangeRequest.bridgeFee\\n        ];\\n\\n        if (result) {\\n            emit NewWrapAndSwap(\\n                ILockers(lockers).getLockerTargetAddress(_lockerLockingScript),\\n                _ccExchangeRequest.recipientAddress,\\n                [\\n                    teleBTC, \\n                    _path[_path.length - 1]\\n                ], // [input token, output token]\\n                [amounts[0], amounts[amounts.length-1]], // [input amount, output amount]\\n                _ccExchangeRequest.speed,\\n                _msgSender(), // Teleporter address\\n                _txId,\\n                _ccExchangeRequest.appId,\\n                _extendedCcExchangeRequest.thirdParty,\\n                fees\\n            );\\n        } else { // Handles situation where exchange was not successful\\n            emit FailedWrapAndSwap(\\n                ILockers(lockers).getLockerTargetAddress(_lockerLockingScript),\\n                _ccExchangeRequest.recipientAddress,\\n                [\\n                    teleBTC, \\n                    _path[_path.length - 1]\\n                ], // [input token, output token]\\n                [_extendedCcExchangeRequest.remainedInputAmount, 0], // [input amount, output amount]\\n                _ccExchangeRequest.speed,\\n                _msgSender(), // Teleporter address\\n                _txId,\\n                _ccExchangeRequest.appId,\\n                _extendedCcExchangeRequest.thirdParty,\\n                fees\\n            );\\n        }\\n    }\\n\\n    // /// @notice Checks that if request can be filled\\n    // /// @dev Request can be filled if \\n    // ///      1. Filling deadline has not been passed\\n    // ///      2. At least one filler exists\\n    // ///      3. Filled amount is greater than or equal of the requested amount\\n    // function _canFill(\\n    //     bytes32 _txId, \\n    //     address _token, \\n    //     uint256 _amount\\n    // ) private view returns (bool) {\\n    //     PrefixFillSum memory _prefixFillSum = prefixFillSums[_txId][_token];\\n\\n    //     if (\\n    //         block.timestamp <= fillsData[_txId].startingTime + fillerWithdrawInterval &&\\n    //         _prefixFillSum.currentIndex > 0 &&\\n    //         _prefixFillSum.prefixSum[_prefixFillSum.currentIndex - 1] >= _amount\\n    //     ) {\\n    //         return true;\\n    //     } else {\\n    //         return false;\\n    //     }\\n    // }\\n\\n    /// @notice Executes the exchange request with filler\\n    // function _fillCcExchange(\\n    //     bytes memory _lockerLockingScript, \\n    //     bytes32 _txId,\\n    //     ccExchangeRequest memory _request\\n    // ) private {\\n    //     address outputToken = _request.path[_request.path.length - 1];\\n\\n    //     FillData memory _txFillData;\\n    //     _txFillData.reqToken = outputToken;\\n\\n    //     PrefixFillSum memory _prefixFillSum = prefixFillSums[_txId][outputToken];\\n    //     _txFillData.lastUsedIdx = _findlastUsedIdxOfFill(_prefixFillSum, _request.outputAmount);\\n    //     _txFillData.remainingAmountOfLastFill = _prefixFillSum.prefixSum[_txFillData.lastUsedIdx] \\n    //         - _request.outputAmount;\\n\\n    //     // Saves the filling data\\n    //     fillsData[_txId] = _txFillData;\\n        \\n    //     uint _chainId = extendedCcExchangeRequests[_txId].chainId;\\n    //     if (_chainId == chainId) {\\n    //         if (outputToken == NATIVE_TOKEN) {\\n    //             Address.sendValue(\\n    //                 payable(_request.recipientAddress),\\n    //                 _request.outputAmount\\n    //             );\\n    //         } else {\\n    //             IERC20(outputToken).transfer(\\n    //                 _request.recipientAddress, \\n    //                 _request.outputAmount\\n    //             );\\n    //         }\\n    //     } else {\\n    //         _sendTokenToOtherChain(\\n    //             extendedCcExchangeRequests[_txId].chainId,\\n    //             _request.path[_request.path.length - 1], \\n    //             _request.outputAmount, \\n    //             _request.recipientAddress,\\n    //             extendedCcExchangeRequests[_txId].bridgeFee\\n    //         );\\n    //     }\\n\\n    //     emit CCExchange(\\n    //         ILockers(lockers).getLockerTargetAddress(_lockerLockingScript),\\n    //         _request.recipientAddress,\\n    //         [teleBTC, outputToken], // [input token, output token]\\n    //         [extendedCcExchangeRequests[_txId].remainedInputAmount, _request.outputAmount], // [input amount, output amount]\\n    //         _request.speed,\\n    //         _msgSender(), // Teleporter address\\n    //         _request.fee,\\n    //         _txId,\\n    //         _request.appId\\n    //     );\\n    // }\\n\\n    // function _findlastUsedIdxOfFill(\\n    //     PrefixFillSum memory _prefixFillSum, \\n    //     uint256 _amount\\n    // ) private pure returns(uint)  {\\n    //     uint[] memory sumArray = _prefixFillSum.prefixSum;\\n    //     int l = -1;\\n    //     int r = int(_prefixFillSum.currentIndex);\\n    //     while (r - l > 1) {\\n    //         int mid = (l + r) >> 1;\\n    //         if (sumArray[uint(mid)] >= _amount)\\n    //             r = mid;\\n    //         else\\n    //             l = mid;\\n    //     }\\n    //     return uint(r);\\n    // }\\n\\n    /// @notice Mints teleBTC by calling lockers contract\\n    /// @param _lockerLockingScript Locker's locking script\\n    /// @param _txId The transaction ID of the request\\n    function _mintAndReduceFees(\\n        bytes memory _lockerLockingScript,\\n        bytes32 _txId\\n    ) private {\\n\\n        // Mints teleBTC for cc exchange router\\n        uint mintedAmount = ILockers(lockers).mint(\\n            _lockerLockingScript,\\n            address(this),\\n            ccExchangeRequests[_txId].inputAmount\\n        );\\n\\n        // Calculates fees\\n        extendedCcExchangeRequests[_txId].protocolFee = ccExchangeRequests[_txId].inputAmount*protocolPercentageFee/MAX_PROTOCOL_FEE;\\n        uint networkFee = ccExchangeRequests[_txId].fee;\\n        extendedCcExchangeRequests[_txId].thirdPartyFee = ccExchangeRequests[_txId].inputAmount*thirdPartyFee[extendedCcExchangeRequests[_txId].thirdParty]/MAX_PROTOCOL_FEE;\\n        extendedCcExchangeRequests[_txId].lockerFee = ccExchangeRequests[_txId].inputAmount - mintedAmount;\\n\\n        // Pays Teleporter fee\\n        if (networkFee > 0) {\\n            ITeleBTC(teleBTC).transfer(_msgSender(), networkFee);\\n        }\\n\\n        // Pays protocol fee\\n        if (extendedCcExchangeRequests[_txId].protocolFee > 0) {\\n            ITeleBTC(teleBTC).transfer(treasury, extendedCcExchangeRequests[_txId].protocolFee);\\n        }\\n\\n        // Pays third party fee\\n        if (extendedCcExchangeRequests[_txId].thirdPartyFee > 0) {\\n            ITeleBTC(teleBTC).transfer(thirdPartyAddress[extendedCcExchangeRequests[_txId].thirdParty], extendedCcExchangeRequests[_txId].thirdPartyFee);\\n        }\\n\\n        extendedCcExchangeRequests[_txId].remainedInputAmount = \\n        mintedAmount \\n        - extendedCcExchangeRequests[_txId].protocolFee \\n        - networkFee \\n        - extendedCcExchangeRequests[_txId].thirdPartyFee;\\n    }\\n\\n    // /// @notice Internal setter for filler withdraw interval\\n    // function _setFillerWithdrawInterval(uint _fillerWithdrawInterval) private {\\n    //     emit NewFillerWithdrawInterval(fillerWithdrawInterval, _fillerWithdrawInterval);\\n    //     fillerWithdrawInterval = _fillerWithdrawInterval;\\n    // }\\n\\n    /// @notice Internal setter for relay contract address\\n    function _setRelay(address _relay) private nonZeroAddress(_relay) {\\n        emit NewRelay(relay, _relay);\\n        relay = _relay;\\n    }\\n\\n    /// @notice Internal setter for instantRouter contract address\\n    function _setInstantRouter(address _instantRouter) private nonZeroAddress(_instantRouter) {\\n        emit NewInstantRouter(instantRouter, _instantRouter);\\n        instantRouter = _instantRouter;\\n    }\\n\\n    /// @notice Internal setter for lockers contract address\\n    function _setLockers(address _lockers) private nonZeroAddress(_lockers) {\\n        emit NewLockers(lockers, _lockers);\\n        lockers = _lockers;\\n    }\\n\\n    /// @notice Internal setter for teleBTC contract address\\n    function _setTeleBTC(address _teleBTC) private nonZeroAddress(_teleBTC) {\\n        emit NewTeleBTC(teleBTC, _teleBTC);\\n        teleBTC = _teleBTC;\\n    }\\n\\n    /// @notice Internal setter for protocol percentage fee\\n    function _setProtocolPercentageFee(uint _protocolPercentageFee) private {\\n        require(\\n            MAX_PROTOCOL_FEE >= _protocolPercentageFee,\\n            \\\"CCExchangeRouter: fee is out of range\\\"\\n        );\\n        emit NewProtocolPercentageFee(protocolPercentageFee, _protocolPercentageFee);\\n        protocolPercentageFee = _protocolPercentageFee;\\n    }\\n\\n    /// @notice Internal setter for starting block number\\n    function _setStartingBlockNumber(uint _startingBlockNumber) private {\\n        require(\\n            _startingBlockNumber > startingBlockNumber,\\n            \\\"CCExchangeRouter: low startingBlockNumber\\\"\\n        );\\n        startingBlockNumber = _startingBlockNumber;\\n    }\\n\\n    /// @notice Internal setter for treasury\\n    function _setTreasury(address _treasury) private nonZeroAddress(_treasury) {\\n        emit NewTreasury(treasury, _treasury);\\n        treasury = _treasury;\\n    }\\n\\n    /// @notice Internal setter for across\\n    function _setAcross(address _across) private nonZeroAddress(_across) {\\n        emit AcrossUpdated(across, _across);\\n        across = _across;\\n    }\\n\\n    /// @notice Internal setter for burnRouter\\n    function _setBurnRouter(address _burnRouter) private nonZeroAddress(_burnRouter) {\\n        emit BurnRouterUpdated(burnRouter, _burnRouter);\\n        burnRouter = _burnRouter;\\n    }\\n\\n    /// @notice                             Internal setter for third party address\\n    /// @param _thirdPartyAddress           third party address\\n    function _setThirdPartyAddress(uint _thirdPartyId, address _thirdPartyAddress) private {\\n        emit NewThirdPartyAddress(_thirdPartyId, thirdPartyAddress[_thirdPartyId], _thirdPartyAddress);\\n        thirdPartyAddress[_thirdPartyId] = _thirdPartyAddress;\\n    }\\n\\n    /// @notice                             Internal setter for third party fee\\n    /// @param _thirdPartyFee               third party fee\\n    function _setThirdPartyFee(uint _thirdPartyId, uint _thirdPartyFee) private {\\n        emit NewThirdPartyFee(_thirdPartyId, thirdPartyFee[_thirdPartyId], _thirdPartyFee);\\n        thirdPartyFee[_thirdPartyId] = _thirdPartyFee;\\n    }\\n\\n    /// @notice                             Internal setter for chain id mapping\\n    function _setChainIdMapping(uint _middleChain, uint _destinationChain, uint _mappedId) private {\\n        emit NewChainIdMapping(_mappedId, _middleChain, _destinationChain);\\n        chainIdMapping[_mappedId] = chainIdStruct(\\n            _middleChain, \\n            _destinationChain\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0xc13743c968b238e9cee5b8c474031cae0a14fd4be8437ad9e4bbe53e37be9e7e\",\"license\":\"MIT\"},\"contracts/routers/CcExchangeRouterStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.8.4;\\n\\nimport \\\"./interfaces/ICcExchangeRouter.sol\\\";\\n\\nabstract contract CcExchangeRouterStorage is ICcExchangeRouter {\\n\\n    // Constants\\n    uint constant MAX_PROTOCOL_FEE = 10000;\\n\\n    // Public variables\\n    uint public override startingBlockNumber;\\n    uint public override chainId;\\n    uint public override protocolPercentageFee; // A number between 0 to 10000\\n    address public override relay;\\n    address public override instantRouter;\\n    address public override lockers;\\n    address public override teleBTC;\\n    address public override treasury;\\n    mapping(uint => address) public override exchangeConnector; \\n    // ^ Mapping from app id to exchange connector address \\n\\n    // Private variables\\n    mapping(bytes32 => ccExchangeRequest) internal ccExchangeRequests;\\n}\\n\",\"keccak256\":\"0x0323cafa50cd8ce2d5dce759d0896aa3b1f19698e38e8feeb826ea863090921f\",\"license\":\"MIT\"},\"contracts/routers/CcExchangeRouterStorageV2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.8.4;\\n\\nimport \\\"./interfaces/ICcExchangeRouter.sol\\\";\\n\\nabstract contract CcExchangeRouterStorageV2 is ICcExchangeRouter {\\n    // New variables (filler)\\n\\n    address constant NATIVE_TOKEN = address(1);\\n\\n    // note: should be set after deplyment\\n    uint public fillerWithdrawInterval;\\n\\n    mapping(bytes32 => mapping(address => FillerData)) public fillersData;\\n    // ^ [txId][filler] to FillerData\\n    mapping(bytes32 => mapping(address => PrefixFillSum)) public prefixFillSums;\\n    // ^ [txId][token] to PrefixFillSum\\n    mapping(bytes32 => FillData) public fillsData;\\n\\n    // New variables (Ethereum support)\\n    \\n    mapping (uint => mapping (address => bool)) public override isTokenSupported; \\n    // ^ Mapping to store supported exchange tokens\\n    mapping(uint => bool) public override isChainSupported; \\n    // ^ Mapping to store supported chainIds\\n    mapping(bytes32 => extendedCcExchangeRequest) public extendedCcExchangeRequests;\\n     \\n    address public override across;\\n    address public wrappedNativeToken;\\n    address public override burnRouter;\\n\\n    // New variables (path support)\\n    address public wmatic;\\n\\n    mapping(uint => chainIdStruct) public chainIdMapping;\\n\\n    // third party\\n    mapping(uint => uint) public thirdPartyFee;\\n    mapping(uint => address) public thirdPartyAddress;\\n}\\n\",\"keccak256\":\"0x27511848c4d3782bf28777c9c88961d92fbe7dfb945664890f920d6cbdfd69ab\",\"license\":\"MIT\"},\"contracts/routers/interfaces/IBurnRouter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.8.4;\\n\\nimport \\\"@teleportdao/btc-evm-bridge/contracts/types/ScriptTypesEnum.sol\\\";\\n\\ninterface IBurnRouter {\\n\\n\\t// Structures\\n\\n    /// @notice Structure for recording cc burn requests\\n    /// @param amount of tokens that user wants to burn\\n    /// @param burntAmount that user will receive (after reducing fees from amount)\\n    /// @param sender Address of user who requests burning\\n    /// @param userScript Script hash of the user on Bitcoin\\n    /// @param deadline of locker for executing the request\\n    /// @param isTransferred True if the request has been processed\\n    /// @param scriptType The script type of the user\\n    /// @param requestIdOfLocker The index of the request for a specific locker\\n\\tstruct burnRequest {\\n\\t\\tuint amount;\\n\\t\\tuint burntAmount;\\n\\t\\taddress sender;\\n\\t\\tbytes userScript;\\n\\t\\tuint deadline;\\n\\t\\tbool isTransferred;\\n\\t\\tScriptTypes scriptType;\\n\\t\\tuint requestIdOfLocker;\\n  \\t}\\n\\n  \\t// Events\\n\\n\\t/// @notice Emits when a burn request gets submitted\\n    /// @param userScript Script of user on Bitcoin\\n    /// @param scriptType Script type of the user (for bitcoin address)\\n\\t/// @param lockerTargetAddress Address of Locker\\n\\t/// @param userTargetAddress Address of the user on EVM\\n\\t/// @param requestIdOfLocker Index of request between Locker's burn requests\\n\\t/// @param deadline of Locker for executing the request (in terms of Bitcoin blocks)\\n\\t/// @param thirdPartyId Id of third party\\n\\t/// @param inputAndOutputToken [inputToken, outputToken]\\n\\t/// @param amounts [inputAmount, teleBTCAmount, burntAmount]\\n\\t/// @param fees [network fee, locker fee, protocol fee, third party fee]\\n\\t\\n  \\tevent NewUnwrap(\\n\\t\\tbytes userScript,\\n\\t\\tScriptTypes scriptType,\\n\\t\\taddress lockerTargetAddress,\\n\\t\\taddress indexed userTargetAddress,\\n\\t\\tuint requestIdOfLocker,\\n\\t\\tuint indexed deadline,\\n\\t\\tuint thirdPartyId,\\n\\t\\taddress[2] inputAndOutputToken,\\n\\t\\tuint[3] amounts,\\n\\t\\tuint[4] fees\\n\\t);\\n\\n\\t/// @notice Emits when a burn proof is provided\\n    /// @param lockerTargetAddress Address of Locker\\n    /// @param requestIdOfLocker Index of paid request of among Locker's requests\\n    /// @param bitcoinTxId The hash of tx that paid a burn request\\n\\t/// @param bitcoinTxOutputIndex The output index in tx\\n\\tevent PaidUnwrap(\\n\\t\\taddress indexed lockerTargetAddress,\\n\\t\\tuint requestIdOfLocker,\\n\\t\\tbytes32 bitcoinTxId,\\n\\t\\tuint bitcoinTxOutputIndex\\n\\t);\\n\\n\\t/// @notice  Emits when a locker gets slashed for withdrawing BTC without proper reason\\n\\t/// @param _lockerTargetAddress\\tLocker's address on the target chain\\n\\t/// @param _blockNumber\\tBlock number of the malicious tx\\n\\t/// @param txId\\tTransaction ID of the malicious tx\\n\\t/// @param amount Slashed amount\\n\\tevent LockerDispute(\\n        address _lockerTargetAddress,\\n\\t\\tbytes lockerLockingScript,\\n    \\tuint _blockNumber,\\n        bytes32 txId,\\n\\t\\tuint amount\\n    );\\n\\n\\tevent BurnDispute(\\n\\t\\taddress indexed userTargetAddress,\\n\\t\\taddress indexed _lockerTargetAddress,\\n\\t\\tbytes lockerLockingScript,\\n\\t\\tuint requestIdOfLocker\\n\\t);\\n\\n\\t/// @notice Emits when relay address is updated\\n    event NewRelay(\\n        address oldRelay, \\n        address newRelay\\n    );\\n\\n\\t/// @notice Emits when treasury address is updated\\n    event NewTreasury(\\n        address oldTreasury, \\n        address newTreasury\\n    );\\n\\n\\t/// @notice Emits when lockers address is updated\\n    event NewLockers(\\n        address oldLockers, \\n        address newLockers\\n    );\\n\\n\\t/// @notice Emits when TeleBTC address is updated\\n    event NewTeleBTC(\\n        address oldTeleBTC, \\n        address newTeleBTC\\n    );\\n\\n\\t/// @notice Emits when transfer deadline is updated\\n    event NewTransferDeadline(\\n        uint oldTransferDeadline, \\n        uint newTransferDeadline\\n    );\\n\\n\\t/// @notice Emits when percentage fee is updated\\n    event NewProtocolPercentageFee(\\n        uint oldProtocolPercentageFee, \\n        uint newProtocolPercentageFee\\n    );\\n\\n\\t/// @notice Emits when slasher percentage fee is updated\\n    event NewSlasherPercentageFee(\\n        uint oldSlasherPercentageFee, \\n        uint newSlasherPercentageFee\\n    );\\n\\n\\t/// @notice Emits when network fee is updated\\n    event NewNetworkFee(\\n        uint oldNetworkFee, \\n        uint newNetworkFee\\n    );\\n\\n\\t/// @notice Emits when network fee oracle is updated\\n    event NewNetworkFeeOracle(\\n        address oldNetworkFeeOracle, \\n        address newNetworkFeeOracle\\n    );\\n\\n\\t/// @notice                     Emits when changes made to third party address\\n\\tevent NewThirdPartyAddress(\\n\\t\\tuint thirdPartyId,\\n\\t\\taddress oldThirdPartyAddress, \\n\\t\\taddress newThirdPartyAddress\\n\\t);\\n\\n\\t/// @notice                     Emits when changes made to third party fee\\n\\tevent NewThirdPartyFee(\\n\\t\\tuint thirdPartyId,\\n\\t\\tuint oldThirdPartyFee, \\n\\t\\tuint newThirdPartyFee\\n\\t);\\n\\n\\n\\t// Read-only functions\\n\\n\\tfunction isTransferred(address _lockerTargetAddress, uint _index) external view returns (bool);\\n\\n    function startingBlockNumber() external view returns (uint);\\n\\t\\n\\tfunction relay() external view returns (address);\\n\\n\\tfunction lockers() external view returns (address);\\n\\n\\tfunction teleBTC() external view returns (address);\\n\\n\\tfunction treasury() external view returns (address);\\n\\n\\tfunction transferDeadline() external view returns (uint);\\n\\n\\tfunction protocolPercentageFee() external view returns (uint);\\n\\n\\tfunction slasherPercentageReward() external view returns (uint);\\n\\n\\tfunction bitcoinFee() external view returns (uint); // Bitcoin transaction fee\\n\\n\\tfunction isUsedAsBurnProof(bytes32 _txId) external view returns (bool);\\n\\n\\tfunction bitcoinFeeOracle() external view returns (address);\\n\\n\\t// State-changing functions\\n\\n\\tfunction setStartingBlockNumber(uint _startingBlockNumber) external;\\n\\n\\tfunction setRelay(address _relay) external;\\n\\n\\tfunction setLockers(address _lockers) external;\\n\\n\\tfunction setTeleBTC(address _teleBTC) external;\\n\\n\\tfunction setTreasury(address _treasury) external;\\n\\n\\tfunction setTransferDeadline(uint _transferDeadline) external;\\n\\n\\tfunction setProtocolPercentageFee(uint _protocolPercentageFee) external;\\n\\n\\tfunction setSlasherPercentageReward(uint _slasherPercentageReward) external;\\n\\n\\tfunction setNetworkFee(uint _networkFee) external;\\n\\n\\tfunction setNetworkFeeOracle(address _networkFeeOracle) external;\\n\\n\\tfunction setThirdPartyAddress(uint _thirdPartyId, address _thirdPartyAddress) external;\\n\\n\\tfunction setThirdPartyFee(uint _thirdPartyId, uint _thirdPartyFee) external;\\n\\n\\tfunction unwrap(\\n\\t\\tuint _amount, \\n\\t\\tbytes calldata _userScript,\\n\\t\\tScriptTypes _scriptType,\\n\\t\\tbytes calldata _lockerLockingScript,\\n\\t\\tuint thirdParty\\n\\t) external returns (uint);\\n\\n    function swapAndUnwrap(\\n        address _exchangeConnector,\\n        uint[] calldata _amounts,\\n        bool _isFixedToken,\\n        address[] calldata _path,\\n        uint256 _deadline, \\n        bytes memory _userScript,\\n        ScriptTypes _scriptType,\\n        bytes calldata _lockerLockingScript,\\n\\t\\tuint thirdParty\\n\\t) external returns (uint);\\n\\n\\tfunction burnProof(\\n\\t\\tbytes4 _version,\\n\\t\\tbytes memory _vin,\\n\\t\\tbytes memory _vout,\\n\\t\\tbytes4 _locktime,\\n\\t\\tuint256 _blockNumber,\\n\\t\\tbytes memory _intermediateNodes,\\n\\t\\tuint _index,\\n\\t\\tbytes memory _lockerLockingScript,\\n        uint[] memory _burnReqIndexes,\\n        uint[] memory _voutIndexes\\n\\t) external payable returns (bool);\\n\\n\\tfunction disputeBurn(\\n\\t\\tbytes calldata _lockerLockingScript,\\n\\t\\tuint[] memory _indices\\n\\t) external;\\n\\n    function disputeLocker(\\n        bytes memory _lockerLockingScript,\\n        bytes4[] memory _versions, // [inputTxVersion, outputTxVersion]\\n        bytes memory _inputVin,\\n        bytes memory _inputVout,\\n        bytes memory _outputVin,\\n        bytes memory _outputVout,\\n        bytes4[] memory _locktimes, // [inputTxLocktime, outputTxLocktime]\\n        bytes memory _inputIntermediateNodes,\\n        uint[] memory _indexesAndBlockNumbers \\n\\t\\t// ^ [inputIndex, inputTxIndex, outputTxIndex, inputTxBlockNumber, outputTxBlockNumber]\\n    ) external payable;\\n}\",\"keccak256\":\"0x538e3a6a99da7ea020eb91609677ac1c987a80e5b64559d968b4559a542f0fbc\",\"license\":\"MIT\"},\"contracts/routers/interfaces/ICcExchangeRouter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.8.4;\\n\\ninterface ICcExchangeRouter {\\n\\n    // Structures\\n\\n    struct chainIdStruct {\\n        uint middleChain;\\n        uint destinationChain;\\n    }\\n\\n    /// @notice Structure for recording cross-chain exchange requests\\n    /// @param appId that user wants to use (which DEX)\\n    /// @param inputAmount Amount of locked BTC on source chain\\n    /// @param outputAmount Amount of output token\\n    /// @param isFixedToken True if amount of input token is fixed\\n    /// @param recipientAddress Address of exchange recipient\\n    /// @param fee Amount of fee that is paid to Teleporter (for tx, relayer and teleporter fees)\\n    /// @param isUsed True if tx has been submitted before\\n    /// @param path Exchange path from input token to output token\\n    /// @param deadline for exchanging tokens (not used anymore)\\n    /// @param speed of the request (normal or instant)\\n    struct ccExchangeRequest {\\n        uint appId;\\n        uint inputAmount;\\n        uint outputAmount;\\n        bool isFixedToken;\\n        address recipientAddress;\\n        uint fee;\\n        bool isUsed;\\n        address[] path;\\n        uint deadline;\\n        uint speed;\\n    }\\n\\n    /// @notice Structure for recording cross-chain exchange requests\\n    /// @param isTransferredToOtherChain True if BTC to ETH exchange is processed successfully\\n    /// @param remainedInputAmount Amount of obtained TELEBTC on target chain\\n    /// @param bridgeFee percentage of fee we have to give to across relayers to fill our request\\n    struct extendedCcExchangeRequest {\\n        uint chainId;\\n        bool isTransferredToOtherChain;\\n        uint remainedInputAmount;\\n        uint bridgeFee;\\n        uint thirdParty;\\n        uint protocolFee;\\n        uint thirdPartyFee;\\n        uint lockerFee;\\n    }\\n    \\n    /// @notice Structure for passing tx and its inclusion proof\\n    /// @param version of the transaction containing the user request\\n    /// @param vin Inputs of the transaction containing the user request\\n    /// @param vout Outputs of the transaction containing the user request\\n    /// @param locktime of the transaction containing the user request\\n    /// @param blockNumber Height of the block containing the user request\\n    /// @param intermediateNodes Merkle inclusion proof for transaction containing the user request\\n    /// @param index of transaction containing the user request in the block\\n    struct TxAndProof {\\n        bytes4 version;\\n        bytes vin;\\n        bytes vout;\\n        bytes4 locktime;\\n        uint256 blockNumber;\\n        bytes intermediateNodes;\\n        uint index;\\n    }\\n\\n    /// @notice Structure for storing filling requests\\n    /// @param startingTime First attemp to fill the request\\n    /// @param reqToken Requested exchange token\\n    /// @param lastUsedIdx Last used filler index\\n    /// @param remainingAmountOfLastFill Amount of unused tokens of last filler\\n    /// @param isWithdrawnLastFill True if last used filler has withdrawn unused tokens\\n    struct FillData {\\n        uint startingTime;\\n        address reqToken;\\n        uint lastUsedIdx;\\n        uint remainingAmountOfLastFill;\\n        bool isWithdrawnLastFill;\\n    }\\n\\n    /// @notice Structure for storing fillers of a request\\n    /// @param index of filler between fillers\\n    /// @param token that filler used to fill\\n    /// @param amount that filler sent to fill\\n    struct FillerData {\\n        uint index;\\n        address token;\\n        uint amount;\\n    }\\n\\n    /// @notice Structure for storing fillings\\n    /// @param prefixSum Cumulative sum of fillings\\n    /// @param currentIndex Next filler index\\n    struct PrefixFillSum {\\n        uint[] prefixSum;\\n        uint currentIndex;\\n    }\\n    // Events\\n\\n    event TokenAdded(\\n        uint chainId,\\n        address newToken\\n    );\\n\\n    event TokenRemoved(\\n        uint chainId,\\n        address oldToken\\n    );\\n\\n    event ChainAdded(\\n        uint newChain\\n    );\\n\\n    event ChainRemoved(\\n        uint oldChain\\n    );\\n\\n    event AcrossUpdated(\\n        address oldAcross,\\n        address newAcross\\n    );\\n\\n    event BurnRouterUpdated(\\n        address oldBurnRouter,\\n        address newBurnRouter\\n    );\\n\\n\\tevent NewFillerWithdrawInterval(\\n        uint oldFillerWithdrawInterval, \\n        uint newFillerWithdrawInterval\\n    );\\n\\n    /// @notice Emits when a new filler fills a request\\n    /// @param filler Address of filler\\n    /// @param txId Bitcoin request id\\n    /// @param token that used for filling\\n    /// @param amount that sent for filling\\n    event NewFill(\\n        address filler,\\n        bytes32 txId, \\n        address token,\\n        uint amount\\n    );\\n\\n    /// @notice Emits when a request is filled for the first time\\n    /// @param txId Bitcoin request id\\n    /// @param time Filling starting time \\n    event FillStarted(\\n        bytes32 txId,\\n        uint time\\n    );\\n\\n    /// @notice Emits when unused tokens withdrawn\\n    /// @param amount of unused tokens\\n    /// @param token that filler sent\\n    /// @param filler Address of filler\\n    /// @param fillIdx Index of filling\\n    /// @param txId that filler filled\\n    event FillTokensReturned(\\n        uint amount,\\n        address token,\\n        address filler,\\n        uint fillIdx,\\n        bytes32 txId\\n    );\\n\\n    /// @notice Emits when filler withdraws teleBTC\\n    /// @param amount Total sent tokens\\n    /// @param remainingAmount Amount of unused token\\n    /// @param token that filler sent\\n    /// @param filler Address of filler\\n    /// @param fillIdx Index of filling\\n    /// @param txId that filler filled\\n    /// @param reqMintedTeleBtc Total teleBTC minted by txId\\n    /// @param sentTeleBtc Share of this filler from total minted teleBTC\\n    event FillTeleBtcSent(\\n        uint amount,\\n        uint remainingAmount,\\n        address token,\\n        address filler,\\n        uint fillIdx,\\n        bytes32 txId,\\n        uint reqMintedTeleBtc,\\n        uint sentTeleBtc\\n    );\\n\\n    /// @notice Emits when a cc exchange request gets done\\n    /// @param lockerTargetAddress Address of Locker\\n    /// @param user Exchange recipient address\\n    /// @param inputAndOutputToken [inputToken, outputToken]\\n    /// @param inputAndOutputAmount [inputAmount, outputAmount]\\n    /// @param speed Speed of the request (normal or instant)\\n    /// @param teleporter Address of teleporter who submitted the request\\n    /// @param bitcoinTxId The transaction ID of request on Bitcoin \\n    /// @param appId Assigned application id to exchange\\n    /// @param thirdPartyId Id of third party\\n    /// @param fees [network fee, locker fee, protocol fee, third party fee, bridge fee]\\n    event NewWrapAndSwap(\\n        address lockerTargetAddress,\\n        address indexed user,\\n        address[2] inputAndOutputToken,\\n        uint[2] inputAndOutputAmount,\\n        uint indexed speed,\\n        address indexed teleporter,\\n        bytes32 bitcoinTxId,\\n        uint appId,\\n        uint thirdPartyId,\\n        uint[5] fees\\n    );\\n\\n    /// @notice Emits when a cc exchange request fails\\n    /// @dev We mint teleBTC and send it to the user\\n    /// @param lockerTargetAddress Address of Locker\\n    /// @param recipientAddress Exchange recipient address\\n    /// @param inputAndOutputToken [inputToken, outputToken]\\n    /// @param inputAndOutputAmount [inputAmount, outputAmount]\\n    /// @param speed Speed of the request (normal or instant)\\n    /// @param teleporter Address of teleporter who submitted the request\\n    /// @param bitcoinTxId The transaction ID of request on Bitcoin \\n    /// @param appId Assigned application id to exchange\\n    /// @param thirdPartyId Id of third party\\n    /// @param fees [network fee, locker fee, protocol fee, third party fee, bridge fee]    \\n    event FailedWrapAndSwap(\\n        address lockerTargetAddress,\\n        address indexed recipientAddress,\\n        address[2] inputAndOutputToken,\\n        uint[2] inputAndOutputAmount,\\n        uint indexed speed,\\n        address indexed teleporter,\\n        bytes32 bitcoinTxId,\\n        uint appId,\\n        uint thirdPartyId,\\n        uint[5] fees\\n    );\\n\\n    /// @notice Emits when appId for an exchange connector is set\\n    /// @param appId Assigned application id to exchange\\n    /// @param exchangeConnector Address of exchange connector contract\\n    event SetExchangeConnector(\\n        uint appId,\\n        address exchangeConnector\\n    );\\n\\n    /// @notice Emits when relay contract updated\\n    event NewRelay(\\n        address oldRelay, \\n        address newRelay\\n    );\\n\\n    /// @notice Emits when instant router contract updated\\n    event NewInstantRouter(\\n        address oldInstantRouter, \\n        address newInstantRouter\\n    );\\n\\n    /// @notice Emits when lockers contract updated\\n    event NewLockers(\\n        address oldLockers, \\n        address newLockers\\n    );\\n\\n    /// @notice Emits when telebtc contract updated\\n    event NewTeleBTC(\\n        address oldTeleBTC, \\n        address newTeleBTC\\n    );\\n\\n    /// @notice Emits when protocol fee updated\\n    event NewProtocolPercentageFee(\\n        uint oldProtocolPercentageFee, \\n        uint newProtocolPercentageFee\\n    );\\n\\n    /// @notice Emits when treasury address updated\\n    event NewTreasury(\\n        address oldTreasury, \\n        address newTreasury\\n    );\\n\\n    /// @notice                     Emits when changes made to third party address\\n\\tevent NewThirdPartyAddress(\\n\\t\\tuint thirdPartyId,\\n\\t\\taddress oldThirdPartyAddress, \\n\\t\\taddress newThirdPartyAddress\\n\\t);\\n\\n\\t/// @notice                     Emits when changes made to third party fee\\n\\tevent NewThirdPartyFee(\\n\\t\\tuint thirdPartyId,\\n\\t\\tuint oldThirdPartyFee, \\n\\t\\tuint newThirdPartyFee\\n\\t);\\n\\n    /// @notice                     Emits when changes made to chain id mapping\\n    event NewChainIdMapping(\\n        uint mappedId,\\n        uint middleChain,\\n        uint destinationChain\\n    );\\n\\n\\n    // Read-only functions\\n    \\n    function isRequestUsed(bytes32 _txId) external view returns (bool);\\n\\n    // Read-only functions\\n    \\n    function startingBlockNumber() external view returns (uint);\\n\\n    function protocolPercentageFee() external view returns (uint);\\n    \\n    function chainId() external view returns (uint);\\n\\n    function relay() external view returns (address);\\n\\n    function instantRouter() external view returns (address);\\n\\n    function lockers() external view returns (address);\\n\\n    function teleBTC() external view returns (address);\\n\\n    function exchangeConnector(uint _appId) external view returns (address);\\n\\n    function treasury() external view returns (address);\\n\\n    function isTokenSupported(uint chainId, address _exchangeToken) external view returns (bool);\\n\\n    function isChainSupported(uint _chainId) external view returns (bool);\\n\\n    function across() external view returns (address);\\n\\n    function burnRouter() external view returns (address);\\n\\n    // State-changing functions\\n\\n    function setStartingBlockNumber(uint _startingBlockNumber) external;\\n\\n    function setRelay(address _relay) external;\\n\\n    function setInstantRouter(address _instantRouter) external;\\n\\n    function setLockers(address _lockers) external;\\n\\n    function setTeleBTC(address _teleBTC) external;\\n\\n    function setExchangeConnector(uint _appId, address _exchangeConnector) external;\\n\\n\\tfunction setTreasury(address _treasury) external;\\n\\n\\tfunction setProtocolPercentageFee(uint _protocolPercentageFee) external;\\n\\n    // function setFillerWithdrawInterval(uint _fillerWithdrawInterval) external;\\n\\n    function setAcross(address _across) external;\\n\\n    function setBurnRouter(address _burnRouter) external;\\n\\n    function setThirdPartyAddress(uint _thirdPartyId, address _thirdPartyAddress) external;\\n\\n\\tfunction setThirdPartyFee(uint _thirdPartyId, uint _thirdPartyFee) external;\\n\\n    function setChainIdMapping(uint _mappedId, uint _middleChain, uint _destinationChain) external;\\n    \\n    function wrapAndSwap(\\n        TxAndProof memory _txAndProof,\\n        bytes calldata _lockerLockingScript,\\n        address[] memory _path\\n    ) external payable returns(bool);\\n\\n    // function fillTx(\\n    //     bytes32 _txId,\\n    //     address _recipient,\\n    //     address _token,\\n    //     uint _amount,\\n    //     uint _requestAmount\\n    // ) external payable;\\n\\n    // function getTeleBtcForFill(\\n    //    bytes32 _txId\\n    // ) external returns (bool);\\n\\n    function supportToken(uint chainId, address _token) external;\\n\\n    function removeToken(uint chainId, address _token) external;\\n\\n    function supportChain(uint _chainId) external;\\n\\n    function removeChain(uint _chainId) external;\\n\\n    function withdrawFailedWrapAndSwap(\\n        bytes32 _txId,\\n        uint8 _scriptType,\\n        bytes memory _userScript,\\n        uint _acrossRelayerFee,\\n        bytes32 _r,\\n        bytes32 _s,\\n        uint8 _v,\\n        bytes calldata _lockerLockingScript\\n    ) external returns (bool);\\n\\n    function retryFailedWrapAndSwap(\\n        bytes32 _txId,\\n        uint256 _outputAmount,\\n        uint _acrossRelayerFee,\\n        address[] memory path,\\n        bytes32 _r,\\n        bytes32 _s,\\n        uint8 _v\\n    ) external returns (bool);\\n}\",\"keccak256\":\"0xbfecc531f7469bd43c3a2a7e9340c731c4c29f71874267b67dc61b5af4a071aa\",\"license\":\"MIT\"},\"contracts/types/DataTypes.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.8.4;\\n\\nimport \\\"@teleportdao/btc-evm-bridge/contracts/types/ScriptTypesEnum.sol\\\";\\n\\nlibrary DataTypes {\\n\\n    /// @notice                             Structure for registering lockers\\n    /// @dev\\n    /// @param lockerLockingScript          Locker redeem script\\n    /// @param lockerRescueType             Locker script type in case of getting BTCs back\\n    /// @param lockerRescueScript           Locker script in case of getting BTCs back\\n    /// @param TDTLockedAmount              Bond amount of locker in TDT\\n    /// @param nativeTokenLockedAmount      Bond amount of locker in native token of the target chain\\n    /// @param netMinted                    Total minted - total burnt\\n    /// @param slashingTeleBTCAmount        Total amount of teleBTC a locker must be slashed\\n    /// @param reservedNativeTokenForSlash  Total native token reserved to support slashing teleBTC\\n    /// @param isLocker                     Indicates that is already a locker or not\\n    /// @param isCandidate                  Indicates that is a candidate or not\\n    /// @param isScriptHash                 Shows if it's script hash\\n    ///                                     has enough collateral to accept more minting requests)\\n    struct locker {\\n        bytes lockerLockingScript;\\n        ScriptTypes lockerRescueType;\\n        bytes lockerRescueScript;\\n        uint TDTLockedAmount;\\n        uint nativeTokenLockedAmount;\\n        uint netMinted;\\n        uint slashingTeleBTCAmount;\\n        uint reservedNativeTokenForSlash;\\n        bool isLocker;\\n        bool isCandidate;\\n        bool isScriptHash;\\n    }\\n\\n    struct lockersLibConstants {\\n        uint OneHundredPercent;\\n        uint HealthFactor;\\n        uint UpperHealthFactor;\\n        uint MaxLockerFee;\\n        uint NativeTokenDecimal;\\n        address NativeToken;\\n    }\\n\\n    struct lockersLibParam {\\n        address teleportDAOToken;\\n        address teleBTC;\\n        address ccBurnRouter;\\n        address exchangeConnector;\\n        address priceOracle;\\n\\n        uint minRequiredTDTLockedAmount;\\n        uint minRequiredTNTLockedAmount;\\n        uint lockerPercentageFee;\\n        uint collateralRatio;\\n        uint liquidationRatio;\\n        uint priceWithDiscountRatio;\\n        uint inactivationDelay;\\n    }\\n}\",\"keccak256\":\"0x1ec4ade2e24c702a150df51981d176b1d7ddd7faf21e971fefdef09674cfdf3d\",\"license\":\"MIT\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0x60b0215121bf25612a6739fb2f1ec35f31ee82e4a8216c032c8243d904ab3aa9\",\"license\":\"MIT\"},\"solidity-bytes-utils/contracts/BytesLib.sol\":{\"content\":\"// SPDX-License-Identifier: Unlicense\\n/*\\n * @title Solidity Bytes Arrays Utils\\n * @author Gon\\u00e7alo S\\u00e1 <goncalo.sa@consensys.net>\\n *\\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\\n */\\npragma solidity >=0.8.0 <0.9.0;\\n\\n\\nlibrary BytesLib {\\n    function concat(\\n        bytes memory _preBytes,\\n        bytes memory _postBytes\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            // Get a location of some free memory and store it in tempBytes as\\n            // Solidity does for memory variables.\\n            tempBytes := mload(0x40)\\n\\n            // Store the length of the first bytes array at the beginning of\\n            // the memory for tempBytes.\\n            let length := mload(_preBytes)\\n            mstore(tempBytes, length)\\n\\n            // Maintain a memory counter for the current write location in the\\n            // temp bytes array by adding the 32 bytes for the array length to\\n            // the starting location.\\n            let mc := add(tempBytes, 0x20)\\n            // Stop copying when the memory counter reaches the length of the\\n            // first bytes array.\\n            let end := add(mc, length)\\n\\n            for {\\n                // Initialize a copy counter to the start of the _preBytes data,\\n                // 32 bytes into its memory.\\n                let cc := add(_preBytes, 0x20)\\n            } lt(mc, end) {\\n                // Increase both counters by 32 bytes each iteration.\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                // Write the _preBytes data into the tempBytes memory 32 bytes\\n                // at a time.\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Add the length of _postBytes to the current length of tempBytes\\n            // and store it as the new length in the first 32 bytes of the\\n            // tempBytes memory.\\n            length := mload(_postBytes)\\n            mstore(tempBytes, add(length, mload(tempBytes)))\\n\\n            // Move the memory counter back from a multiple of 0x20 to the\\n            // actual end of the _preBytes data.\\n            mc := end\\n            // Stop copying when the memory counter reaches the new combined\\n            // length of the arrays.\\n            end := add(mc, length)\\n\\n            for {\\n                let cc := add(_postBytes, 0x20)\\n            } lt(mc, end) {\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Update the free-memory pointer by padding our last write location\\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\\n            // next 32 byte block, then round down to the nearest multiple of\\n            // 32. If the sum of the length of the two arrays is zero then add\\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\\n            mstore(0x40, and(\\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\\n              not(31) // Round down to the nearest 32 bytes.\\n            ))\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\\n        assembly {\\n            // Read the first 32 bytes of _preBytes storage, which is the length\\n            // of the array. (We don't need to use the offset into the slot\\n            // because arrays use the entire slot.)\\n            let fslot := sload(_preBytes.slot)\\n            // Arrays of 31 bytes or less have an even value in their slot,\\n            // while longer arrays have an odd value. The actual length is\\n            // the slot divided by two for odd values, and the lowest order\\n            // byte divided by two for even values.\\n            // If the slot is even, bitwise and the slot with 255 and divide by\\n            // two to get the length. If the slot is odd, bitwise and the slot\\n            // with -1 and divide by two.\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n            let newlength := add(slength, mlength)\\n            // slength can contain both the length and contents of the array\\n            // if length < 32 bytes so let's prepare for that\\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n            switch add(lt(slength, 32), lt(newlength, 32))\\n            case 2 {\\n                // Since the new array still fits in the slot, we just need to\\n                // update the contents of the slot.\\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\\n                sstore(\\n                    _preBytes.slot,\\n                    // all the modifications to the slot are inside this\\n                    // next block\\n                    add(\\n                        // we can just add to the slot contents because the\\n                        // bytes we want to change are the LSBs\\n                        fslot,\\n                        add(\\n                            mul(\\n                                div(\\n                                    // load the bytes from memory\\n                                    mload(add(_postBytes, 0x20)),\\n                                    // zero all bytes to the right\\n                                    exp(0x100, sub(32, mlength))\\n                                ),\\n                                // and now shift left the number of bytes to\\n                                // leave space for the length in the slot\\n                                exp(0x100, sub(32, newlength))\\n                            ),\\n                            // increase length by the double of the memory\\n                            // bytes length\\n                            mul(mlength, 2)\\n                        )\\n                    )\\n                )\\n            }\\n            case 1 {\\n                // The stored value fits in the slot, but the combined value\\n                // will exceed it.\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // The contents of the _postBytes array start 32 bytes into\\n                // the structure. Our first read should obtain the `submod`\\n                // bytes that can fit into the unused space in the last word\\n                // of the stored array. To get this, we read 32 bytes starting\\n                // from `submod`, so the data we read overlaps with the array\\n                // contents by `submod` bytes. Masking the lowest-order\\n                // `submod` bytes allows us to add that value directly to the\\n                // stored value.\\n\\n                let submod := sub(32, slength)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(\\n                    sc,\\n                    add(\\n                        and(\\n                            fslot,\\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\\n                        ),\\n                        and(mload(mc), mask)\\n                    )\\n                )\\n\\n                for {\\n                    mc := add(mc, 0x20)\\n                    sc := add(sc, 1)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n            default {\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                // Start copying to the last used word of the stored array.\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // Copy over the first `submod` bytes of the new data as in\\n                // case 1 above.\\n                let slengthmod := mod(slength, 32)\\n                let mlengthmod := mod(mlength, 32)\\n                let submod := sub(32, slengthmod)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\\n\\n                for {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n        }\\n    }\\n\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n        require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\\n        require(_bytes.length >= _start + 20, \\\"toAddress_outOfBounds\\\");\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\\n        require(_bytes.length >= _start + 1 , \\\"toUint8_outOfBounds\\\");\\n        uint8 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x1), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\\n        require(_bytes.length >= _start + 2, \\\"toUint16_outOfBounds\\\");\\n        uint16 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x2), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\\n        require(_bytes.length >= _start + 4, \\\"toUint32_outOfBounds\\\");\\n        uint32 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x4), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\\n        require(_bytes.length >= _start + 8, \\\"toUint64_outOfBounds\\\");\\n        uint64 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x8), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\\n        require(_bytes.length >= _start + 12, \\\"toUint96_outOfBounds\\\");\\n        uint96 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0xc), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\\n        require(_bytes.length >= _start + 16, \\\"toUint128_outOfBounds\\\");\\n        uint128 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x10), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\\n        require(_bytes.length >= _start + 32, \\\"toUint256_outOfBounds\\\");\\n        uint256 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\\n        require(_bytes.length >= _start + 32, \\\"toBytes32_outOfBounds\\\");\\n        bytes32 tempBytes32;\\n\\n        assembly {\\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempBytes32;\\n    }\\n\\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\\n        bool success = true;\\n\\n        assembly {\\n            let length := mload(_preBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(length, mload(_postBytes))\\n            case 1 {\\n                // cb is a circuit breaker in the for loop since there's\\n                //  no said feature for inline assembly loops\\n                // cb = 1 - don't breaker\\n                // cb = 0 - break\\n                let cb := 1\\n\\n                let mc := add(_preBytes, 0x20)\\n                let end := add(mc, length)\\n\\n                for {\\n                    let cc := add(_postBytes, 0x20)\\n                // the next line is the loop condition:\\n                // while(uint256(mc < end) + cb == 2)\\n                } eq(add(lt(mc, end), cb), 2) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    // if any of these checks fails then arrays are not equal\\n                    if iszero(eq(mload(mc), mload(cc))) {\\n                        // unsuccess:\\n                        success := 0\\n                        cb := 0\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n\\n    function equalStorage(\\n        bytes storage _preBytes,\\n        bytes memory _postBytes\\n    )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        bool success = true;\\n\\n        assembly {\\n            // we know _preBytes_offset is 0\\n            let fslot := sload(_preBytes.slot)\\n            // Decode the length of the stored array like in concatStorage().\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(slength, mlength)\\n            case 1 {\\n                // slength can contain both the length and contents of the array\\n                // if length < 32 bytes so let's prepare for that\\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n                if iszero(iszero(slength)) {\\n                    switch lt(slength, 32)\\n                    case 1 {\\n                        // blank the last byte which is the length\\n                        fslot := mul(div(fslot, 0x100), 0x100)\\n\\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\\n                            // unsuccess:\\n                            success := 0\\n                        }\\n                    }\\n                    default {\\n                        // cb is a circuit breaker in the for loop since there's\\n                        //  no said feature for inline assembly loops\\n                        // cb = 1 - don't breaker\\n                        // cb = 0 - break\\n                        let cb := 1\\n\\n                        // get the keccak hash to get the contents of the array\\n                        mstore(0x0, _preBytes.slot)\\n                        let sc := keccak256(0x0, 0x20)\\n\\n                        let mc := add(_postBytes, 0x20)\\n                        let end := add(mc, mlength)\\n\\n                        // the next line is the loop condition:\\n                        // while(uint256(mc < end) + cb == 2)\\n                        for {} eq(add(lt(mc, end), cb), 2) {\\n                            sc := add(sc, 1)\\n                            mc := add(mc, 0x20)\\n                        } {\\n                            if iszero(eq(sload(sc), mload(mc))) {\\n                                // unsuccess:\\n                                success := 0\\n                                cb := 0\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n}\\n\",\"keccak256\":\"0xf75784dfc94ea43668eb195d5690a1dde1b6eda62017e73a3899721583821d29\",\"license\":\"Unlicense\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b5061481c806100206000396000f3fe6080604052600436106103385760003560e01c80637f0f1817116101b0578063a9b68271116100ec578063e35a0a8811610095578063ecc92eba1161006f578063ecc92eba14610b15578063f0f4426014610b5c578063f2fde38b14610b7c578063fb41be1614610b9c5761033f565b8063e35a0a8814610a9a578063e45b5c2914610aba578063ea2979ee14610af55761033f565b8063bd51aaa3116100c6578063bd51aaa3146109e7578063c805f68b14610a5a578063cbf50bb614610a7a5761033f565b8063a9b6827114610971578063b14d3532146109a7578063b59589d1146109c75761033f565b80638f9eb78b116101595780639a8a0592116101335780639a8a0592146108fb578063a015f99c14610911578063a2d95f2214610931578063a9ac5919146109515761033f565b80638f9eb78b1461081d578063913967d31461083d57806393c5c73a146108c65761033f565b80638d3d78cd1161018a5780638d3d78cd146107bf5780638d5fc1d4146107df5780638da5cb5b146107ff5761033f565b80637f0f18171461075f57806380bc47261461077f578063870ba6cf1461079f5761033f565b80635279feed1161027f5780636c32b2ec11610228578063715018a611610202578063715018a6146106dc57806375979f79146106f15780637a2181351461072c5780637ed557481461073f5761033f565b80636c32b2ec146106705780636e8adf611461069057806370872aa5146106c65761033f565b806361be10f21161025957806361be10f21461061057806361d027b3146106305780636b2857ef146106505761033f565b80635279feed146105a3578063527b42a6146105c357806359fd0b0c146105e35761033f565b80631e7107c7116102e157806342b5dcd0116102bb57806342b5dcd0146105145780634e63ba951461052a5780635221c1f0146105735761033f565b80631e7107c7146104b4578063292c1d92146104d457806333fe5676146104f45761033f565b80631812adb6116103125780631812adb61461044e5780631876dec4146104725780631dc4b09c146104925761033f565b806306be8b0e146103445780630d6467c0146103e657806317fcb39b146104165761033f565b3661033f57005b600080fd5b34801561035057600080fd5b506103a661035f366004613f32565b60a76020526000908152604090208054600182015460028301546003840154600485015460058601546006870154600790970154959660ff90951695939492939192909188565b604080519889529615156020890152958701949094526060860192909252608085015260a084015260c083015260e0820152610100015b60405180910390f35b3480156103f257600080fd5b5061040661040136600461400d565b610bbc565b60405190151581526020016103dd565b34801561042257600080fd5b5060a954610436906001600160a01b031681565b6040516001600160a01b0390911681526020016103dd565b34801561045a57600080fd5b5061046460025481565b6040519081526020016103dd565b34801561047e57600080fd5b50600554610436906001600160a01b031681565b34801561049e57600080fd5b506104b26104ad366004613e36565b610f54565b005b3480156104c057600080fd5b506104b26104cf366004613f32565b610f68565b3480156104e057600080fd5b5060a854610436906001600160a01b031681565b34801561050057600080fd5b506104b261050f366004613f62565b610f79565b34801561052057600080fd5b5061046460a15481565b34801561053657600080fd5b5061055e610545366004613f32565b60ac602052600090815260409020805460019091015482565b604080519283526020830191909152016103dd565b34801561057f57600080fd5b5061040661058e366004613f32565b60a66020526000908152604090205460ff1681565b3480156105af57600080fd5b506104b26105be366004614216565b610fef565b3480156105cf57600080fd5b506104646105de366004613f32565b611007565b3480156105ef57600080fd5b506104646105fe366004613f32565b60ad6020526000908152604090205481565b34801561061c57600080fd5b506104b261062b366004613e36565b61101f565b34801561063c57600080fd5b50600754610436906001600160a01b031681565b34801561065c57600080fd5b506104b261066b366004613f62565b611030565b34801561067c57600080fd5b5060aa54610436906001600160a01b031681565b34801561069c57600080fd5b506104366106ab366004613f32565b6008602052600090815260409020546001600160a01b031681565b3480156106d257600080fd5b5061046460005481565b3480156106e857600080fd5b506104b261109e565b3480156106fd57600080fd5b5061040661070c366004613f62565b60a560209081526000928352604080842090915290825290205460ff1681565b61040661073a3660046140bf565b6110a8565b34801561074b57600080fd5b506104b261075a366004613f32565b611760565b34801561076b57600080fd5b506104b261077a366004613e36565b611771565b34801561078b57600080fd5b5061040661079a366004613f32565b611782565b3480156107ab57600080fd5b506104b26107ba366004613e36565b6117ab565b3480156107cb57600080fd5b50600654610436906001600160a01b031681565b3480156107eb57600080fd5b506104b26107fa366004613f62565b6117bc565b34801561080b57600080fd5b50603d546001600160a01b0316610436565b34801561082957600080fd5b506104b26108383660046141f5565b6117d2565b34801561084957600080fd5b50610894610858366004613f32565b60a4602052600090815260409020805460018201546002830154600384015460049094015492936001600160a01b039092169290919060ff1685565b604080519586526001600160a01b0390941660208601529284019190915260608301521515608082015260a0016103dd565b3480156108d257600080fd5b5061055e6108e1366004613f32565b600090815260ac6020526040902080546001909101549091565b34801561090757600080fd5b5061046460015481565b34801561091d57600080fd5b506104b261092c366004614241565b6117e4565b34801561093d57600080fd5b5061040661094c366004613f91565b61197b565b34801561095d57600080fd5b506104b261096c366004613f62565b611dfc565b34801561097d57600080fd5b5061043661098c366004613f32565b60ae602052600090815260409020546001600160a01b031681565b3480156109b357600080fd5b506104b26109c2366004613e36565b611e75565b3480156109d357600080fd5b50600354610436906001600160a01b031681565b3480156109f357600080fd5b50610a37610a02366004613f62565b60a260209081526000928352604080842090915290825290208054600182015460029092015490916001600160a01b03169083565b604080519384526001600160a01b039092166020840152908201526060016103dd565b348015610a6657600080fd5b506104b2610a75366004613e36565b611e86565b348015610a8657600080fd5b506104b2610a95366004613f32565b611e97565b348015610aa657600080fd5b50600454610436906001600160a01b031681565b348015610ac657600080fd5b50610464610ad5366004613f62565b60a360209081526000928352604080842090915290825290206001015481565b348015610b0157600080fd5b506104b2610b10366004613f32565b611eea565b348015610b2157600080fd5b506104b2610b30366004614216565b6040805180820182529384526020808501938452600092835260ac905290209151825551600190910155565b348015610b6857600080fd5b506104b2610b77366004613e36565b611f40565b348015610b8857600080fd5b506104b2610b97366004613e36565b611f51565b348015610ba857600080fd5b5060ab54610436906001600160a01b031681565b6000610bc6611fde565b60015460008b815260a7602052604090205414801590610bf8575060008a815260a7602052604090206001015460ff16155b610c535760405162461bcd60e51b815260206004820152602160248201527f45786368616e6765526f757465723a20616c72656164792070726f63657373656044820152601960fa1b60648201526084015b60405180910390fd5b600160a760008c815260200190815260200160002060010160006101000a81548160ff021916908315150217905550600960008b815260200190815260200160002060030160019054906101000a90046001600160a01b03166001600160a01b031673E66AC01F73AE3cE8e7A0CFf5dB5A40388B354e746319e52d54610cfd8d8d8d8d604051602001610ce994939291906144c0565b604051602081830303815290604052612038565b6040516001600160e01b031960e084901b1681526004810191909152602481018a90526044810189905260ff8816606482015260840160206040518083038186803b158015610d4b57600080fd5b505af4158015610d5f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d839190613e59565b6001600160a01b031614610dd95760405162461bcd60e51b815260206004820152601e60248201527f45786368616e6765526f757465723a20696e76616c6964207369676e657200006044820152606401610c4a565b60065460aa5460008c815260a760205260409081902060020154905163095ea7b360e01b81526001600160a01b039283166004820152602481019190915291169063095ea7b390604401602060405180830381600087803b158015610e3d57600080fd5b505af1158015610e51573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e759190613e75565b5060aa5460008b815260a760205260409020600201546001600160a01b0390911690633fea4367908a60ff8d166005811115610ec157634e487b7160e01b600052602160045260246000fd5b878760006040518763ffffffff1660e01b8152600401610ee696959493929190614650565b602060405180830381600087803b158015610f0057600080fd5b505af1158015610f14573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f389190613f4a565b5060019050610f476001606f55565b9998505050505050505050565b610f5c6120a2565b610f65816120fc565b50565b610f706120a2565b610f65816121bd565b610f816120a2565b604080518381526001600160a01b03831660208201527fb3036f81a7a8205f3b94de16897df636d553839d92289fb7ec72dd2d54132842910160405180910390a1600091825260a5602090815260408084206001600160a01b0390931684529190529020805460ff19169055565b610ff76120a2565b611002828285612239565b505050565b600081815260ac60205260409020600101545b919050565b6110276120a2565b610f65816122a6565b6110386120a2565b60008281526008602090815260409182902080546001600160a01b0319166001600160a01b0385169081179091558251858152918201527f31a8c4e62daac2a3ed5d713004d9ae867d6dcddfa35603db2a4b65d9236b1bc1910160405180910390a15050565b6110a66120a2565b565b60006110b2611fde565b6004546001600160a01b0316336001600160a01b0316146111155760405162461bcd60e51b815260206004820152601e60248201527f45786368616e6765526f757465723a20696e76616c69642073656e64657200006044820152606401610c4a565b6000548560800151101561116b5760405162461bcd60e51b815260206004820152601b60248201527f45786368616e6765526f757465723a206f6c64207265717565737400000000006044820152606401610c4a565b60608501516001600160e01b031916156111ed5760405162461bcd60e51b815260206004820152602160248201527f45786368616e6765526f757465723a206e6f6e2d7a65726f206c6f636b74696d60448201527f65000000000000000000000000000000000000000000000000000000000000006064820152608401610c4a565b6005546040517faff2faa30000000000000000000000000000000000000000000000000000000081526001600160a01b039091169063aff2faa39061123890879087906004016144f3565b60206040518083038186803b15801561125057600080fd5b505afa158015611264573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112889190613e75565b6112d45760405162461bcd60e51b815260206004820152601a60248201527f45786368616e6765526f757465723a206e6f74206c6f636b65720000000000006044820152606401610c4a565b600073E66AC01F73AE3cE8e7A0CFf5dB5A40388B354e7463dba71cdf87600960a7600660009054906101000a90046001600160a01b031660a960009054906101000a90046001600160a01b03166127108c8c600360009054906101000a90046001600160a01b03166040518a63ffffffff1660e01b815260040161136099989796959493929190614548565b60206040518083038186803b15801561137857600080fd5b505af415801561138c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113b09190613f4a565b600081815260a760205260408120549192509081906113e390600090815260ac6020526040902080546001909101549091565b9150915060015482146114385760405162461bcd60e51b815260206004820152601b60248201527f45786368616e6765526f757465723a2077726f6e6720636861696e00000000006044820152606401610c4a565b600081815260a6602052604090205460ff166114965760405162461bcd60e51b815260206004820181905260248201527f45786368616e6765526f757465723a20696e76616c696420636861696e2069646044820152606401610c4a565b600083815260096020908152604080832081516101408101835281548152600182015481850152600282015481840152600382015460ff808216151560608401526101009091046001600160a01b03166080830152600483015460a0830152600583015416151560c08201526006820180548451818702810187019095528085529194929360e086019390929083018282801561155c57602002820191906000526020600020905b81546001600160a01b0316815260019091019060200180831161153e575b50505091835250506007820154602080830191909152600892830154604092830152835160009081529290529020549091506001600160a01b0316806115e45760405162461bcd60e51b815260206004820152601d60248201527f45786368616e6765526f757465723a20696e76616c69642061707049640000006044820152606401610c4a565b61162589898080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250899250612367915050565b6101208201511561169e5760405162461bcd60e51b815260206004820152602760248201527f45786368616e6765526f757465723a2066696c6c6572206973206e6f7420737560448201527f70706f72746564000000000000000000000000000000000000000000000000006064820152608401610c4a565b6001548314156116f1576116ec818a8a8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152508a92508c91506127499050565b611745565b611745818a8a8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201829052508b815260a760205260409020600301548b93508d925090508861296d565b6001955050505050506117586001606f55565b949350505050565b6117686120a2565b610f6581612c39565b6117796120a2565b610f6581612cf2565b60008181526009602052604081206005015460ff166117a25760006117a5565b60015b92915050565b6117b36120a2565b610f6581612db3565b6117c46120a2565b6117ce8282612e74565b5050565b6117da6120a2565b6117ce8282612f10565b600a54610100900460ff16158080156118045750600a54600160ff909116105b8061181e5750303b15801561181e5750600a5460ff166001145b6118905760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201527f647920696e697469616c697a65640000000000000000000000000000000000006064820152608401610c4a565b600a805460ff1916600117905580156118b357600a805461ff0019166101001790555b6118bb612f71565b6118c3612fe4565b6001888155600089815260a660205260409020805460ff191690911790556118ea8a6121bd565b6118f389612c39565b6118fc86613057565b61190587613118565b61190e85612cf2565b611917846131d9565b611920836122a6565b611929826120fc565b801561196f57600a805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b50505050505050505050565b6000611985611fde565b600088815260096020908152604080832081516101408101835281548152600182015481850152600282015481840152600382015460ff808216151560608401526101009091046001600160a01b03166080830152600483015460a0830152600583015416151560c08201526006820180548451818702810187019095528085529194929360e0860193909290830182828015611a4b57602002820191906000526020600020905b81546001600160a01b03168152600190910190602001808311611a2d575b5050505050815260200160078201548152602001600882015481525050905060015460a760008b81526020019081526020016000206000015414158015611aa45750600089815260a7602052604090206001015460ff16155b611afa5760405162461bcd60e51b815260206004820152602160248201527f45786368616e6765526f757465723a20616c72656164792070726f63657373656044820152601960fa1b6064820152608401610c4a565b600089815260a760209081526040918290206001908101805460ff19169091179055608083015191516001600160a01b039092169173E66AC01F73AE3cE8e7A0CFf5dB5A40388B354e74916319e52d5491611b6191610ce9918f918f918f918f91016143c2565b6040516001600160e01b031960e084901b1681526004810191909152602481018990526044810188905260ff8716606482015260840160206040518083038186803b158015611baf57600080fd5b505af4158015611bc3573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611be79190613e59565b6001600160a01b031614611c3d5760405162461bcd60e51b815260206004820152601e60248201527f45786368616e6765526f757465723a20696e76616c6964207369676e657200006044820152606401610c4a565b80516000908152600860209081526040808320548c845260a79092528083206002015490517fb0bbcd8800000000000000000000000000000000000000000000000000000000815283926001600160a01b03169163b0bbcd8891611caf91908e908d90309042906001906004016146b2565b600060405180830381600087803b158015611cc957600080fd5b505af1158015611cdd573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052611d059190810190613e8f565b9150915081611d565760405162461bcd60e51b815260206004820152601b60248201527f45786368616e6765526f757465723a2073776170206661696c656400000000006044820152606401610c4a565b60008b815260a760205260409020548851611de091908a90611d7a9060019061478e565b81518110611d9857634e487b7160e01b600052603260045260246000fd5b60200260200101518360018551611daf919061478e565b81518110611dcd57634e487b7160e01b600052603260045260246000fd5b602002602001015186608001518d61329a565b60019350505050611df16001606f55565b979650505050505050565b611e046120a2565b604080518381526001600160a01b03831660208201527fca37a60f79854243dcab36b6ad6fcaafc7ae13448087ee70547943babc7dccf0910160405180910390a1600091825260a5602090815260408084206001600160a01b0390931684529190529020805460ff19166001179055565b611e7d6120a2565b610f6581613118565b611e8e6120a2565b610f6581613057565b611e9f6120a2565b6040518181527f11a9d1a77f76361ed131c19b1dc5758504c51dbde2e49fc973a0ef9577ad13d59060200160405180910390a1600090815260a660205260409020805460ff19169055565b611ef26120a2565b6040518181527fbba9d55e9fd1a441b1617724e2fdb76777d15ec77ab2b72ac15952cbe97085db9060200160405180910390a1600090815260a660205260409020805460ff19166001179055565b611f486120a2565b610f65816131d9565b611f596120a2565b6001600160a01b038116611fd55760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152608401610c4a565b610f65816133fc565b6002606f5414156120315760405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c006044820152606401610c4a565b6002606f55565b6000818051906020012060405160200161207e91907f19457468657265756d205369676e6564204d6573736167653a0a3332000000008152601c810191909152603c0190565b604051602081830303815290604052805190602001209050919050565b6001606f55565b603d546001600160a01b031633146110a65760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610c4a565b806001600160a01b0381166121535760405162461bcd60e51b815260206004820152601c60248201527f45786368616e6765526f757465723a207a65726f2061646472657373000000006044820152606401610c4a565b60aa54604080516001600160a01b03928316815291841660208301527f5b663d57fa8cf393f8c8019f514b25c1b3223c9324a2ce3efe28ce5aef0e62fe910160405180910390a15060aa80546001600160a01b0319166001600160a01b0392909216919091179055565b60005481116122345760405162461bcd60e51b815260206004820152602960248201527f434345786368616e6765526f757465723a206c6f77207374617274696e67426c60448201527f6f636b4e756d62657200000000000000000000000000000000000000000000006064820152608401610c4a565b600055565b60408051828152602081018590529081018390527fd4d81e1736e6dd2e97d0c6eff0dc7ec7184dec2bd4e03ce98d84d6057a8045c49060600160405180910390a16040805180820182529384526020808501938452600092835260ac905290209151825551600190910155565b806001600160a01b0381166122fd5760405162461bcd60e51b815260206004820152601c60248201527f45786368616e6765526f757465723a207a65726f2061646472657373000000006044820152606401610c4a565b60a854604080516001600160a01b03928316815291841660208301527f06e5f2ca1234f717a2031f662608c02182d4f8bdc3dab013ec4c04eb97553132910160405180910390a15060a880546001600160a01b0319166001600160a01b0392909216919091179055565b6005546000828152600960205260408082206001015490517f1fcfe19c00000000000000000000000000000000000000000000000000000000815291926001600160a01b031691631fcfe19c916123c4918791309160040161451a565b602060405180830381600087803b1580156123de57600080fd5b505af11580156123f2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906124169190613f4a565b6002546000848152600960205260409020600101549192506127109161243c919061476f565b612446919061474f565b600083815260a76020908152604080832060058101949094556009808352818420600480820154960154855260ad8452918420549387905290915260010154612710916124929161476f565b61249c919061474f565b600084815260a760209081526040808320600601939093556009905220600101546124c890839061478e565b600084815260a760205260409020600701558015612574576006546001600160a01b031663a9059cbb336040516001600160e01b031960e084901b1681526001600160a01b03909116600482015260248101849052604401602060405180830381600087803b15801561253a57600080fd5b505af115801561254e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906125729190613e75565b505b600083815260a760205260409020600501541561262957600654600754600085815260a760205260409081902060050154905163a9059cbb60e01b81526001600160a01b039283166004820152602481019190915291169063a9059cbb90604401602060405180830381600087803b1580156125ef57600080fd5b505af1158015612603573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906126279190613e75565b505b600083815260a76020526040902060060154156126f55760068054600085815260a760208181526040808420600480820154865260ae845282862054958b905293909252940154935163a9059cbb60e01b81526001600160a01b03928316918101919091526024810193909352169063a9059cbb90604401602060405180830381600087803b1580156126bb57600080fd5b505af11580156126cf573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906126f39190613e75565b505b600083815260a7602052604090206006810154600590910154829061271a908561478e565b612724919061478e565b61272e919061478e565b600093845260a7602052604090932060020192909255505050565b600180546000848152600960209081526040808320815161014081018352815481529581015486840152600281015486830152600381015460ff808216151560608901526101009091046001600160a01b03166080880152600482015460a0880152600582015416151560c0870152600681018054835181860281018601909452808452949687966128ad9690958c9592949360e086019392909183018282801561281d57602002820191906000526020600020905b81546001600160a01b031681526001909101906020018083116127ff575b505050918352505060078281015460208084019190915260089093015460409283015260008b815260a7845282902082516101008101845281548152600182015460ff161515948101949094526002810154928401929092526003820154606084015260048201546080840152600582015460a0840152600682015460c0840152015460e082015288888c61344e565b91509150816129655760065460008581526009602090815260408083206003015460a79092529182902060020154915163a9059cbb60e01b81526101009091046001600160a01b039081166004830152602482019290925291169063a9059cbb90604401602060405180830381600087803b15801561292b57600080fd5b505af115801561293f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906129639190613e75565b505b505050505050565b600084815260096020908152604080832081516101408101835281548152600182015481850152600282015481840152600382015460ff808216151560608401526101009091046001600160a01b03166080830152600483015460a0830152600583015416151560c08201526006820180548451818702810187019095528085528695612ac99589958e9594909360e0860193830182828015612a3957602002820191906000526020600020905b81546001600160a01b03168152600190910190602001808311612a1b575b505050918352505060078281015460208084019190915260089093015460409283015260008d815260a7845282902082516101008101845281548152600182015460ff161515948101949094526002810154928401929092526003820154606084015260048201546080840152600582015460a0840152600682015460c0840152015460e08201528a8a8e61344e565b915091508115612b9457600086815260a7602052604090206001818101805460ff19168217905590548651612b8f928891612b04919061478e565b81518110612b2257634e487b7160e01b600052603260045260246000fd5b60200260200101518360018551612b39919061478e565b81518110612b5757634e487b7160e01b600052603260045260246000fd5b6020026020010151600960008b815260200190815260200160002060030160019054906101000a90046001600160a01b03168861329a565b612c2f565b600654600087815260a760205260409081902060020154905163095ea7b360e01b81526001600160a01b038b81166004830152602482019290925291169063095ea7b390604401602060405180830381600087803b158015612bf557600080fd5b505af1158015612c09573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612c2d9190613e75565b505b5050505050505050565b806127101015612cb15760405162461bcd60e51b815260206004820152602560248201527f434345786368616e6765526f757465723a20666565206973206f7574206f662060448201527f72616e67650000000000000000000000000000000000000000000000000000006064820152608401610c4a565b60025460408051918252602082018390527f7d205f60891f60851c61cd244ba387d72b6589e7c0ac41b9d909ab0ce2c2a53b910160405180910390a1600255565b806001600160a01b038116612d495760405162461bcd60e51b815260206004820152601c60248201527f45786368616e6765526f757465723a207a65726f2061646472657373000000006044820152606401610c4a565b600654604080516001600160a01b03928316815291841660208301527f36a4c08a38b736dcecb6c328dba61238529620e83ccb23db2cc43cd34ec26096910160405180910390a150600680546001600160a01b0319166001600160a01b0392909216919091179055565b806001600160a01b038116612e0a5760405162461bcd60e51b815260206004820152601c60248201527f45786368616e6765526f757465723a207a65726f2061646472657373000000006044820152606401610c4a565b600454604080516001600160a01b03928316815291841660208301527f12ad124e13af4c31364ad22aa74320e167b37f005dafb75d71a210c49da3629e910160405180910390a150600480546001600160a01b0319166001600160a01b0392909216919091179055565b600082815260ae6020526040908190205490517f1e73962bcff5b98a9ac70c9b0f71fbb31dc0f5a09348c6d3ceab164169a9e72991612eda9185916001600160a01b03169085909283526001600160a01b03918216602084015216604082015260600190565b60405180910390a1600091825260ae602052604090912080546001600160a01b0319166001600160a01b03909216919091179055565b600082815260ad6020908152604091829020548251858152918201529081018290527f188adabf806a6b6d814acc1dbd9f09e5a251c8c065d6285749a5824e4579b6459060600160405180910390a1600091825260ad602052604090912055565b600a54610100900460ff16612fdc5760405162461bcd60e51b815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201526a6e697469616c697a696e6760a81b6064820152608401610c4a565b6110a6613bf7565b600a54610100900460ff1661304f5760405162461bcd60e51b815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201526a6e697469616c697a696e6760a81b6064820152608401610c4a565b6110a6613c6b565b806001600160a01b0381166130ae5760405162461bcd60e51b815260206004820152601c60248201527f45786368616e6765526f757465723a207a65726f2061646472657373000000006044820152606401610c4a565b600354604080516001600160a01b03928316815291841660208301527f4c28a3f61a715259c4dc930c23e7423b8fa52e13232c061a6e488729c66184f4910160405180910390a150600380546001600160a01b0319166001600160a01b0392909216919091179055565b806001600160a01b03811661316f5760405162461bcd60e51b815260206004820152601c60248201527f45786368616e6765526f757465723a207a65726f2061646472657373000000006044820152606401610c4a565b600554604080516001600160a01b03928316815291841660208301527ffa021c2ec0f46429a53e7f88b88065e40001f50c9d38b2e8b713beaf9828d4c3910160405180910390a150600580546001600160a01b0319166001600160a01b0392909216919091179055565b806001600160a01b0381166132305760405162461bcd60e51b815260206004820152601c60248201527f45786368616e6765526f757465723a207a65726f2061646472657373000000006044820152606401610c4a565b600754604080516001600160a01b03928316815291841660208301527f567657fa3f286518b318f4a29870674f433f622fdfc819691acb13105b228225910160405180910390a150600780546001600160a01b0319166001600160a01b0392909216919091179055565b60a85460405163095ea7b360e01b81526001600160a01b039182166004820152602481018590529085169063095ea7b390604401602060405180830381600087803b1580156132e857600080fd5b505af11580156132fc573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906133209190613e75565b5060a8546001600160a01b0316631186ec3383868661333e8a611007565b6040516001600160e01b031960e087901b1681526001600160a01b03948516600482015293909216602484015260448301526064820152600784900b608482015263ffffffff421660a482015261010060c482015260026101048201527f307800000000000000000000000000000000000000000000000000000000000061012482015260001960e482015261014401600060405180830381600087803b1580156133e857600080fd5b505af1158015612c2d573d6000803e3d6000fd5b603d80546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b600060606001548914806134c45750600089815260a5602052604081208551909190869061347e9060019061478e565b8151811061349c57634e487b7160e01b600052603260045260246000fd5b6020908102919091018101516001600160a01b031682528101919091526040016000205460ff165b1561385157600654604087810151905163095ea7b360e01b81526001600160a01b038681166004830152602482019290925291169063095ea7b390604401602060405180830381600087803b15801561351c57600080fd5b505af1158015613530573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906135549190613e75565b506040517f9b4bca240000000000000000000000000000000000000000000000000000000081526001600160a01b03841690639b4bca249061359a9087906004016144ad565b60206040518083038186803b1580156135b257600080fd5b505afa1580156135c6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906135ea9190613e75565b1561384c5760065484516001600160a01b0390911690859060009061361f57634e487b7160e01b600052603260045260246000fd5b60200260200101516001600160a01b03161480156136ba575060e0870151805161364b9060019061478e565b8151811061366957634e487b7160e01b600052603260045260246000fd5b60200260200101516001600160a01b03168460018651613689919061478e565b815181106136a757634e487b7160e01b600052603260045260246000fd5b60200260200101516001600160a01b0316145b6137065760405162461bcd60e51b815260206004820152601e60248201527f436345786368616e6765526f757465723a20696e76616c6964207061746800006044820152606401610c4a565b826001600160a01b031663b0bbcd8887604001518960400151878b608001514260016040518763ffffffff1660e01b8152600401613749969594939291906146b2565b600060405180830381600087803b15801561376357600080fd5b505af1158015613777573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261379f9190810190613e8f565b90925090508161384c57826001600160a01b031663b0bbcd88876040015189604001518a60e001518b608001514260016040518763ffffffff1660e01b81526004016137f0969594939291906146b2565b600060405180830381600087803b15801561380a57600080fd5b505af115801561381e573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526138469190810190613e8f565b90925090505b613856565b600091505b60006040518060a001604052808960a0015181526020018860e0015181526020018860a0015181526020018860c001518152602001886060015181525090508215613a7057336001600160a01b031688610120015189608001516001600160a01b03167f9a89a1f930026d8c37eac8e47828d2019fb5076a7eea6314919dfc8426f894dd600560009054906101000a90046001600160a01b03166001600160a01b031663c4d10b6a8e6040518263ffffffff1660e01b815260040161391b9190614507565b60206040518083038186803b15801561393357600080fd5b505afa158015613947573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061396b9190613e59565b604080518082019091526006546001600160a01b031681528a5160208201908c906139989060019061478e565b815181106139b657634e487b7160e01b600052603260045260246000fd5b60200260200101516001600160a01b03166001600160a01b03168152506040518060400160405280896000815181106139ff57634e487b7160e01b600052603260045260246000fd5b602002602001015181526020018960018b51613a1b919061478e565b81518110613a3957634e487b7160e01b600052603260045260246000fd5b60200260200101518152508c8f600001518f608001518a604051613a639796959493929190614413565b60405180910390a4613bea565b336001600160a01b031688610120015189608001516001600160a01b03167f2f2349a4438effe698d654ac41a4f96349f503bd1e6f48dac5c8cd74f8d4d11f600560009054906101000a90046001600160a01b03166001600160a01b031663c4d10b6a8e6040518263ffffffff1660e01b8152600401613af09190614507565b60206040518083038186803b158015613b0857600080fd5b505afa158015613b1c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613b409190613e59565b604080518082019091526006546001600160a01b031681528a5160208201908c90613b6d9060019061478e565b81518110613b8b57634e487b7160e01b600052603260045260246000fd5b60200260200101516001600160a01b03166001600160a01b031681525060405180604001604052808e60400151815260200160008152508c8f600001518f608001518a604051613be19796959493929190614413565b60405180910390a45b5097509795505050505050565b600a54610100900460ff16613c625760405162461bcd60e51b815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201526a6e697469616c697a696e6760a81b6064820152608401610c4a565b6110a6336133fc565b600a54610100900460ff1661209b5760405162461bcd60e51b815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201526a6e697469616c697a696e6760a81b6064820152608401610c4a565b600082601f830112613ce6578081fd5b81356020613cfb613cf68361472b565b6146fa565b8281528181019085830183850287018401881015613d17578586fd5b855b85811015613d3e578135613d2c816147d1565b84529284019290840190600101613d19565b5090979650505050505050565b8051801515811461101a57600080fd5b80356001600160e01b03198116811461101a57600080fd5b60008083601f840112613d84578182fd5b50813567ffffffffffffffff811115613d9b578182fd5b602083019150836020828501011115613db357600080fd5b9250929050565b600082601f830112613dca578081fd5b813567ffffffffffffffff811115613de457613de46147bb565b613df7601f8201601f19166020016146fa565b818152846020838601011115613e0b578283fd5b816020850160208301379081016020019190915292915050565b803560ff8116811461101a57600080fd5b600060208284031215613e47578081fd5b8135613e52816147d1565b9392505050565b600060208284031215613e6a578081fd5b8151613e52816147d1565b600060208284031215613e86578081fd5b613e5282613d4b565b60008060408385031215613ea1578081fd5b613eaa83613d4b565b915060208084015167ffffffffffffffff811115613ec6578283fd5b8401601f81018613613ed6578283fd5b8051613ee4613cf68261472b565b81815283810190838501858402850186018a1015613f00578687fd5b8694505b83851015613f22578051835260019490940193918501918501613f04565b5080955050505050509250929050565b600060208284031215613f43578081fd5b5035919050565b600060208284031215613f5b578081fd5b5051919050565b60008060408385031215613f74578182fd5b823591506020830135613f86816147d1565b809150509250929050565b600080600080600080600060e0888a031215613fab578283fd5b873596506020880135955060408801359450606088013567ffffffffffffffff811115613fd6578384fd5b613fe28a828b01613cd6565b9450506080880135925060a08801359150613fff60c08901613e25565b905092959891949750929550565b60008060008060008060008060006101008a8c03121561402b578283fd5b8935985061403b60208b01613e25565b975060408a013567ffffffffffffffff80821115614057578485fd5b6140638d838e01613dba565b985060608c0135975060808c0135965060a08c0135955061408660c08d01613e25565b945060e08c013591508082111561409b578384fd5b506140a88c828d01613d73565b915080935050809150509295985092959850929598565b600080600080606085870312156140d4578182fd5b843567ffffffffffffffff808211156140eb578384fd5b9086019060e082890312156140fe578384fd5b61410860e06146fa565b61411183613d5b565b8152602083013582811115614124578586fd5b6141308a828601613dba565b602083015250604083013582811115614147578586fd5b6141538a828601613dba565b60408301525061416560608401613d5b565b60608201526080830135608082015260a083013582811115614185578586fd5b6141918a828601613dba565b60a08301525060c083013560c08201528096505060208701359150808211156141b8578384fd5b6141c488838901613d73565b909550935060408701359150808211156141dc578283fd5b506141e987828801613cd6565b91505092959194509250565b60008060408385031215614207578182fd5b50508035926020909101359150565b60008060006060848603121561422a578081fd5b505081359360208301359350604090920135919050565b60008060008060008060008060006101208a8c03121561425f578283fd5b8935985060208a0135975060408a0135965060608a013561427f816147d1565b955060808a013561428f816147d1565b945060a08a013561429f816147d1565b935060c08a01356142af816147d1565b925060e08a01356142bf816147d1565b91506101008a01356142d0816147d1565b809150509295985092959850929598565b6000815180845260208085019450808401835b838110156143195781516001600160a01b0316875295820195908201906001016142f4565b509495945050505050565b8060005b6005811015614347578151845260209384019390910190600101614328565b50505050565b60008284528282602086013780602084860101526020601f19601f85011685010190509392505050565b60008151808452815b8181101561439c57602081850181015186830182015201614380565b818111156143ad5782602083870101525b50601f01601f19169290920160200192915050565b600085825260208581840152846040840152606083018451828601845b828110156144045781516001600160a01b0316845292840192908401906001016143df565b50919998505050505050505050565b6001600160a01b03881681526101a0810160208083018960005b60028110156144555781516001600160a01b031683526020830192509083019060010161442d565b505050606083018860005b600281101561447d57815183529183019190830190600101614460565b505050508560a08301528460c08301528360e08301526144a1610100830184614324565b98975050505050505050565b600060208252613e5260208301846142e1565b600085825260ff85166020830152608060408301526144e26080830185614377565b905082606083015295945050505050565b60006020825261175860208301848661434d565b600060208252613e526020830184614377565b60006060825261452d6060830186614377565b6001600160a01b039490941660208301525060400152919050565b600061010082526001600160e01b0319808c511661010084015260208c015160e061012085015261457d6101e0850182614377565b905060408d015160ff198583030161014086015261459b8282614377565b60608f0151909316610160860152505060808c015161018084015260a08c015183820360ff19016101a0850152906145d38183614377565b91505060c08c01516101c08401528a6020840152896040840152614602606084018a6001600160a01b03169052565b6001600160a01b03881660808401528660a084015282810360c084015261462a81868861434d565b91505061464260e08301846001600160a01b03169052565b9a9950505050505050505050565b600087825260a0602083015261466960a0830188614377565b6006871061468557634e487b7160e01b82526021600452602482fd5b866040840152828103606084015261469e81868861434d565b915050826080830152979650505050505050565b600087825286602083015260c060408301526146d160c08301876142e1565b6001600160a01b03959095166060830152506080810192909252151560a0909101529392505050565b604051601f8201601f1916810167ffffffffffffffff81118282101715614723576147236147bb565b604052919050565b600067ffffffffffffffff821115614745576147456147bb565b5060209081020190565b60008261476a57634e487b7160e01b81526012600452602481fd5b500490565b6000816000190483118215151615614789576147896147a5565b500290565b6000828210156147a0576147a06147a5565b500390565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052604160045260246000fd5b6001600160a01b0381168114610f6557600080fdfea2646970667358221220af52952296658ab74558844b8f584424d9caaa121d01379a54578f9febdb935b64736f6c63430008020033",
  "deployedBytecode": "0x6080604052600436106103385760003560e01c80637f0f1817116101b0578063a9b68271116100ec578063e35a0a8811610095578063ecc92eba1161006f578063ecc92eba14610b15578063f0f4426014610b5c578063f2fde38b14610b7c578063fb41be1614610b9c5761033f565b8063e35a0a8814610a9a578063e45b5c2914610aba578063ea2979ee14610af55761033f565b8063bd51aaa3116100c6578063bd51aaa3146109e7578063c805f68b14610a5a578063cbf50bb614610a7a5761033f565b8063a9b6827114610971578063b14d3532146109a7578063b59589d1146109c75761033f565b80638f9eb78b116101595780639a8a0592116101335780639a8a0592146108fb578063a015f99c14610911578063a2d95f2214610931578063a9ac5919146109515761033f565b80638f9eb78b1461081d578063913967d31461083d57806393c5c73a146108c65761033f565b80638d3d78cd1161018a5780638d3d78cd146107bf5780638d5fc1d4146107df5780638da5cb5b146107ff5761033f565b80637f0f18171461075f57806380bc47261461077f578063870ba6cf1461079f5761033f565b80635279feed1161027f5780636c32b2ec11610228578063715018a611610202578063715018a6146106dc57806375979f79146106f15780637a2181351461072c5780637ed557481461073f5761033f565b80636c32b2ec146106705780636e8adf611461069057806370872aa5146106c65761033f565b806361be10f21161025957806361be10f21461061057806361d027b3146106305780636b2857ef146106505761033f565b80635279feed146105a3578063527b42a6146105c357806359fd0b0c146105e35761033f565b80631e7107c7116102e157806342b5dcd0116102bb57806342b5dcd0146105145780634e63ba951461052a5780635221c1f0146105735761033f565b80631e7107c7146104b4578063292c1d92146104d457806333fe5676146104f45761033f565b80631812adb6116103125780631812adb61461044e5780631876dec4146104725780631dc4b09c146104925761033f565b806306be8b0e146103445780630d6467c0146103e657806317fcb39b146104165761033f565b3661033f57005b600080fd5b34801561035057600080fd5b506103a661035f366004613f32565b60a76020526000908152604090208054600182015460028301546003840154600485015460058601546006870154600790970154959660ff90951695939492939192909188565b604080519889529615156020890152958701949094526060860192909252608085015260a084015260c083015260e0820152610100015b60405180910390f35b3480156103f257600080fd5b5061040661040136600461400d565b610bbc565b60405190151581526020016103dd565b34801561042257600080fd5b5060a954610436906001600160a01b031681565b6040516001600160a01b0390911681526020016103dd565b34801561045a57600080fd5b5061046460025481565b6040519081526020016103dd565b34801561047e57600080fd5b50600554610436906001600160a01b031681565b34801561049e57600080fd5b506104b26104ad366004613e36565b610f54565b005b3480156104c057600080fd5b506104b26104cf366004613f32565b610f68565b3480156104e057600080fd5b5060a854610436906001600160a01b031681565b34801561050057600080fd5b506104b261050f366004613f62565b610f79565b34801561052057600080fd5b5061046460a15481565b34801561053657600080fd5b5061055e610545366004613f32565b60ac602052600090815260409020805460019091015482565b604080519283526020830191909152016103dd565b34801561057f57600080fd5b5061040661058e366004613f32565b60a66020526000908152604090205460ff1681565b3480156105af57600080fd5b506104b26105be366004614216565b610fef565b3480156105cf57600080fd5b506104646105de366004613f32565b611007565b3480156105ef57600080fd5b506104646105fe366004613f32565b60ad6020526000908152604090205481565b34801561061c57600080fd5b506104b261062b366004613e36565b61101f565b34801561063c57600080fd5b50600754610436906001600160a01b031681565b34801561065c57600080fd5b506104b261066b366004613f62565b611030565b34801561067c57600080fd5b5060aa54610436906001600160a01b031681565b34801561069c57600080fd5b506104366106ab366004613f32565b6008602052600090815260409020546001600160a01b031681565b3480156106d257600080fd5b5061046460005481565b3480156106e857600080fd5b506104b261109e565b3480156106fd57600080fd5b5061040661070c366004613f62565b60a560209081526000928352604080842090915290825290205460ff1681565b61040661073a3660046140bf565b6110a8565b34801561074b57600080fd5b506104b261075a366004613f32565b611760565b34801561076b57600080fd5b506104b261077a366004613e36565b611771565b34801561078b57600080fd5b5061040661079a366004613f32565b611782565b3480156107ab57600080fd5b506104b26107ba366004613e36565b6117ab565b3480156107cb57600080fd5b50600654610436906001600160a01b031681565b3480156107eb57600080fd5b506104b26107fa366004613f62565b6117bc565b34801561080b57600080fd5b50603d546001600160a01b0316610436565b34801561082957600080fd5b506104b26108383660046141f5565b6117d2565b34801561084957600080fd5b50610894610858366004613f32565b60a4602052600090815260409020805460018201546002830154600384015460049094015492936001600160a01b039092169290919060ff1685565b604080519586526001600160a01b0390941660208601529284019190915260608301521515608082015260a0016103dd565b3480156108d257600080fd5b5061055e6108e1366004613f32565b600090815260ac6020526040902080546001909101549091565b34801561090757600080fd5b5061046460015481565b34801561091d57600080fd5b506104b261092c366004614241565b6117e4565b34801561093d57600080fd5b5061040661094c366004613f91565b61197b565b34801561095d57600080fd5b506104b261096c366004613f62565b611dfc565b34801561097d57600080fd5b5061043661098c366004613f32565b60ae602052600090815260409020546001600160a01b031681565b3480156109b357600080fd5b506104b26109c2366004613e36565b611e75565b3480156109d357600080fd5b50600354610436906001600160a01b031681565b3480156109f357600080fd5b50610a37610a02366004613f62565b60a260209081526000928352604080842090915290825290208054600182015460029092015490916001600160a01b03169083565b604080519384526001600160a01b039092166020840152908201526060016103dd565b348015610a6657600080fd5b506104b2610a75366004613e36565b611e86565b348015610a8657600080fd5b506104b2610a95366004613f32565b611e97565b348015610aa657600080fd5b50600454610436906001600160a01b031681565b348015610ac657600080fd5b50610464610ad5366004613f62565b60a360209081526000928352604080842090915290825290206001015481565b348015610b0157600080fd5b506104b2610b10366004613f32565b611eea565b348015610b2157600080fd5b506104b2610b30366004614216565b6040805180820182529384526020808501938452600092835260ac905290209151825551600190910155565b348015610b6857600080fd5b506104b2610b77366004613e36565b611f40565b348015610b8857600080fd5b506104b2610b97366004613e36565b611f51565b348015610ba857600080fd5b5060ab54610436906001600160a01b031681565b6000610bc6611fde565b60015460008b815260a7602052604090205414801590610bf8575060008a815260a7602052604090206001015460ff16155b610c535760405162461bcd60e51b815260206004820152602160248201527f45786368616e6765526f757465723a20616c72656164792070726f63657373656044820152601960fa1b60648201526084015b60405180910390fd5b600160a760008c815260200190815260200160002060010160006101000a81548160ff021916908315150217905550600960008b815260200190815260200160002060030160019054906101000a90046001600160a01b03166001600160a01b031673__$5188ca1ef01dc999a9b560e2e2728f759b$__6319e52d54610cfd8d8d8d8d604051602001610ce994939291906144c0565b604051602081830303815290604052612038565b6040516001600160e01b031960e084901b1681526004810191909152602481018a90526044810189905260ff8816606482015260840160206040518083038186803b158015610d4b57600080fd5b505af4158015610d5f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d839190613e59565b6001600160a01b031614610dd95760405162461bcd60e51b815260206004820152601e60248201527f45786368616e6765526f757465723a20696e76616c6964207369676e657200006044820152606401610c4a565b60065460aa5460008c815260a760205260409081902060020154905163095ea7b360e01b81526001600160a01b039283166004820152602481019190915291169063095ea7b390604401602060405180830381600087803b158015610e3d57600080fd5b505af1158015610e51573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e759190613e75565b5060aa5460008b815260a760205260409020600201546001600160a01b0390911690633fea4367908a60ff8d166005811115610ec157634e487b7160e01b600052602160045260246000fd5b878760006040518763ffffffff1660e01b8152600401610ee696959493929190614650565b602060405180830381600087803b158015610f0057600080fd5b505af1158015610f14573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f389190613f4a565b5060019050610f476001606f55565b9998505050505050505050565b610f5c6120a2565b610f65816120fc565b50565b610f706120a2565b610f65816121bd565b610f816120a2565b604080518381526001600160a01b03831660208201527fb3036f81a7a8205f3b94de16897df636d553839d92289fb7ec72dd2d54132842910160405180910390a1600091825260a5602090815260408084206001600160a01b0390931684529190529020805460ff19169055565b610ff76120a2565b611002828285612239565b505050565b600081815260ac60205260409020600101545b919050565b6110276120a2565b610f65816122a6565b6110386120a2565b60008281526008602090815260409182902080546001600160a01b0319166001600160a01b0385169081179091558251858152918201527f31a8c4e62daac2a3ed5d713004d9ae867d6dcddfa35603db2a4b65d9236b1bc1910160405180910390a15050565b6110a66120a2565b565b60006110b2611fde565b6004546001600160a01b0316336001600160a01b0316146111155760405162461bcd60e51b815260206004820152601e60248201527f45786368616e6765526f757465723a20696e76616c69642073656e64657200006044820152606401610c4a565b6000548560800151101561116b5760405162461bcd60e51b815260206004820152601b60248201527f45786368616e6765526f757465723a206f6c64207265717565737400000000006044820152606401610c4a565b60608501516001600160e01b031916156111ed5760405162461bcd60e51b815260206004820152602160248201527f45786368616e6765526f757465723a206e6f6e2d7a65726f206c6f636b74696d60448201527f65000000000000000000000000000000000000000000000000000000000000006064820152608401610c4a565b6005546040517faff2faa30000000000000000000000000000000000000000000000000000000081526001600160a01b039091169063aff2faa39061123890879087906004016144f3565b60206040518083038186803b15801561125057600080fd5b505afa158015611264573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112889190613e75565b6112d45760405162461bcd60e51b815260206004820152601a60248201527f45786368616e6765526f757465723a206e6f74206c6f636b65720000000000006044820152606401610c4a565b600073__$5188ca1ef01dc999a9b560e2e2728f759b$__63dba71cdf87600960a7600660009054906101000a90046001600160a01b031660a960009054906101000a90046001600160a01b03166127108c8c600360009054906101000a90046001600160a01b03166040518a63ffffffff1660e01b815260040161136099989796959493929190614548565b60206040518083038186803b15801561137857600080fd5b505af415801561138c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113b09190613f4a565b600081815260a760205260408120549192509081906113e390600090815260ac6020526040902080546001909101549091565b9150915060015482146114385760405162461bcd60e51b815260206004820152601b60248201527f45786368616e6765526f757465723a2077726f6e6720636861696e00000000006044820152606401610c4a565b600081815260a6602052604090205460ff166114965760405162461bcd60e51b815260206004820181905260248201527f45786368616e6765526f757465723a20696e76616c696420636861696e2069646044820152606401610c4a565b600083815260096020908152604080832081516101408101835281548152600182015481850152600282015481840152600382015460ff808216151560608401526101009091046001600160a01b03166080830152600483015460a0830152600583015416151560c08201526006820180548451818702810187019095528085529194929360e086019390929083018282801561155c57602002820191906000526020600020905b81546001600160a01b0316815260019091019060200180831161153e575b50505091835250506007820154602080830191909152600892830154604092830152835160009081529290529020549091506001600160a01b0316806115e45760405162461bcd60e51b815260206004820152601d60248201527f45786368616e6765526f757465723a20696e76616c69642061707049640000006044820152606401610c4a565b61162589898080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250899250612367915050565b6101208201511561169e5760405162461bcd60e51b815260206004820152602760248201527f45786368616e6765526f757465723a2066696c6c6572206973206e6f7420737560448201527f70706f72746564000000000000000000000000000000000000000000000000006064820152608401610c4a565b6001548314156116f1576116ec818a8a8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152508a92508c91506127499050565b611745565b611745818a8a8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201829052508b815260a760205260409020600301548b93508d925090508861296d565b6001955050505050506117586001606f55565b949350505050565b6117686120a2565b610f6581612c39565b6117796120a2565b610f6581612cf2565b60008181526009602052604081206005015460ff166117a25760006117a5565b60015b92915050565b6117b36120a2565b610f6581612db3565b6117c46120a2565b6117ce8282612e74565b5050565b6117da6120a2565b6117ce8282612f10565b600a54610100900460ff16158080156118045750600a54600160ff909116105b8061181e5750303b15801561181e5750600a5460ff166001145b6118905760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201527f647920696e697469616c697a65640000000000000000000000000000000000006064820152608401610c4a565b600a805460ff1916600117905580156118b357600a805461ff0019166101001790555b6118bb612f71565b6118c3612fe4565b6001888155600089815260a660205260409020805460ff191690911790556118ea8a6121bd565b6118f389612c39565b6118fc86613057565b61190587613118565b61190e85612cf2565b611917846131d9565b611920836122a6565b611929826120fc565b801561196f57600a805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b50505050505050505050565b6000611985611fde565b600088815260096020908152604080832081516101408101835281548152600182015481850152600282015481840152600382015460ff808216151560608401526101009091046001600160a01b03166080830152600483015460a0830152600583015416151560c08201526006820180548451818702810187019095528085529194929360e0860193909290830182828015611a4b57602002820191906000526020600020905b81546001600160a01b03168152600190910190602001808311611a2d575b5050505050815260200160078201548152602001600882015481525050905060015460a760008b81526020019081526020016000206000015414158015611aa45750600089815260a7602052604090206001015460ff16155b611afa5760405162461bcd60e51b815260206004820152602160248201527f45786368616e6765526f757465723a20616c72656164792070726f63657373656044820152601960fa1b6064820152608401610c4a565b600089815260a760209081526040918290206001908101805460ff19169091179055608083015191516001600160a01b039092169173__$5188ca1ef01dc999a9b560e2e2728f759b$__916319e52d5491611b6191610ce9918f918f918f918f91016143c2565b6040516001600160e01b031960e084901b1681526004810191909152602481018990526044810188905260ff8716606482015260840160206040518083038186803b158015611baf57600080fd5b505af4158015611bc3573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611be79190613e59565b6001600160a01b031614611c3d5760405162461bcd60e51b815260206004820152601e60248201527f45786368616e6765526f757465723a20696e76616c6964207369676e657200006044820152606401610c4a565b80516000908152600860209081526040808320548c845260a79092528083206002015490517fb0bbcd8800000000000000000000000000000000000000000000000000000000815283926001600160a01b03169163b0bbcd8891611caf91908e908d90309042906001906004016146b2565b600060405180830381600087803b158015611cc957600080fd5b505af1158015611cdd573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052611d059190810190613e8f565b9150915081611d565760405162461bcd60e51b815260206004820152601b60248201527f45786368616e6765526f757465723a2073776170206661696c656400000000006044820152606401610c4a565b60008b815260a760205260409020548851611de091908a90611d7a9060019061478e565b81518110611d9857634e487b7160e01b600052603260045260246000fd5b60200260200101518360018551611daf919061478e565b81518110611dcd57634e487b7160e01b600052603260045260246000fd5b602002602001015186608001518d61329a565b60019350505050611df16001606f55565b979650505050505050565b611e046120a2565b604080518381526001600160a01b03831660208201527fca37a60f79854243dcab36b6ad6fcaafc7ae13448087ee70547943babc7dccf0910160405180910390a1600091825260a5602090815260408084206001600160a01b0390931684529190529020805460ff19166001179055565b611e7d6120a2565b610f6581613118565b611e8e6120a2565b610f6581613057565b611e9f6120a2565b6040518181527f11a9d1a77f76361ed131c19b1dc5758504c51dbde2e49fc973a0ef9577ad13d59060200160405180910390a1600090815260a660205260409020805460ff19169055565b611ef26120a2565b6040518181527fbba9d55e9fd1a441b1617724e2fdb76777d15ec77ab2b72ac15952cbe97085db9060200160405180910390a1600090815260a660205260409020805460ff19166001179055565b611f486120a2565b610f65816131d9565b611f596120a2565b6001600160a01b038116611fd55760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152608401610c4a565b610f65816133fc565b6002606f5414156120315760405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c006044820152606401610c4a565b6002606f55565b6000818051906020012060405160200161207e91907f19457468657265756d205369676e6564204d6573736167653a0a3332000000008152601c810191909152603c0190565b604051602081830303815290604052805190602001209050919050565b6001606f55565b603d546001600160a01b031633146110a65760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610c4a565b806001600160a01b0381166121535760405162461bcd60e51b815260206004820152601c60248201527f45786368616e6765526f757465723a207a65726f2061646472657373000000006044820152606401610c4a565b60aa54604080516001600160a01b03928316815291841660208301527f5b663d57fa8cf393f8c8019f514b25c1b3223c9324a2ce3efe28ce5aef0e62fe910160405180910390a15060aa80546001600160a01b0319166001600160a01b0392909216919091179055565b60005481116122345760405162461bcd60e51b815260206004820152602960248201527f434345786368616e6765526f757465723a206c6f77207374617274696e67426c60448201527f6f636b4e756d62657200000000000000000000000000000000000000000000006064820152608401610c4a565b600055565b60408051828152602081018590529081018390527fd4d81e1736e6dd2e97d0c6eff0dc7ec7184dec2bd4e03ce98d84d6057a8045c49060600160405180910390a16040805180820182529384526020808501938452600092835260ac905290209151825551600190910155565b806001600160a01b0381166122fd5760405162461bcd60e51b815260206004820152601c60248201527f45786368616e6765526f757465723a207a65726f2061646472657373000000006044820152606401610c4a565b60a854604080516001600160a01b03928316815291841660208301527f06e5f2ca1234f717a2031f662608c02182d4f8bdc3dab013ec4c04eb97553132910160405180910390a15060a880546001600160a01b0319166001600160a01b0392909216919091179055565b6005546000828152600960205260408082206001015490517f1fcfe19c00000000000000000000000000000000000000000000000000000000815291926001600160a01b031691631fcfe19c916123c4918791309160040161451a565b602060405180830381600087803b1580156123de57600080fd5b505af11580156123f2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906124169190613f4a565b6002546000848152600960205260409020600101549192506127109161243c919061476f565b612446919061474f565b600083815260a76020908152604080832060058101949094556009808352818420600480820154960154855260ad8452918420549387905290915260010154612710916124929161476f565b61249c919061474f565b600084815260a760209081526040808320600601939093556009905220600101546124c890839061478e565b600084815260a760205260409020600701558015612574576006546001600160a01b031663a9059cbb336040516001600160e01b031960e084901b1681526001600160a01b03909116600482015260248101849052604401602060405180830381600087803b15801561253a57600080fd5b505af115801561254e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906125729190613e75565b505b600083815260a760205260409020600501541561262957600654600754600085815260a760205260409081902060050154905163a9059cbb60e01b81526001600160a01b039283166004820152602481019190915291169063a9059cbb90604401602060405180830381600087803b1580156125ef57600080fd5b505af1158015612603573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906126279190613e75565b505b600083815260a76020526040902060060154156126f55760068054600085815260a760208181526040808420600480820154865260ae845282862054958b905293909252940154935163a9059cbb60e01b81526001600160a01b03928316918101919091526024810193909352169063a9059cbb90604401602060405180830381600087803b1580156126bb57600080fd5b505af11580156126cf573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906126f39190613e75565b505b600083815260a7602052604090206006810154600590910154829061271a908561478e565b612724919061478e565b61272e919061478e565b600093845260a7602052604090932060020192909255505050565b600180546000848152600960209081526040808320815161014081018352815481529581015486840152600281015486830152600381015460ff808216151560608901526101009091046001600160a01b03166080880152600482015460a0880152600582015416151560c0870152600681018054835181860281018601909452808452949687966128ad9690958c9592949360e086019392909183018282801561281d57602002820191906000526020600020905b81546001600160a01b031681526001909101906020018083116127ff575b505050918352505060078281015460208084019190915260089093015460409283015260008b815260a7845282902082516101008101845281548152600182015460ff161515948101949094526002810154928401929092526003820154606084015260048201546080840152600582015460a0840152600682015460c0840152015460e082015288888c61344e565b91509150816129655760065460008581526009602090815260408083206003015460a79092529182902060020154915163a9059cbb60e01b81526101009091046001600160a01b039081166004830152602482019290925291169063a9059cbb90604401602060405180830381600087803b15801561292b57600080fd5b505af115801561293f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906129639190613e75565b505b505050505050565b600084815260096020908152604080832081516101408101835281548152600182015481850152600282015481840152600382015460ff808216151560608401526101009091046001600160a01b03166080830152600483015460a0830152600583015416151560c08201526006820180548451818702810187019095528085528695612ac99589958e9594909360e0860193830182828015612a3957602002820191906000526020600020905b81546001600160a01b03168152600190910190602001808311612a1b575b505050918352505060078281015460208084019190915260089093015460409283015260008d815260a7845282902082516101008101845281548152600182015460ff161515948101949094526002810154928401929092526003820154606084015260048201546080840152600582015460a0840152600682015460c0840152015460e08201528a8a8e61344e565b915091508115612b9457600086815260a7602052604090206001818101805460ff19168217905590548651612b8f928891612b04919061478e565b81518110612b2257634e487b7160e01b600052603260045260246000fd5b60200260200101518360018551612b39919061478e565b81518110612b5757634e487b7160e01b600052603260045260246000fd5b6020026020010151600960008b815260200190815260200160002060030160019054906101000a90046001600160a01b03168861329a565b612c2f565b600654600087815260a760205260409081902060020154905163095ea7b360e01b81526001600160a01b038b81166004830152602482019290925291169063095ea7b390604401602060405180830381600087803b158015612bf557600080fd5b505af1158015612c09573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612c2d9190613e75565b505b5050505050505050565b806127101015612cb15760405162461bcd60e51b815260206004820152602560248201527f434345786368616e6765526f757465723a20666565206973206f7574206f662060448201527f72616e67650000000000000000000000000000000000000000000000000000006064820152608401610c4a565b60025460408051918252602082018390527f7d205f60891f60851c61cd244ba387d72b6589e7c0ac41b9d909ab0ce2c2a53b910160405180910390a1600255565b806001600160a01b038116612d495760405162461bcd60e51b815260206004820152601c60248201527f45786368616e6765526f757465723a207a65726f2061646472657373000000006044820152606401610c4a565b600654604080516001600160a01b03928316815291841660208301527f36a4c08a38b736dcecb6c328dba61238529620e83ccb23db2cc43cd34ec26096910160405180910390a150600680546001600160a01b0319166001600160a01b0392909216919091179055565b806001600160a01b038116612e0a5760405162461bcd60e51b815260206004820152601c60248201527f45786368616e6765526f757465723a207a65726f2061646472657373000000006044820152606401610c4a565b600454604080516001600160a01b03928316815291841660208301527f12ad124e13af4c31364ad22aa74320e167b37f005dafb75d71a210c49da3629e910160405180910390a150600480546001600160a01b0319166001600160a01b0392909216919091179055565b600082815260ae6020526040908190205490517f1e73962bcff5b98a9ac70c9b0f71fbb31dc0f5a09348c6d3ceab164169a9e72991612eda9185916001600160a01b03169085909283526001600160a01b03918216602084015216604082015260600190565b60405180910390a1600091825260ae602052604090912080546001600160a01b0319166001600160a01b03909216919091179055565b600082815260ad6020908152604091829020548251858152918201529081018290527f188adabf806a6b6d814acc1dbd9f09e5a251c8c065d6285749a5824e4579b6459060600160405180910390a1600091825260ad602052604090912055565b600a54610100900460ff16612fdc5760405162461bcd60e51b815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201526a6e697469616c697a696e6760a81b6064820152608401610c4a565b6110a6613bf7565b600a54610100900460ff1661304f5760405162461bcd60e51b815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201526a6e697469616c697a696e6760a81b6064820152608401610c4a565b6110a6613c6b565b806001600160a01b0381166130ae5760405162461bcd60e51b815260206004820152601c60248201527f45786368616e6765526f757465723a207a65726f2061646472657373000000006044820152606401610c4a565b600354604080516001600160a01b03928316815291841660208301527f4c28a3f61a715259c4dc930c23e7423b8fa52e13232c061a6e488729c66184f4910160405180910390a150600380546001600160a01b0319166001600160a01b0392909216919091179055565b806001600160a01b03811661316f5760405162461bcd60e51b815260206004820152601c60248201527f45786368616e6765526f757465723a207a65726f2061646472657373000000006044820152606401610c4a565b600554604080516001600160a01b03928316815291841660208301527ffa021c2ec0f46429a53e7f88b88065e40001f50c9d38b2e8b713beaf9828d4c3910160405180910390a150600580546001600160a01b0319166001600160a01b0392909216919091179055565b806001600160a01b0381166132305760405162461bcd60e51b815260206004820152601c60248201527f45786368616e6765526f757465723a207a65726f2061646472657373000000006044820152606401610c4a565b600754604080516001600160a01b03928316815291841660208301527f567657fa3f286518b318f4a29870674f433f622fdfc819691acb13105b228225910160405180910390a150600780546001600160a01b0319166001600160a01b0392909216919091179055565b60a85460405163095ea7b360e01b81526001600160a01b039182166004820152602481018590529085169063095ea7b390604401602060405180830381600087803b1580156132e857600080fd5b505af11580156132fc573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906133209190613e75565b5060a8546001600160a01b0316631186ec3383868661333e8a611007565b6040516001600160e01b031960e087901b1681526001600160a01b03948516600482015293909216602484015260448301526064820152600784900b608482015263ffffffff421660a482015261010060c482015260026101048201527f307800000000000000000000000000000000000000000000000000000000000061012482015260001960e482015261014401600060405180830381600087803b1580156133e857600080fd5b505af1158015612c2d573d6000803e3d6000fd5b603d80546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b600060606001548914806134c45750600089815260a5602052604081208551909190869061347e9060019061478e565b8151811061349c57634e487b7160e01b600052603260045260246000fd5b6020908102919091018101516001600160a01b031682528101919091526040016000205460ff165b1561385157600654604087810151905163095ea7b360e01b81526001600160a01b038681166004830152602482019290925291169063095ea7b390604401602060405180830381600087803b15801561351c57600080fd5b505af1158015613530573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906135549190613e75565b506040517f9b4bca240000000000000000000000000000000000000000000000000000000081526001600160a01b03841690639b4bca249061359a9087906004016144ad565b60206040518083038186803b1580156135b257600080fd5b505afa1580156135c6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906135ea9190613e75565b1561384c5760065484516001600160a01b0390911690859060009061361f57634e487b7160e01b600052603260045260246000fd5b60200260200101516001600160a01b03161480156136ba575060e0870151805161364b9060019061478e565b8151811061366957634e487b7160e01b600052603260045260246000fd5b60200260200101516001600160a01b03168460018651613689919061478e565b815181106136a757634e487b7160e01b600052603260045260246000fd5b60200260200101516001600160a01b0316145b6137065760405162461bcd60e51b815260206004820152601e60248201527f436345786368616e6765526f757465723a20696e76616c6964207061746800006044820152606401610c4a565b826001600160a01b031663b0bbcd8887604001518960400151878b608001514260016040518763ffffffff1660e01b8152600401613749969594939291906146b2565b600060405180830381600087803b15801561376357600080fd5b505af1158015613777573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261379f9190810190613e8f565b90925090508161384c57826001600160a01b031663b0bbcd88876040015189604001518a60e001518b608001514260016040518763ffffffff1660e01b81526004016137f0969594939291906146b2565b600060405180830381600087803b15801561380a57600080fd5b505af115801561381e573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526138469190810190613e8f565b90925090505b613856565b600091505b60006040518060a001604052808960a0015181526020018860e0015181526020018860a0015181526020018860c001518152602001886060015181525090508215613a7057336001600160a01b031688610120015189608001516001600160a01b03167f9a89a1f930026d8c37eac8e47828d2019fb5076a7eea6314919dfc8426f894dd600560009054906101000a90046001600160a01b03166001600160a01b031663c4d10b6a8e6040518263ffffffff1660e01b815260040161391b9190614507565b60206040518083038186803b15801561393357600080fd5b505afa158015613947573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061396b9190613e59565b604080518082019091526006546001600160a01b031681528a5160208201908c906139989060019061478e565b815181106139b657634e487b7160e01b600052603260045260246000fd5b60200260200101516001600160a01b03166001600160a01b03168152506040518060400160405280896000815181106139ff57634e487b7160e01b600052603260045260246000fd5b602002602001015181526020018960018b51613a1b919061478e565b81518110613a3957634e487b7160e01b600052603260045260246000fd5b60200260200101518152508c8f600001518f608001518a604051613a639796959493929190614413565b60405180910390a4613bea565b336001600160a01b031688610120015189608001516001600160a01b03167f2f2349a4438effe698d654ac41a4f96349f503bd1e6f48dac5c8cd74f8d4d11f600560009054906101000a90046001600160a01b03166001600160a01b031663c4d10b6a8e6040518263ffffffff1660e01b8152600401613af09190614507565b60206040518083038186803b158015613b0857600080fd5b505afa158015613b1c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613b409190613e59565b604080518082019091526006546001600160a01b031681528a5160208201908c90613b6d9060019061478e565b81518110613b8b57634e487b7160e01b600052603260045260246000fd5b60200260200101516001600160a01b03166001600160a01b031681525060405180604001604052808e60400151815260200160008152508c8f600001518f608001518a604051613be19796959493929190614413565b60405180910390a45b5097509795505050505050565b600a54610100900460ff16613c625760405162461bcd60e51b815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201526a6e697469616c697a696e6760a81b6064820152608401610c4a565b6110a6336133fc565b600a54610100900460ff1661209b5760405162461bcd60e51b815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201526a6e697469616c697a696e6760a81b6064820152608401610c4a565b600082601f830112613ce6578081fd5b81356020613cfb613cf68361472b565b6146fa565b8281528181019085830183850287018401881015613d17578586fd5b855b85811015613d3e578135613d2c816147d1565b84529284019290840190600101613d19565b5090979650505050505050565b8051801515811461101a57600080fd5b80356001600160e01b03198116811461101a57600080fd5b60008083601f840112613d84578182fd5b50813567ffffffffffffffff811115613d9b578182fd5b602083019150836020828501011115613db357600080fd5b9250929050565b600082601f830112613dca578081fd5b813567ffffffffffffffff811115613de457613de46147bb565b613df7601f8201601f19166020016146fa565b818152846020838601011115613e0b578283fd5b816020850160208301379081016020019190915292915050565b803560ff8116811461101a57600080fd5b600060208284031215613e47578081fd5b8135613e52816147d1565b9392505050565b600060208284031215613e6a578081fd5b8151613e52816147d1565b600060208284031215613e86578081fd5b613e5282613d4b565b60008060408385031215613ea1578081fd5b613eaa83613d4b565b915060208084015167ffffffffffffffff811115613ec6578283fd5b8401601f81018613613ed6578283fd5b8051613ee4613cf68261472b565b81815283810190838501858402850186018a1015613f00578687fd5b8694505b83851015613f22578051835260019490940193918501918501613f04565b5080955050505050509250929050565b600060208284031215613f43578081fd5b5035919050565b600060208284031215613f5b578081fd5b5051919050565b60008060408385031215613f74578182fd5b823591506020830135613f86816147d1565b809150509250929050565b600080600080600080600060e0888a031215613fab578283fd5b873596506020880135955060408801359450606088013567ffffffffffffffff811115613fd6578384fd5b613fe28a828b01613cd6565b9450506080880135925060a08801359150613fff60c08901613e25565b905092959891949750929550565b60008060008060008060008060006101008a8c03121561402b578283fd5b8935985061403b60208b01613e25565b975060408a013567ffffffffffffffff80821115614057578485fd5b6140638d838e01613dba565b985060608c0135975060808c0135965060a08c0135955061408660c08d01613e25565b945060e08c013591508082111561409b578384fd5b506140a88c828d01613d73565b915080935050809150509295985092959850929598565b600080600080606085870312156140d4578182fd5b843567ffffffffffffffff808211156140eb578384fd5b9086019060e082890312156140fe578384fd5b61410860e06146fa565b61411183613d5b565b8152602083013582811115614124578586fd5b6141308a828601613dba565b602083015250604083013582811115614147578586fd5b6141538a828601613dba565b60408301525061416560608401613d5b565b60608201526080830135608082015260a083013582811115614185578586fd5b6141918a828601613dba565b60a08301525060c083013560c08201528096505060208701359150808211156141b8578384fd5b6141c488838901613d73565b909550935060408701359150808211156141dc578283fd5b506141e987828801613cd6565b91505092959194509250565b60008060408385031215614207578182fd5b50508035926020909101359150565b60008060006060848603121561422a578081fd5b505081359360208301359350604090920135919050565b60008060008060008060008060006101208a8c03121561425f578283fd5b8935985060208a0135975060408a0135965060608a013561427f816147d1565b955060808a013561428f816147d1565b945060a08a013561429f816147d1565b935060c08a01356142af816147d1565b925060e08a01356142bf816147d1565b91506101008a01356142d0816147d1565b809150509295985092959850929598565b6000815180845260208085019450808401835b838110156143195781516001600160a01b0316875295820195908201906001016142f4565b509495945050505050565b8060005b6005811015614347578151845260209384019390910190600101614328565b50505050565b60008284528282602086013780602084860101526020601f19601f85011685010190509392505050565b60008151808452815b8181101561439c57602081850181015186830182015201614380565b818111156143ad5782602083870101525b50601f01601f19169290920160200192915050565b600085825260208581840152846040840152606083018451828601845b828110156144045781516001600160a01b0316845292840192908401906001016143df565b50919998505050505050505050565b6001600160a01b03881681526101a0810160208083018960005b60028110156144555781516001600160a01b031683526020830192509083019060010161442d565b505050606083018860005b600281101561447d57815183529183019190830190600101614460565b505050508560a08301528460c08301528360e08301526144a1610100830184614324565b98975050505050505050565b600060208252613e5260208301846142e1565b600085825260ff85166020830152608060408301526144e26080830185614377565b905082606083015295945050505050565b60006020825261175860208301848661434d565b600060208252613e526020830184614377565b60006060825261452d6060830186614377565b6001600160a01b039490941660208301525060400152919050565b600061010082526001600160e01b0319808c511661010084015260208c015160e061012085015261457d6101e0850182614377565b905060408d015160ff198583030161014086015261459b8282614377565b60608f0151909316610160860152505060808c015161018084015260a08c015183820360ff19016101a0850152906145d38183614377565b91505060c08c01516101c08401528a6020840152896040840152614602606084018a6001600160a01b03169052565b6001600160a01b03881660808401528660a084015282810360c084015261462a81868861434d565b91505061464260e08301846001600160a01b03169052565b9a9950505050505050505050565b600087825260a0602083015261466960a0830188614377565b6006871061468557634e487b7160e01b82526021600452602482fd5b866040840152828103606084015261469e81868861434d565b915050826080830152979650505050505050565b600087825286602083015260c060408301526146d160c08301876142e1565b6001600160a01b03959095166060830152506080810192909252151560a0909101529392505050565b604051601f8201601f1916810167ffffffffffffffff81118282101715614723576147236147bb565b604052919050565b600067ffffffffffffffff821115614745576147456147bb565b5060209081020190565b60008261476a57634e487b7160e01b81526012600452602481fd5b500490565b6000816000190483118215151615614789576147896147a5565b500290565b6000828210156147a0576147a06147a5565b500390565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052604160045260246000fd5b6001600160a01b0381168114610f6557600080fdfea2646970667358221220af52952296658ab74558844b8f584424d9caaa121d01379a54578f9febdb935b64736f6c63430008020033",
  "libraries": {
    "CcExchangeRouterLib": "0xE66AC01F73AE3cE8e7A0CFf5dB5A40388B354e74"
  },
  "devdoc": {
    "kind": "dev",
    "methods": {
      "initialize(uint256,uint256,uint256,address,address,address,address,address,address)": {
        "params": {
          "_chainId": "Id of the target chain",
          "_lockers": "Lockers' contract address",
          "_protocolPercentageFee": "Percentage amount of protocol fee (min: %0.01)",
          "_relay": "The Relay address to validate data from source chain",
          "_startingBlockNumber": "Requests that are included in a block older                              than _startingBlockNumber cannot be executed",
          "_teleBTC": "TeleportDAO BTC ERC20 token address",
          "_treasury": "Address of treasury that collects protocol fees"
        }
      },
      "isRequestUsed(bytes32)": {
        "details": "It prevents re-submitting an executed request",
        "params": {
          "_txId": "The transaction ID of request on Bitcoin "
        },
        "returns": {
          "_0": "True if the cc exchange request has been already executed"
        }
      },
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."
      },
      "retryFailedWrapAndSwap(bytes32,uint256,uint256,address[],bytes32,bytes32,uint8)": {
        "params": {
          "_acrossRelayerFee": "Fee that user pays to across relayer",
          "_outputAmount": "Amount of output token",
          "_r": "Signature r",
          "_s": "Signature s",
          "_txId": "The transaction ID of request on Bitcoin",
          "_v": "Signature v",
          "path": "Exchange path from teleBTC to the output token"
        }
      },
      "setChainIdMapping(uint256,uint256,uint256)": {
        "details": "Only owner can call this"
      },
      "setExchangeConnector(uint256,address)": {
        "details": "_exchangeConnector can be set to zero to inactive an app"
      },
      "setInstantRouter(address)": {
        "details": "Only owner can call this",
        "params": {
          "_instantRouter": "The new instantRouter contract address"
        }
      },
      "setThirdPartyAddress(uint256,address)": {
        "details": "Only owner can call this",
        "params": {
          "_thirdPartyAddress": "third party address"
        }
      },
      "setThirdPartyFee(uint256,uint256)": {
        "details": "Only owner can call this",
        "params": {
          "_thirdPartyFee": "third party fee"
        }
      },
      "transferOwnership(address)": {
        "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      },
      "withdrawFailedWrapAndSwap(bytes32,uint8,bytes,uint256,bytes32,bytes32,uint8,bytes)": {
        "params": {
          "_acrossRelayerFee": "Fee that user pays to across relayer",
          "_lockerLockingScript": "Script hash of locker that user has sent BTC to it",
          "_r": "Signature r",
          "_s": "Signature s",
          "_scriptType": "Script type of the user script",
          "_txId": "The transaction ID of request on Bitcoin",
          "_userScript": "Script hash of the user on Bitcoin",
          "_v": "Signature v"
        },
        "returns": {
          "_0": ""
        }
      },
      "wrapAndSwap((bytes4,bytes,bytes,bytes4,uint256,bytes,uint256),bytes,address[])": {
        "details": "Mints teleBTC for user if exchanging is not successful",
        "params": {
          "_lockerLockingScript": "Script hash of locker that user has sent BTC to it",
          "_path": "(Optional) Exchange path from teleBTC to the output token. This is used if               the default path [teleBTC, wrappedNativeToken, outputToken] not exist or              exchanging using this path fails",
          "_txAndProof": "Transaction and merkle proof data"
        },
        "returns": {
          "_0": "true "
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "events": {
      "FailedWrapAndSwap(address,address,address[2],uint256[2],uint256,address,bytes32,uint256,uint256,uint256[5])": {
        "notice": "Emits when a cc exchange request fails"
      },
      "FillStarted(bytes32,uint256)": {
        "notice": "Emits when a request is filled for the first time"
      },
      "FillTeleBtcSent(uint256,uint256,address,address,uint256,bytes32,uint256,uint256)": {
        "notice": "Emits when filler withdraws teleBTC"
      },
      "FillTokensReturned(uint256,address,address,uint256,bytes32)": {
        "notice": "Emits when unused tokens withdrawn"
      },
      "NewChainIdMapping(uint256,uint256,uint256)": {
        "notice": "Emits when changes made to chain id mapping"
      },
      "NewFill(address,bytes32,address,uint256)": {
        "notice": "Emits when a new filler fills a request"
      },
      "NewInstantRouter(address,address)": {
        "notice": "Emits when instant router contract updated"
      },
      "NewLockers(address,address)": {
        "notice": "Emits when lockers contract updated"
      },
      "NewProtocolPercentageFee(uint256,uint256)": {
        "notice": "Emits when protocol fee updated"
      },
      "NewRelay(address,address)": {
        "notice": "Emits when relay contract updated"
      },
      "NewTeleBTC(address,address)": {
        "notice": "Emits when telebtc contract updated"
      },
      "NewThirdPartyAddress(uint256,address,address)": {
        "notice": "Emits when changes made to third party address"
      },
      "NewThirdPartyFee(uint256,uint256,uint256)": {
        "notice": "Emits when changes made to third party fee"
      },
      "NewTreasury(address,address)": {
        "notice": "Emits when treasury address updated"
      },
      "NewWrapAndSwap(address,address,address[2],uint256[2],uint256,address,bytes32,uint256,uint256,uint256[5])": {
        "notice": "Emits when a cc exchange request gets done"
      },
      "SetExchangeConnector(uint256,address)": {
        "notice": "Emits when appId for an exchange connector is set"
      }
    },
    "kind": "user",
    "methods": {
      "initialize(uint256,uint256,uint256,address,address,address,address,address,address)": {
        "notice": "Gives default params to initiate cc exchange router"
      },
      "isRequestUsed(bytes32)": {
        "notice": "Checks if a request has been executed before"
      },
      "removeChain(uint256)": {
        "notice": "Removing a chainId"
      },
      "removeToken(uint256,address)": {
        "notice": "Removing a token as supported token on specific chain"
      },
      "retryFailedWrapAndSwap(bytes32,uint256,uint256,address[],bytes32,bytes32,uint8)": {
        "notice": "ETH user whose exchange request failed can retry          to exchange teleBTC for the desired token"
      },
      "setAcross(address)": {
        "notice": "Setter for across"
      },
      "setBurnRouter(address)": {
        "notice": "Setter for burnRouters"
      },
      "setChainIdMapping(uint256,uint256,uint256)": {
        "notice": "Setter for chain id mapping"
      },
      "setExchangeConnector(uint256,address)": {
        "notice": "Sets appId for an exchange connector"
      },
      "setInstantRouter(address)": {
        "notice": "Changes instantRouter contract address"
      },
      "setLockers(address)": {
        "notice": "Updates lockers contract address"
      },
      "setProtocolPercentageFee(uint256)": {
        "notice": "Setter for protocol percentage fee"
      },
      "setRelay(address)": {
        "notice": "Updates relay contract address"
      },
      "setStartingBlockNumber(uint256)": {
        "notice": "Setter for starting block number"
      },
      "setTeleBTC(address)": {
        "notice": "Updates teleBTC contract address"
      },
      "setThirdPartyAddress(uint256,address)": {
        "notice": "Setter for third party address"
      },
      "setThirdPartyFee(uint256,uint256)": {
        "notice": "Setter for third party fee"
      },
      "setTreasury(address)": {
        "notice": "Setter for treasury"
      },
      "supportChain(uint256)": {
        "notice": "Adding a new chainId"
      },
      "supportToken(uint256,address)": {
        "notice": "Adding a token as supported token on specific chain"
      },
      "withdrawFailedWrapAndSwap(bytes32,uint8,bytes,uint256,bytes32,bytes32,uint8,bytes)": {
        "notice": "ETH user whose request failed can redeem teleBTC for native BTC"
      },
      "wrapAndSwap((bytes4,bytes,bytes,bytes4,uint256,bytes,uint256),bytes,address[])": {
        "notice": "Executes a cross-chain exchange request after checking its merkle inclusion proof"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 22450,
        "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
        "label": "startingBlockNumber",
        "offset": 0,
        "slot": "0",
        "type": "t_uint256"
      },
      {
        "astId": 22453,
        "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
        "label": "chainId",
        "offset": 0,
        "slot": "1",
        "type": "t_uint256"
      },
      {
        "astId": 22456,
        "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
        "label": "protocolPercentageFee",
        "offset": 0,
        "slot": "2",
        "type": "t_uint256"
      },
      {
        "astId": 22459,
        "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
        "label": "relay",
        "offset": 0,
        "slot": "3",
        "type": "t_address"
      },
      {
        "astId": 22462,
        "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
        "label": "instantRouter",
        "offset": 0,
        "slot": "4",
        "type": "t_address"
      },
      {
        "astId": 22465,
        "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
        "label": "lockers",
        "offset": 0,
        "slot": "5",
        "type": "t_address"
      },
      {
        "astId": 22468,
        "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
        "label": "teleBTC",
        "offset": 0,
        "slot": "6",
        "type": "t_address"
      },
      {
        "astId": 22471,
        "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
        "label": "treasury",
        "offset": 0,
        "slot": "7",
        "type": "t_address"
      },
      {
        "astId": 22476,
        "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
        "label": "exchangeConnector",
        "offset": 0,
        "slot": "8",
        "type": "t_mapping(t_uint256,t_address)"
      },
      {
        "astId": 22481,
        "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
        "label": "ccExchangeRequests",
        "offset": 0,
        "slot": "9",
        "type": "t_mapping(t_bytes32,t_struct(ccExchangeRequest)25632_storage)"
      },
      {
        "astId": 442,
        "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
        "label": "_initialized",
        "offset": 0,
        "slot": "10",
        "type": "t_uint8"
      },
      {
        "astId": 445,
        "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
        "label": "_initializing",
        "offset": 1,
        "slot": "10",
        "type": "t_bool"
      },
      {
        "astId": 1844,
        "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
        "label": "__gap",
        "offset": 0,
        "slot": "11",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 314,
        "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
        "label": "_owner",
        "offset": 0,
        "slot": "61",
        "type": "t_address"
      },
      {
        "astId": 434,
        "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
        "label": "__gap",
        "offset": 0,
        "slot": "62",
        "type": "t_array(t_uint256)49_storage"
      },
      {
        "astId": 745,
        "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
        "label": "_status",
        "offset": 0,
        "slot": "111",
        "type": "t_uint256"
      },
      {
        "astId": 803,
        "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
        "label": "__gap",
        "offset": 0,
        "slot": "112",
        "type": "t_array(t_uint256)49_storage"
      },
      {
        "astId": 22495,
        "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
        "label": "fillerWithdrawInterval",
        "offset": 0,
        "slot": "161",
        "type": "t_uint256"
      },
      {
        "astId": 22502,
        "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
        "label": "fillersData",
        "offset": 0,
        "slot": "162",
        "type": "t_mapping(t_bytes32,t_mapping(t_address,t_struct(FillerData)25682_storage))"
      },
      {
        "astId": 22509,
        "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
        "label": "prefixFillSums",
        "offset": 0,
        "slot": "163",
        "type": "t_mapping(t_bytes32,t_mapping(t_address,t_struct(PrefixFillSum)25688_storage))"
      },
      {
        "astId": 22514,
        "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
        "label": "fillsData",
        "offset": 0,
        "slot": "164",
        "type": "t_mapping(t_bytes32,t_struct(FillData)25675_storage)"
      },
      {
        "astId": 22521,
        "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
        "label": "isTokenSupported",
        "offset": 0,
        "slot": "165",
        "type": "t_mapping(t_uint256,t_mapping(t_address,t_bool))"
      },
      {
        "astId": 22526,
        "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
        "label": "isChainSupported",
        "offset": 0,
        "slot": "166",
        "type": "t_mapping(t_uint256,t_bool)"
      },
      {
        "astId": 22531,
        "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
        "label": "extendedCcExchangeRequests",
        "offset": 0,
        "slot": "167",
        "type": "t_mapping(t_bytes32,t_struct(extendedCcExchangeRequest)25649_storage)"
      },
      {
        "astId": 22534,
        "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
        "label": "across",
        "offset": 0,
        "slot": "168",
        "type": "t_address"
      },
      {
        "astId": 22536,
        "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
        "label": "wrappedNativeToken",
        "offset": 0,
        "slot": "169",
        "type": "t_address"
      },
      {
        "astId": 22539,
        "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
        "label": "burnRouter",
        "offset": 0,
        "slot": "170",
        "type": "t_address"
      },
      {
        "astId": 22541,
        "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
        "label": "wmatic",
        "offset": 0,
        "slot": "171",
        "type": "t_address"
      },
      {
        "astId": 22546,
        "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
        "label": "chainIdMapping",
        "offset": 0,
        "slot": "172",
        "type": "t_mapping(t_uint256,t_struct(chainIdStruct)25610_storage)"
      },
      {
        "astId": 22550,
        "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
        "label": "thirdPartyFee",
        "offset": 0,
        "slot": "173",
        "type": "t_mapping(t_uint256,t_uint256)"
      },
      {
        "astId": 22554,
        "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
        "label": "thirdPartyAddress",
        "offset": 0,
        "slot": "174",
        "type": "t_mapping(t_uint256,t_address)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_address)dyn_storage": {
        "base": "t_address",
        "encoding": "dynamic_array",
        "label": "address[]",
        "numberOfBytes": "32"
      },
      "t_array(t_uint256)49_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[49]",
        "numberOfBytes": "1568"
      },
      "t_array(t_uint256)50_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[50]",
        "numberOfBytes": "1600"
      },
      "t_array(t_uint256)dyn_storage": {
        "base": "t_uint256",
        "encoding": "dynamic_array",
        "label": "uint256[]",
        "numberOfBytes": "32"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_address,t_struct(FillerData)25682_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct ICcExchangeRouter.FillerData)",
        "numberOfBytes": "32",
        "value": "t_struct(FillerData)25682_storage"
      },
      "t_mapping(t_address,t_struct(PrefixFillSum)25688_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct ICcExchangeRouter.PrefixFillSum)",
        "numberOfBytes": "32",
        "value": "t_struct(PrefixFillSum)25688_storage"
      },
      "t_mapping(t_bytes32,t_mapping(t_address,t_struct(FillerData)25682_storage))": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => mapping(address => struct ICcExchangeRouter.FillerData))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_struct(FillerData)25682_storage)"
      },
      "t_mapping(t_bytes32,t_mapping(t_address,t_struct(PrefixFillSum)25688_storage))": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => mapping(address => struct ICcExchangeRouter.PrefixFillSum))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_struct(PrefixFillSum)25688_storage)"
      },
      "t_mapping(t_bytes32,t_struct(FillData)25675_storage)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => struct ICcExchangeRouter.FillData)",
        "numberOfBytes": "32",
        "value": "t_struct(FillData)25675_storage"
      },
      "t_mapping(t_bytes32,t_struct(ccExchangeRequest)25632_storage)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => struct ICcExchangeRouter.ccExchangeRequest)",
        "numberOfBytes": "32",
        "value": "t_struct(ccExchangeRequest)25632_storage"
      },
      "t_mapping(t_bytes32,t_struct(extendedCcExchangeRequest)25649_storage)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => struct ICcExchangeRouter.extendedCcExchangeRequest)",
        "numberOfBytes": "32",
        "value": "t_struct(extendedCcExchangeRequest)25649_storage"
      },
      "t_mapping(t_uint256,t_address)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_uint256,t_bool)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_uint256,t_mapping(t_address,t_bool))": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => mapping(address => bool))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_bool)"
      },
      "t_mapping(t_uint256,t_struct(chainIdStruct)25610_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct ICcExchangeRouter.chainIdStruct)",
        "numberOfBytes": "32",
        "value": "t_struct(chainIdStruct)25610_storage"
      },
      "t_mapping(t_uint256,t_uint256)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_struct(FillData)25675_storage": {
        "encoding": "inplace",
        "label": "struct ICcExchangeRouter.FillData",
        "members": [
          {
            "astId": 25666,
            "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
            "label": "startingTime",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 25668,
            "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
            "label": "reqToken",
            "offset": 0,
            "slot": "1",
            "type": "t_address"
          },
          {
            "astId": 25670,
            "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
            "label": "lastUsedIdx",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          },
          {
            "astId": 25672,
            "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
            "label": "remainingAmountOfLastFill",
            "offset": 0,
            "slot": "3",
            "type": "t_uint256"
          },
          {
            "astId": 25674,
            "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
            "label": "isWithdrawnLastFill",
            "offset": 0,
            "slot": "4",
            "type": "t_bool"
          }
        ],
        "numberOfBytes": "160"
      },
      "t_struct(FillerData)25682_storage": {
        "encoding": "inplace",
        "label": "struct ICcExchangeRouter.FillerData",
        "members": [
          {
            "astId": 25677,
            "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
            "label": "index",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 25679,
            "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
            "label": "token",
            "offset": 0,
            "slot": "1",
            "type": "t_address"
          },
          {
            "astId": 25681,
            "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
            "label": "amount",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "96"
      },
      "t_struct(PrefixFillSum)25688_storage": {
        "encoding": "inplace",
        "label": "struct ICcExchangeRouter.PrefixFillSum",
        "members": [
          {
            "astId": 25685,
            "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
            "label": "prefixSum",
            "offset": 0,
            "slot": "0",
            "type": "t_array(t_uint256)dyn_storage"
          },
          {
            "astId": 25687,
            "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
            "label": "currentIndex",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(ccExchangeRequest)25632_storage": {
        "encoding": "inplace",
        "label": "struct ICcExchangeRouter.ccExchangeRequest",
        "members": [
          {
            "astId": 25612,
            "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
            "label": "appId",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 25614,
            "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
            "label": "inputAmount",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 25616,
            "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
            "label": "outputAmount",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          },
          {
            "astId": 25618,
            "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
            "label": "isFixedToken",
            "offset": 0,
            "slot": "3",
            "type": "t_bool"
          },
          {
            "astId": 25620,
            "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
            "label": "recipientAddress",
            "offset": 1,
            "slot": "3",
            "type": "t_address"
          },
          {
            "astId": 25622,
            "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
            "label": "fee",
            "offset": 0,
            "slot": "4",
            "type": "t_uint256"
          },
          {
            "astId": 25624,
            "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
            "label": "isUsed",
            "offset": 0,
            "slot": "5",
            "type": "t_bool"
          },
          {
            "astId": 25627,
            "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
            "label": "path",
            "offset": 0,
            "slot": "6",
            "type": "t_array(t_address)dyn_storage"
          },
          {
            "astId": 25629,
            "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
            "label": "deadline",
            "offset": 0,
            "slot": "7",
            "type": "t_uint256"
          },
          {
            "astId": 25631,
            "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
            "label": "speed",
            "offset": 0,
            "slot": "8",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "288"
      },
      "t_struct(chainIdStruct)25610_storage": {
        "encoding": "inplace",
        "label": "struct ICcExchangeRouter.chainIdStruct",
        "members": [
          {
            "astId": 25607,
            "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
            "label": "middleChain",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 25609,
            "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
            "label": "destinationChain",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(extendedCcExchangeRequest)25649_storage": {
        "encoding": "inplace",
        "label": "struct ICcExchangeRouter.extendedCcExchangeRequest",
        "members": [
          {
            "astId": 25634,
            "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
            "label": "chainId",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 25636,
            "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
            "label": "isTransferredToOtherChain",
            "offset": 0,
            "slot": "1",
            "type": "t_bool"
          },
          {
            "astId": 25638,
            "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
            "label": "remainedInputAmount",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          },
          {
            "astId": 25640,
            "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
            "label": "bridgeFee",
            "offset": 0,
            "slot": "3",
            "type": "t_uint256"
          },
          {
            "astId": 25642,
            "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
            "label": "thirdParty",
            "offset": 0,
            "slot": "4",
            "type": "t_uint256"
          },
          {
            "astId": 25644,
            "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
            "label": "protocolFee",
            "offset": 0,
            "slot": "5",
            "type": "t_uint256"
          },
          {
            "astId": 25646,
            "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
            "label": "thirdPartyFee",
            "offset": 0,
            "slot": "6",
            "type": "t_uint256"
          },
          {
            "astId": 25648,
            "contract": "contracts/routers/CcExchangeRouterLogic.sol:CcExchangeRouterLogic",
            "label": "lockerFee",
            "offset": 0,
            "slot": "7",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "256"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      }
    }
  }
}